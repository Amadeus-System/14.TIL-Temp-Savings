* Date : 2022-05-22
* Last-Devised : 2022-05-23

# 파이썬으로 쉽게 풀어쓴 자료구조 (Data Structures Using Python)

# Chapter 01. Data Structures and Algorithms

## 1.1 자료구조와 알고리즘

### 자료구조란?

인터넷과 정보통신기술의 발달에 따라 지금 우리는 고도로 정보화된 시대를 살아가고 있다. 일부 사람들만이 지식과 정보를 소유하던 시대는 끝나고 모든 사람이 다양한 자료를 활용하고 공유하며 생산하는 시대가 되었다. 이와 같은 정보의 홍수 시대에는 자료의 양이 아니라 얼마나 효율적으로 이들을 관리하고 사용하는가가 훨씬 중요해졌다.

우리는 일상에서 많은 물건이나 자료를 사용한다. 어떤 사람들은 이들을 잘 정리하지만 그렇지 못한 사람들도 많다. 책상이나 옷을 정리하고 스마트폰에서 사진들을 분류하고 컴퓨터에서 파일들을 정리해야 한다. 이것은 다소 귀찮은 일이지만 정리가 잘 되어 있으면 찾거나 사용할 때 매우 편리할 것이다. 그렇다면 왜 정리하는 것이 피곤할까? 아마도 규칙을 찾는 것이 귀찮아서일 것이다. 해야 할 일들은 순서대로 수첩에 기록하고, 빌린 책은 반납일 순으로 책꽃이에 보관하면 편리하다. 영어사전에는 단어들이 알파벳순으로 정렬되어 저장되어 있고, 컴퓨터에는 폴더들이 계층적으로 만들어져 있다. 지도에는 도시들의 연결상태가 알아보기 쉽게 표시되어 있다. 즉, **자료마다 효율적인 정리규칙이 있는 것이다**.

![자료구조 그림](https://user-images.githubusercontent.com/76824867/169798823-280d69cf-4a54-4b1c-b739-f7a00389f1d1.PNG)

컴퓨터는 현실세계에서의 반복적이고 복잡한 자료들을 효율적으로 처리하기 위한 기계이다. 컴퓨터를 이용하여 자료를 처리하려면 먼저 컴퓨터가 잘 다룰 수 있는 형태로 표현해 주어야만 한다. 사람들이 사물을 편리하고 효율적으로 사용하기 위해 정리하는 것과 마찬가지로 컴퓨터에서도 자료들을 정리하고 조직화하는 여러가지 구조들이 있다. 이를 **자료구조(Data Structure)**라 부른다.

자료구조는 숫자나 문자와 같은 **단순 자료구조**와 여러 자료들을 한꺼번에 보관하는 **컨테이너(Container)**와 같은 **복합 자료구조**로 나눌 수 있다. 여기서는 복합 자료구조를 다루는데 이들은 형태에 따라 다시 2가지로 나누어진다.

* **선형(Linear) 자료구조** : 항목들을 **순서적**으로 나열하여 저장하는 창고이다. 항목들에 접근하는 방법에 따라 다시 세분화되는데, **스택**이나 **큐**, **덱**은 항목의 접근이 맨 앞(전단)이나 맨 뒤(후단)로 제한된다. **리스트**는 가장 자유로운 선형 자료구조로 임의의 위치에 항목을 삽입하거나 삭제할 수 있다.
* **비선형(Non-linear) 자료구조** : 저장되는 항목들이 보다 복잡한 연결관계를 갖는다. **트리**는 회사의 조직도나 컴퓨터의 폴더와 같은 계층구조를 표현하기에 적합하고, **힙** 트리는 우선순위 큐를 효율적으로 구현할 수 있다. **이진 탐색트리**나 **AVL 트리**는 탐색을 위한 트리구조이다. **그래프**는 지도나 인터넷 망 등 가장 복잡한 연결관계를 표현할 수 있는데, 특히 간선에 가중치가 할당된 **가중치 그래프**는 최단경로탐색과 같은 다양한 문제를 해결하기 위한 기본구조로 사용된다.

![그림 1 1](https://user-images.githubusercontent.com/76824867/169798860-770cde61-d4fa-4629-9afd-9dac48822b1b.PNG)

[그림 1.1] 자료구조의 분류와 이 책의 구성

이러한 다양한 자료구조는 **배열 구조**와 **연결된 구조**의 2가지 방법으로 표현할 수 있다. 또한 많은 알고리즘들은 **순환(Recursion)**이나 **반복**구조를 이용해 구현할 수 있다. 반복과 달리 순환은 어떤 함수가 자기 자신을 다시 호출하여 문제를 해결하는 재미있는 해결방법이다. 컴퓨터의 가장 대표적인 응용은 정렬과 탐색이다. **정렬**은 주어진 자료들을 어떤 기준에 따라 순서대로 나열하는 것으로, 효율적인 정렬을 위해서는 다양한 자료구조를 활용해야 한다. 효율적인 **탐색**을 위해서도 반드시 적절한 자료구조와 그에 따른 알고리즘을 사용해야 한다. 앞으로 이러한 내용들을 모두 다룰 것이다.


### 알고리즘이란?

컴퓨터 프로그램은 무엇으로 이루어져 있을까? 대부분의 프로그램은 어떤 데이터를 처리하고 그 결과를 제공한다. 이때 데이터는 **자료구조**를 이용하여 표현되고, 이를 이용해 주어진 문제를 처리하기 위한 효과적인 절차가 필요하다. 이와 같이 어떤 문제를 해결하는 절차를 **알고리즘(Algorithm)**이라고 한다. 결국 프로그램은 자료구조와 알고리즘으로 구성되어 있다고 볼 수 있다.

(자료구조 + 알고리즘 = 프로그램 그림 삽입)

영어사전에서 특정한 단어를 찾는 2가지 방법(알고리즘)을 생각해보자.

* 방법 1 : 사전의 첫 페이지에 있는 첫 단어부터 시작하여 사전의 모든 단어를 순서대로 찾는 것이다. 이것은 확실하기는 하지만 엄청난 시간이 걸리는 비효율적인 방법이다.
* 방법 2 : 사전의 단어들이 알파벳순으로 정렬되어 있는 것을 이용한다. 즉, 찾고자 하는 단어가 "structure"이면 먼저 "s"로 시작하는 위치로 바로 이동한다. 만약 너무 적게 갔으면 약간 앞으로 더 가고, 너무 많이 갔으면 조금 뒤로 간다. 이 과정을 "structure"란 단어를 찾을 때까지 반복한다.

단어들이 배열에 저장되어 있다고 생각하면 이 **배열이 자료구조**에 해당하고, 단어를 **찾는 방법이 알고리즘**에 해당한다. 물론 2번째 방법이 훨씬 좋은 알고리즘이고, 우리는 이 방법으로 사전을 찾는다. 그런데 만약 사전에 단어들이 정렬되어 있지 않다면 우리는 어쩔 수 없이 첫번째 방법을 사용해야 한다.

(자료구조와 알고리즘은 밀접한 관계가 있다.)

자료구조와 알고리즘은 밀접한 관계가 있다. 단어찾기의 예시에서와 같이 **더 좋은 알고리즘을 사용하기 위해서는 대부분의 경우 더 복잡한 자료구조를 사용**해야 한다. 컴퓨터에서 복잡한 자료들을 빠르게 저장하고 검색, 분석하기 위해서는 반드시 주어진 문제해결에 가장 적합한 자료구조와 알고리즘을 찾아야 하는 것이다.


### 알고리즘의 조건

알고리즘은 주어진 문제를 논리적으로 해결하기 위해 필요한 절차나 방법, 명령어들을 모아놓은 것이다. 특히 컴퓨터에서는 알고리즘을 **특정한 일을 수행하는 명령어들의 집합**으로 볼 수 있는데, 이때 명령어란 컴퓨터에서 수행되는 문장들을 의미한다. 이러한 절차와 문장들은 프로그래밍 스타일이나 언어와는 무관하다. 즉, 알고리즘은 파이썬이나 C, C++, JAVA 등 사용되는 프로그래밍 언어와는 관련이 없다. 그렇다고 모든 명령어들의 집합이 알고리즘이 되는 것도 아니다. 알고리즘은 다음 조건들을 만족해야 한다.

정의 1.1 알고리즘의 조건

* 입력 : 0개 이상의 입력이 존재하여야 한다.
* 출력 : 1개 이상의 출력이 존재하여야 한다.
* 명백성 : 각 명령어의 의미는 모호하지 않고 명확해야 한다.
* 유한성 : 한정된 수의 단계 이후에는 반드시 종료되어야 한다.
* 유효성 : 각 명령어들은 실행가능한 연산이어야 한다.

알고리즘에는 입력은 없어도 되지만, 출력은 반드시 하나 이상 있어야 한다. 모호한 방법으로 기술된 명령어들의 집합도 알고리즘이 될 수 없다. 또 컴퓨터가 실행할 수 없는 명령어 (예를 들면, 0으로 나누는 연산)를 사용하면 역시 알고리즘이 아니다. 무한히 반복되는 명령어들의 집합도 알고리즘이 아니다.


### 알고리즘의 기술 방법

알고리즘을 기술하는 방법에는 1) 영어나 한국어와 같은 **자연어**, 2) **흐름도(Flowchart)**, 3) **유사코드(Pseudo-code)**, 그리고 4) 특정한 프로그래밍 언어(예를 들면 C, JAVA, Python)를 사용하는 4가지 방법이 있다. $n$개의 숫자를 저장하고 있는 배열(또는 리스트) $A$에서 최대값을 찾는 알고리즘을 이러한 4가지 방법으로 기술해보자.


![그림 1 2](https://user-images.githubusercontent.com/76824867/169798863-b6c5148e-73f1-4199-822c-d1044c096ac6.PNG)

[그림 1.2] 최대값을 찾는 알고리즘의 4가지 표현방법


* 자연어로 표현 : find_max(A)
    1. 배열 $A$의 첫번째 요소를 변수 tmp에 복사한다.
    2. 배열 $A$의 다음 요소들을 차례대로 tmp와 비교하여, 더 크면 그 값을 tmp로 복사한다.
    3. 배열 $A$의 모든 요소를 비교했으면 tmp를 반환한다.
* 흐름도로 표현 :
* 유사코드로 표현 : 
    ```
    find_max(A)
    tmp <- A[0];
    for i <- 1 to size(A) do
        if tmp < A[i] then
            tmp <- A[i]
    return tmp
    ```
* 파이썬으로 표현 :
    ``` Python
    def find_max(A):
        tmp = A[0]
        for item in A:
            if item > tmp:
                tmp = item
        return tmp
    ```

**자연어**는 편리하지만 의미가 애매할 수 있다. **흐름도**는 알고리즘을 명확하게 표현할 수는 있지만 알고리즘이 복잡해지면 그림이 너무 복잡해지므로 여기서는 사용하지 않는다. **유사코드**는 자연어보다는 체계적이지만 프로그래밍 언어보다는 덜 엄격한 방법으로, 프로그래밍 언어에서 발생하는 구현상의 불필요한 표현들을 생략할 수 있어서 흔히 사용되는 알고리즘 표기법이다. **파이썬**으로 구현된 코드는 바로 실행할 수 있는 코드이다. 파이썬은 매우 간결하게 표현되는 것에 유의하라. 따라서 C나 Java와 같은 기존의 언어들에 비해 훨씬 알고리즘의 핵심적인 내용에 대한 표현에 집중할 수 있다.

> 많은 책에서 알고리즘을 유사코드로 먼저 나타내고 C나 Java와 같은 프로그래밍 언어로 구현한다. 이는 실제 코드가 유사코드에 비해 너무 길기 때문이다. 그러나 파이썬의 경우 **유사코드와 실제 코드의 차이가 별로 없다**. 따라서 여기서는 많은 경우 유사코드 없이 바로 파이썬 코드로 알고리즘을 설명한다.


## 1.2 추상 자료형

### 추상자료형(Abstract Data Type, ADT)이란?

프로그래머가 추상적으로 정의한 자료형을 말한다. 추상자료형은 어떤 **자료들**과 자료에 가해지는 **연산들**을 구체적으로 표시한다. 이때 "추상"의 의미는 **어떤(What?) 자료나 연산이 제공**되는가 만을 정의하고 이들이 **어떻게(How?)** 구현되는가는 정의하지 않는다는 것을 말한다. 예를 들어, 물건을 넣을 수 있는 가방(Bag)이라는 자료구조에 대한 추상적인 자료형을 정의해보자. 가방이 어떤 자료를 갖고 어떤 연산을 제공해야 할지를 결정해야 한다.

![그림 1 3](https://user-images.githubusercontent.com/76824867/169798865-02e46731-ff5a-42e3-a3d7-cbc0dea4aea9.PNG)

(그림 1.3 가방(Bag)의 추상자료형)

* 데이터 : 지갑, 휴대폰, 거울, 동전 등 여러가지 물건을 넣을 수 있는 저장소이다. 물론 동전을 여러 개 넣을 수도 있다.
* 연산 : 가방으로 할 수 있는 일은 어떤 것이 있을까? 휴대폰을 넣거나 뺄 수 있어야 할 것이며, 지갑이 가방에 있는지를 확인할 수도 있어야 한다. 가방에 몇 개의 물건이 있는지도 알려주면 좋을 것이다. 이들을 모두 가방의 연산으로 추가할 수 있다. 넣고 빼는 연산은 insert(), remove()라 하고, 물건이 있는지 확인하는 것은 contains(), 물건의 개수 검사는 count()라 하면 되겠다.

추상자료형은 자신을 사용하는 사용자 프로그램에게는 구현에 관한 세부사항들은 감추고 간단한 **인터페이스(Interface)**만을 공개한다. 사용자는 공개된 인터페이스만 사용하고 이것이 어떻게 구현되었는지를 알 필요가 없다. 추후에 구현방법이 변경되더라도 인터페이스만 정확하게 지켜진다면 사용자는 변경된 내용을 힘들게 공부할 필요없이 기존과 동일하게 사용할 수 있다. 이것이 **정보은닉(Information Hiding)**의 기본개념이다.


### Bag 추상자료형을 정의하고 구현해보자.

앞에서 살펴본 내용을 바탕으로 Bag의 추상자료형을 정의하면 다음과 같다.

정의 1.2 Bag 추상자료형

* 데이터 : 중복된 항목을 허용하는 자료들의 저장소. 항목들은 특별한 순서가 없이 개별적으로 저장되지만 항목간의 비교는 가능해야 함.
* 연산 :
    * Bag() : 비어있는 가방을 새로 만든다.
    * insert(e) : 가방에 항목 e를 넣는다.
    * remove(e) : 가방에 e가 있는지 검사하여 있으면 이 항목을 꺼낸다.
    * contains(e) : e가 들어있으면 True, 없으면 False를 반환한다.
    * count() : 가방에 들어있는 항목들의 수를 반환한다.


이제 Bag ADT를 파이썬으로 구현해보자. 파이썬을 잘 모른다고 걱정할 필요는 없다. 다음 장에서 공부할 예정이기 때문이다. Bag을 위한 데이터로는 **파이썬의 리스트**를 사용하였다. 연산들은 **함수로 구현**하였는데, 파이썬 리스트에서 제공하는 기능들을 이용하여 다음과 같이 매우 직관적이고 간단하게 구현할 수 있다.

``` Python
def contains(bag, e):       # bag에 항목 e가 있는지 검사하는 함수
    return e in bag         # 파이썬의 in 연산자 사용

def insert(bag, e):         # bag에 항목 e를 넣는 함수
    bag.append(e)           # 파이썬 리스트의 append 메서드 사용

def remove(bag, e):         # bag에서 항목 e를 삭제하는 함수
    bag.remove(e)           # 파이썬 리스트의 remove 메서드 사용

def count(bag):             # bag의 전체 항목 수를 계산하는 함수
    return len(bag)         # 파이썬의 len 함수 사용
```

테스트를 위한 코드는 다음과 같다. 먼저 파이썬의 리스트 객체를 만들고 insert 연산을 이용해 휴대폰, 지갑 등 6개의 물건을 삽입하고, Bag의 내용을 출력하였다. 추가로 "빗"을 넣고 "손수건"을 가방에서 꺼낸 후 내용을 다시 출력한 코드이다.

> 매개변수 bag이 파이썬의 리스트 객체라고 생각하고 리스트에서 제공하는 연산들을 이용해 구현하였다. 파이썬의 리스트에 대한 자세한 내용은 2.6절과 3.2절을 참고하라. 다음은 코드에서 사용된 연산들의 의미를 설명한다.
> * e in bag은 bag에 e가 있으면 True, 없으면 False를 반환한다.
> * bag.append(e) 연산은 리스트 bag의 맨 뒤에 항목 e를 추가한다.
> * bag.remove(e) 연산은 리스트 bag에서 항목 e를 삭제한다.
> * len(bag)은 리스트 bag에 들어있는 항목들의 수를 반환하는 함수이다.
> * print()는 화면출력 함수이다. 2.4절을 참고하라.

``` Python
myBag = []                          # Bag을 위한 빈 리스트 생성
insert(myBag, '휴대폰')             # Bag에 휴대폰 삽입
insert(myBag, '지갑')               # Bag에 지갑 삽입
insert(myBag, '손수건')             # Bag에 손수건 삽입
insert(myBag, '빗')                 # Bag에 빗 삽입
insert(myBag, '자료구조')           # Bag에 자료구조 삽입
insert(myBag, '야구공')             # Bag에 야구공 삽입
print('가방속의 물건 :', myBag)     # Bag의 내용 출력

insert(myBag, '빗')                 # Bag에서 '빗' 삽입(중복)
remove(myBag, '손수건')             # Bag에서 '손수건' 삭제
print('가방속의 물건 :', myBag)     # Bag의 내용 출력
```

모든 연산의 매개변수에 bag이 있는 것에 유의하라. 이것은 여러개의 가방 중에서 어느 가방에 연산을 적용할지를 지정하기 위해서이다. 파이썬의 다양한 함수나 내장자료형 리스트는 다음 장부터 천천히 공부해나갈 것이므로 잘 모르겠더라도 크게 걱정할 필요는 없다.

사실 **추상자료형**은 일반함수보다는 **클래스로 구현하는 것이 더 바람직**하다. 추상자료형의 **데이터와 연산**이 클래스의 **상태(State)와 행위(Behaviour)**에 정확히 대응되기 때문이다. 클래스도 2장에서 공부한다. 실습문제 2.3을 통해 Bag을 클래스로 구현해볼 것이다.


## 1.3 알고리즘의 성능 분석

### 알고리즘의 실행시간을 측정해보자.

알고리즘의 효율성은 계산속도와 메모리 사용량으로 평가됨, 즉 좋은 알고리즘은 실행시간이 짧으면서 메모리와 같은 컴퓨터의 자원들을 적게 사용하는 것이다. 일반적으로 실행시간이 메모리 공간보다 더 중요하게 인식되므로 실행시간을 효율적인 알고리즘의 기준으로 삼는다.


![4](https://user-images.githubusercontent.com/76824867/169798833-3363a9e3-d8e8-4743-b8af-92f7b97d5e01.PNG)


Bag에 물건을 넣는 insert 연산의 경우, 가방을 잘 정돈하고 좋은 알고리즘을 사용하면 물건을 넣는 시간이 단축됨, 반대로 나쁜 알고리즘을 사용하면 가방에 물건을 하나 넣기 위해서도 번거로운 작업과 많은 시간이 필요. 이러한 **알고리즘의 효율성은 항목들을 어떤 구조로 관리하는지, 즉 사용하는 자료구조에 따라 큰 영향을 받는다.**

알고리즘의 효율성 측정하는 확실한 방법 -> 알고리즘 구현하여 실제 컴퓨터로 실행하고, 실행시간 측정하는 것, insert 연산을 2가지 알고리즘으로 구현했는데, 알고리즘 A는 10초 걸리고, B는 50초 걸렸다면 알고리즘 A가 더 효율적인 알고리즘.

파이썬에서는 다음과 같은 방법으로 실행시간 측정가능

```python
import time             # time 모듈 불러오기

myBag = []              # 비어있는 새로운 가방 하나 만듬
start = time.time()     # 현재 시각을 start에 저장
insert(myBag, '축구공')  # 실행시간 측정하려는 코드
...

end = time.time()               # 현재 시각을 end에 저장
print('실행시간 =', end - start) # 실행시간(종료-시작) 출력
```

time 모듈은 운영체제가 제공하는 다양한 시간관련 기능을 제공, time.time()은 컴퓨터의 현재 시각 반환하는 함수.

이러한 시간측정 방법은 매우 직관적이고 간단함, 그런데 실행시간 측정방법으로 알고리즘의 성능을 비교하려면 몇가지 문제가 있다.

* (당연히) 알고리즘을 반드시 "구현"해야 한다. 간단한 알고리즘이면 쉽게 구현할 수 있지만, 복잡한 경우에는 구현하는 것이 큰 부담이다.
* 반드시 동일한 조건의 하드웨어를 사용하여 실행시간 측정해야 한다. 아주 비효율적인 알고리즘도 슈퍼컴퓨터상에서 실행하면, 가장 효율적인 알고리즘을 스마트폰에서 실행하는 것보다 더 빠를 수 있기 때문
* 소프트웨어 환경도 동일해야 한다. 예를 들면, 구현에 사용된 프로그래밍 언어에 따라 실행속도가 크게 달라질 수 있음, 보통 C나 C++ 같은 컴파일 방식의 언어를 사용한 경우가 파이썬(Python)이나 베이직과 같이 명령어를 직접 실행하는 인터프리터 방식보다 빠르다.
* 성능비교에 사용했던 데이터가 아닌 다른 데이터에 대해서는 다른 결과가 나올 수 있음, 실험되지 않은 입력에 대해서는 실행시간 주장할 수 없다.

그렇다면 구현하지 않고서도 알고리즘의 효율성을 따져보는 방법은 없을까? 물론 있다. 

이것은 큰 그림(Big-picture)를 그려서, 절대적인 실행시간을 측정하지 않고, 입력 개수가 증가함에 따라 실행시간이 어떤 형태로 증가하는지를 분석하는 방법이다.


![5](https://user-images.githubusercontent.com/76824867/169798836-f6bb44cc-55e9-40b0-a7a5-21b5cf39be2d.PNG)


### 알고리즘의 복잡도 분석이란?

여러 알고리즘이 있을 때 구현하지 않고 각 알고리즘의 효율성을 비교하는 것은 알고리즘의 **복잡도분석(Complexity Analysis)**으로 가능. 입력의 개수를 n이라 할 때, 이 방법은 n이 증가함에 따라 실행시간이 **어떤 형태로 증가하는지**만을 분석, 알고리즘 구현하지 않고도 모든 입력에 대해 실행 하드웨어나 소프트웨어 환경과 관계없이 알고리즘의 효율성을 평가가능.

Bag에 **n개의 물건이 들어있는 상태에서 새로운 물건을 넣는 연산** 생각하자, 가방의 자료구조와 insert() 알고리즘이 효율적이라면 1번에 넣을 수 있을 것, 그러나 항상 그렇지는 않다, 가방의 정리 방법이 효율적이지 않다면 먼저 들어가있는 물건들을 모두 한쪽으로 밀고 공간을 만든 후 새로운 물건을 넣어야 할 것이다, 이 경우 물건 하나를 넣기 위해 n번 이상의 처리 또는 연산이 필요할 수도 있다.

앞서 정의한 insert()를 다른 방식으로 구현해보자, 물건을 항상 리스트의 맨 앞에 넣을 수도 있는데, 다음과 같이 구현된다.

```python
def insert(bag, e):     # bag에 항목 e를 넣는 함수
    bag.insert(0, e)    # 파이썬 리스트의 맨 앞에 추가
```

파이썬의 리스트는 맨 뒤에는 바로 삽입할 수 있지만 앞에 넣으려면 삽입할 위치 이후의 모든 항목을 한칸씩 뒤로 밀어야, 빈자리가 생겨 삽입가능하다.

즉, append(e)는 가방을 열어 맨 위에 옷(e)을 넣고 닫는 동작이라면, insert(0, e)는 오른쪽과 같이 가방에 들어있던 옷을 먼저 다 꺼내고, 새 옷을 맨 밑에 넣은 다음, 다시 꺼냈던 옷들을 그 위에 올리는 것과 같은 연산이다,

리스트에 n개의 항목이 있다면, append(e)는 n과 상관없이 1번만에 처리되지만, insert(0, e)는 기존의 모든 항목을 이동해야 하므로 n에 비례하는 시간이 걸리는 비효율적인 연산이다. 놀랍게도 우리는 알고리즘을 컴퓨터에서 실행해보지도 않고 두 알고리즘의 효율성을 분석하였다!

이와 같이 복잡도분석 방법은 절대적인 실행시간이 아니라 알고리즘을 이루고 있는 연산들의 횟수를 분석한다. 이들은 보통 입력의 개수 n에 영향을 받는데, **연산의 수를 n의 함수로 나타낸 것**을 시간복잡도 함수 $T(n)$이라고 표기한다. 

예를 들어, 다음과 같이 양의 정수 n의 제곱, 즉 $n^2$을 구하는 3가지 알고리즘을 생각해보자.

* 알고리즘 A: 곱셈연산을 이용해 n과 n을 곱하는 (n * n) 방법
* 알고리즘 B: 덧셈연산을 이용해 n을 n번 더하는 방법
* 알고리즘 C: 덧셈연산을 이용해 1을 n * n번 더하는 방법

이 알고리즘들을 유사코드로 나타내면 다음과 같다.

![표 1.1](https://user-images.githubusercontent.com/76824867/169798878-1144de6f-2a90-4391-a8ec-259fa7163f2d.PNG)


실제로는 연산들(덧셈, 곱셈, 대입 등)마다 처리시간이 조금씩 다름, 그러나 시간복잡도 함수를 구할 때에는 이것이 중요하지 않으며, 모든 연산에 동일한 시간이 걸린다고 가정한다, 이제 시간복잡도 함수를 그래프로 그려보자, n이 커질수록 알고리즘간의 연산량의 차이가 커짐을 알 수 있고, 효율적인 알고리즘이 무엇인지 판단할 수 있다.


![[그림 1.5] n2을 구하는 3가지 알고리즘의 복잡도 함수](https://user-images.githubusercontent.com/76824867/169798867-e020e78f-b677-407b-aa47-69178f6de5d1.PNG)

[그림 1.5] n2을 구하는 3가지 알고리즘의 복잡도 함수



### 빅오표기법

시간복잡도 함수 $T(n)$은 입력의 개수 $n$에 대한 상당히 복잡한 수식으로 나타낼 수 있다. 그러나 $n$이 커질수록 **차수가 가장 큰 항의 영향력이 절대적**이 된다. 시간복잡도 함수 $T(n) = n^2 + n + 1$을 생각해보자.

* $n = 1$일 때 : $T(n) = 1 + 1 + 1 = 3$ ($n^2$항이 33.3%)
* $n = 10$일 때 : $T(n) = 100 + 10 + 1 = 111$ ($n^2$항이 90%)
* $n = 100$일 때 : $T(n) = 10000 + 100 + 1 = 10101$ ($n^2$항이 99%)
* $n = 1000$일 때 : $T(n) = 1000000 + 1000 + 1 = 1001001$ ($n^2$항이 99.9%)

우리는 Big Picture를 생각한다는 것을 기억하라. 앞의 계산결과를 보면 시간복잡도 분석에서는 함수의 전체 항이 아니라 **최고차항만**을 고려하면 될 것임을 짐작하게 한다. 결국 중요한 것은 $n$에 대해 연산이 정확히 몇 번 필요한가가 아니라 $n$이 증가함에 따라 무엇에 비례하는 수의 연산이 필요한가이다. 예를 들어, 그림 1.5의 세 알고리즘의 그래프에서도 중요한 것은 정확한 연산의 수가 아니라 그래프의 형태이다. 이와 같이, 시간복잡도 함수에서 불필요한 정보를 제거하고 알고리즘 분석을 쉽게 할 목적으로 시간복잡도 함수를 표시하는 방법을 빅오 표기법이라고 하는데, 다음과 같이 정의한다.

정의 1.3 빅오 표기법

> 2개의 함수 $f(n)$과 $g(n)$이 주어졌을 때 모든 $n \geq n_0$에 대해 $|f(n)| \leq c |g(n)|$을 만족하는 상수 $c$와 $n_0$가 존재하면 $f(n) = O(g(n))$이다.

여기서 어떤 수 $c$와 $n_0$에 대해서는 아무런 제약이 없음에 유의하라. 이러한 부등식을 만족하는 $c$나 $n_0$는 무수히 많을 수 있다. 예를 들어, $f(n)$이 $2n^2 + 3n + 1$이고 $g(n)$은 $n^2$이라면 $n \geq n_0$일 때 부등식 $|2n^2 + 3n + 1| \leq c|n^2|$를 만족하는 $c$와 $n_0$ 쌍은 (6, 1), (5, 2), (4, 3), ... 등이 가능하다. 따라서 위의 정의에 의하여 $2n^2 + 3 + 1 = O(n^2)$이라 말할 수 있다.

$n^2$을 구하는 3가지 알고리즘의 시간복잡도는 각각 다음과 같다.

* $T_A(n) = 2 \longrightarrow O(1)$
* $T_B(n) = 2n + 1 \longrightarrow O(n)$
* $T_C(n) = 2n^2 + n + 1 \longrightarrow O(n^2)$

다음과 같이 $n$이 매우 커지게 되면 $f(n)$ 값은 결국 $g(n)$보다 작거나 같아지는데, 이것은 $g(n)$이 $f(n)$의 상한이라는 것을 의미한다. 따라서 빅오 표기법은 $n$에 따른 **함수의 상한**을 나타낸다.


![6](https://user-images.githubusercontent.com/76824867/169798838-a39b38b2-7f6d-4249-a62b-663acfc57f70.PNG)


빅오 표기법은 입력의 개수에 따른 기본 연산의 수행 횟수를 개략적으로 나타낸 것으로 알고리즘의 성능비교에 사용된다. 예를 들어, $O(n)$ 알고리즘은 $O(n^2)$ 알고리즘보다 훨씬 빠르다고 할 수 있다. 다음은 자주 사용되는 빅오 표기와, $n$이 증가할 때 각 함수가 어떻게 증가하는지를 보여준다.


[그림 1.6] $n$이 증가함에 따라 시간복잡도 함수의 증가

상수형인 $O(1)$은 $n$이 변화하더라도 항상 일정한 시간에 처리되고, $O(n)$은 $n$에 비례하는 시간이 걸린다는 것을 말한다. 지수형($O(2^n)$, $O(3^n)$)이나 팩토리얼형($O(n!)$)은 입력이 32개만 되더라도 강력한 슈퍼컴퓨터로 지구가 탄생하여 지금까지 흘러온 시간보다 더 많은 실행시간이 요구된다!


### 빅오메가와 빅세타 표기법

빅오 표기법에는 한 가지 문제가 있다. 예를 들어, $f(n) = 2n + 1$인 경우 $O(n)$ 알고리즘이지만, 사실은 $O(n^2)$ 알고리즘이기도 하다. 왜냐하면, $n_0 = 1$, $c = 4$로 잡으면 $n \geq 1$에 대하여 $2n + 1 \leq 4n ^2$이기 때문이다. 빅오 표기법은 상한을 표기한 것이므로 상한은 여러개가 존재할 수 있다. 물론 **빅오 표기법이 최소 차수 함수로 표기되었을 경우만 의미가 있다**. 빅오의 이와 같은 문제점을 보완하기 위하여 빅오메가와 빅세타 표기법이 있다. **빅오메가(Big Omega)**는 어떤 함수의 하한을 표시하는 방법이고, **빅세타(Big Theta)**는 동일한 함수로 상한과 하한을 만들 수 있는 경우를 나타내는데, 정의는 다음과 같다.

정의 1.4 빅오메가 표기법

2개의 함수 $f(n)$과 $g(n)$이 주어졌을 때 모든 $n \geq n_0$에 대해 $|f(n)| \geq c|g(n)|$을 만족하는 상수 $c$와 $n_0$가 존재하면 $f(n) = \Omega(g(n))$이다.


정의 1.5 빅세타 표기법

2개의 함수 $f(n)$과 $g(n)$이 주어졌을 때 모든 $n \geq n_0$에 대해 $c_1 |g(n)| \leq f(n) \leq c_2 |g(n)|$을 만족하는 상수 $c_1$, $c_2$와 $n_0$가 존재하면 $f(n) = \Theta (g(n))$이다.


3개의 표기법을 그래프로 비교하면 그림과 같다. 이들 중에서 가장 정밀한 것은 역시 빅세타이지만, 통상적으로 빅오 표기법을 많이 사용한다. 단, 그때는 최소차수로 상한을 표시를 한다고 가정한다.

[그림 1.7] 빅오, 빅오메가, 빅세타 표기법의 비교



### 입력 데이터에 따른 성능 차이

같은 알고리즘도 입력의 종류에 따라 다른 실행시간을 보일 수 있다. 학교에 등교하는 간단한 알고리즘을 생각해보자. 버스정류장까지 걸어가서 버스를 타고 학교 앞에서 내려 학교로 등교하는 것이다. 알고리즘은 동일하지만 특히 버스가 언제 도착하느냐에 따라 전체 등교시간이 달라질 수 있다.


![7](https://user-images.githubusercontent.com/76824867/169798840-d17841ca-543d-446a-940d-1ab9b4ba313b.PNG)


* **최선의 경우(Best Case)** : 정류장에 오자마자 바로 버스가 도착한다. 가장 빨리 등교할 수 있지만, 항상 이 상황을 기대할 수는 없다.
* **평균적인 경우(Average Case)** : 평균적인 시간에 버스가 도착한다. 예를 들어, 일 년 동안 버스를 기다린 시간의 평균을 평균적인 경우로 볼 수 있다.
* **최악의 경우(Worst Case)** : 이전 버스가 출발하자마자 정류장에 도착한 상황이다. 가장 많이 기다려야 하지만 반대로 이 상황을 고려해서 집에서 출발한다면 절대 지각하지 않는다.


대부분의 경우 알고리즘에 최대한 불리한 입력 데이터를 사용하는 **최악의 경우의 실행시간이 가장 중요**하다. 예를 들어, 비행기 관제 업무에 사용되는 알고리즘은 어떤 입력에 대해서도 항상 제한된 시간 안에 안전한 관제신호를 생성해야 오류에 의해 발생할 수 있는 중대한 사고를 피할 수 있다.


![8](https://user-images.githubusercontent.com/76824867/169798843-f9689fdb-64ff-499f-8bb1-629e7f3cd4c6.PNG)


## 1.4 시간 복잡도 분석 : 순환 알고리즘

순환 알고리즘들을 공부해보고, 시간복잡도를 분석을 적용해보자.

순환(Recursion), 또는 재귀호출이란 어떤 함수가 자기 자신을 다시 호출하여 문제를 해결하는 프로그래밍 기법이다. 이는 조금 이상하게 보일 수 있지만, 매우 흥미롭고 중요한 프로그래밍 기법의 하나로, 특히 트리구조(8, 9장)에서 많이 사용된다.


### 순환 알고리즘이란?

순환은 본질적으로 순환적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다. 

예를 들어 정수의 팩토리얼(Factorial)은 다음과 같이 정의된다.

$ 
f(x) = 
\begin{cases}
    1            & n = 1 \\
    n * (n - 1)! & n > 1 \\
\end{cases}
$

위의 정의에서 팩토리얼 n!을 정의하는데 다시 (n-1)!이 사용된 것에 주목하자. 이러한 정의를 순환적이라 한다. 위의 정의에 따라 n!을 구하는 함수 factorial(n)을 파이썬으로 작성하면 다음과 같다.


![9](https://user-images.githubusercontent.com/76824867/169798845-476cc64f-1567-4272-add7-9481b0fa6479.PNG)


```python
def factorial(n):                   # 순환적으로 구현한 factorial 함수
    if n == 1:                      # 종료조건 : 순환을 멈추는 부분
        return 1
    else:
        return n * factorial(n - 1) # 자기 자신을 순환적으로 호출
```

순환함수는 자신을 순환적으로 호출하는 부분과 순환 호출을 멈추는 부분으로 구성되어 있다. 만약 순환 호출을 멈추는 부분이 없다면 시스템 스택을 다 사용할 때까지 순환적으로 호출되다가 결국 오류를 내면서 멈출 것이다. Factorial(3)이 호출되었을 때 순환적으로 호출되고 반환되는 과정은 다음과 같다.


![10](https://user-images.githubusercontent.com/76824867/169798849-15c46276-5b54-4d3a-a3ce-17b30b25dfaa.PNG)


그렇다면 이 알고리즘의 시간복잡도는 어떻게 될까? 곱셈의 횟수로 생각해보자. 한번 호출할 때마다 1번의 곱셈이 수행되고, 전체 순환호출은 n번이 일어난다. 따라서 시간복잡도는 O(n)이다.

많은 경우, 순환은 반복(iteration) 구조로 변환할 수 있다. 특히 순환호출이 끝에서 이루어지는 경우는 다음과 같이 간단한 반복 구조로 바꿀 수 있다.

순환 구조 : n! = n * (n - 1)! --> 반복 구조 : n! = n * (n - 1) * (n - 2) * ... * 1

```python
def factorial(n):               # 반복 구조로 구현한 Factorial 함수
    result = 1
    for k in range(n, 0, -1):   # k: n, n-1, ..., 2, 1 (2.5절 참조)
        result = result * k
    return result
```

반복 알고리즘은 for 루프가 n번 반복하므로 시간복잡도는 O(n)으로, 순환의 시간복잡도와 동일하다. 순환은 트리와 같은 특정한 문제에 대해 반복에 비해 훨씬 명확하고 간결한 알고리즘을 나타내지만, 실행속도 면에서는 많은 경우 함수 호출의 부담에 의해 반복보다 느리다. 결국 순환 알고리즘은 **이해하기 쉽다**는 것과 쉽게 프로그래밍할 수 있다는 장점이 있는 대신 **수행시간과 기억공간의 사용에 있어서는 비효율적**인 경우가 많다.

### 순환이 더 빠른 예시도 있다 : 거듭제곱 구하기

$x$의 $n$-거듭제곱 $x^{n}$을 구하는 함수를 수학 라이브러리를 사용하지 않고 반복구조로 구현해보자. 코드는 다음과 같다.

``` python
def power_iter(x, n):           # 반복으로 x^n을 구하는 함수
    result = 1.0
    for i in range(n):          # 루프 : n번 반복
        result = result * x
    return result
```

이 함수의 시간복잡도는 명확히 $O(n)$이다. 그런데, 더 효율적인 알고리즘이 가능하다. 

$x^{n} = (x^2)^{n/2}$의 공식을 이용하는 것이다. 즉, n이 짝수인 경우에는 $x^2$을 먼저 계산하고 이 값을 n/2승하면 된다. n이 홀수이면 $x^2$을 (n-1)/2승하고 여기에 x를 곱해주면 같은 결과가 된다. 즉, n에 따라 다음과 같이 계산하는 것이다.

* $n$이 짝수인 경우:
    power(x, n) = power($x^2$, $n/2$) = $(x^2)^{n/2}$ = $x^{2(n/2)}$ = $x^n$
* $n$이 홀수인 경우:
    power(x, n) = x * power($x^2$, $(n-1)/2$) = $x * (x^2)^{(n-1)/2}$ = x * x^{n-1} = x^n

이 알고리즘은 다음과 같이 순환구조를 이용해 간단히 구현할 수 있다.

``` Python
def power(x, n):
    if n == 0:
        return 1
    elif (n % 2) == 0:                    # n이 짝수
        return power(x * x, n // 2)       # 정수의 나눗셈 (2.3절 참조)
    else:
        return x * power(x * x, (n-1)//2) # n이 홀수
```

이 알고리즘이 순환적으로 호출될 때마다 문제의 크기가 어떤 비율로 줄어드는가?

처음에는 n승이었다가 다음에 n/2승이 되고 또 n/4승이 되는 식으로 문제의 크기가 줄어든다. **문제의 크기가 하나씩 줄어드는 것이 아니라 절반씩 줄어든다!** 예를 들어, n이 100이라면 다음과 같이 급속히 문제의 크기가 줄어들게 된다.

$$ 100 -> 50 -> 25 -> 12 -> 6 -> 3 -> 1 $$

n을 2의 거듭제곱 값의 하나인 $2^k$라고 가정해보자. 그러면 순환호출을 한번 할 때마다 $n$의 크기가 절반씩 줄어들게 되므로 다음과 같이 줄어든다.

$$ 2^k -> 2^{k-1} -> 2^{k-2} -> ... -> 2^1 -> 2^0 $$

몇 번의 순환호출이 일어나게 되는가? 약 $k$번의 순환호출이 일어나게 됨을 알 수 있다. $n = 2^k$이므로 양변에 log 함수를 취하면 $log_2 n = k$가 된다. n이 2의 거듭제곱이 아닌 경우는 어떻게 될까? 한 번의 순환호출이 일어날 때마다 1번의 곱셈과 1번의 나눗셈이 일어나므로 전체 연산의 개수는 $k = log_2 n$에 비례하게 될 것이고, 따라서 시간복잡도는 $O(log_2 n)$이다. 반복으로 구현한 함수의 $O(n)$보다 훨씬 훌륭한 알고리즘이다.

실제로도 빠를까? $2^500$을 계산하는 power(2.0, 500)과 power_iter(2.0, 500)을 실행하여 계산해서 결과를 먼저 출력하고, 이들 함수를 각각 10만회 반복했을 때의 실행시간을 출력하면 다음과 같다.

두 알고리즘의 실행결과는 동일하고, 순환이 더 빠르다. 알고리즘은 더 복잡해보이고 게다가 함수호출이라는 오버헤드도 있지만 놀랍게도 순환적인 power 함수가 훨씬 효율적이다.

### 순환이 훨씬 느린 경우가 많다 : 피보나치 수열의 계산

보통 순환을 사용하면 코드가 단순화되고 가독성이 높아지지만, 이것 때문에 같은 계산을 몇 번씩 반복해야 한다면 문제가 있을 것이다. 대표적인 예가 피보나치수열이다. **피보나치 수열**은 다음과 같이 순환적으로 정의된다.

$$ 
fib(n) = 
\begin{cases}
    0                   & n = 0 \\
    1                   & n = 1 \\
    fib(n-2) + fib(n-1) & otherwise 
\end{cases}
$$

즉, 일반적인 경우는 앞의 2개의 숫자를 더해서 뒤의 숫자를 만들면 된다. 정의에 따라 수열을 만들어보면 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... 과 같이 된다. 피보나치 수열은 정의 자체가 순환적이므로 다음과 같이 순환호출을 이용하여 구현하는 것이 자연스럽다.

``` Python
def fib(n):                             # 순환으로 구현한 피보나치 수열
    if n == 0:                          # 종료조건
        return 0
    elif n == 1:                        # 종료조건
        return 1
    else:
        return fib(n - 1) + fib(n - 2)  # 순환호출
```

이 함수는 단순하고 이해하기 쉽게 구현되었지만 매우 비효율적이다. 왜 그럴까? 다음 그림을 보자. fib(6)을 호출하면 fib(4)가 2번 반복하여 호출된다. fib(3)은 3번 호출되고 이런 현상은 순환호출이 깊어질수록 점점 심해진다. 따라서 상당히 비효율적이다. fib(6)을 구하기 위해 fib(1) 함수만 총 8번 호출되었고, 전체 fib() 함수가 25번이나 순환호출된 것에 유의하라.

(그림 1.8 순환을 이용한 피보나치 수열 계산의 비효율성)

![그림 1 8](https://user-images.githubusercontent.com/76824867/169798872-e97939e3-09dc-40a6-83b8-1dd0a17a7ada.PNG)


근본적인 이유는 중간에 계산되었던 값을 기억하지 않고 다시 계산하기 때문이다. $n$이 작을 때에는 중복계산이 비교적 적지만, $n$이 커지게 되면 엄청난 순환호출이 필요하게 된다. 예를 들어, $n$이 25이면 거의 25만번의 호출을 해야 하고, $n$이 30이면 약 300만번의 함수호출이 필요하다. 따라서 $n$이 커지면 순환호출을 사용하여 피보나치 수열을 계산하는 것이 거의 불가능해진다. 이 알고리즘의 시간복잡도는 $O(2^n)$으로 매우 비효율적이다.

그렇다면 피보나치 수열을 계산하는데 다른 방법이 있을까? 물론 반복구조를 이용하여 다음과 같이 구현할 수 있다. 이 알고리즘은 n번 루프를 반복한다. 따라서 시간복잡도는 $O(n)$이고 순환에 비해 훨씬 효율적이다.

``` Python
def fib_iter(n):                # 반복으로 구현한 피보나치 수열
    if n < 2:
        return n
    
    last = 0
    current = 1
    for i in range(2, n + 1):   # 반복 루프
        tmp = current
        current += last
        last = tmp
    return current
```

결국 피보나치 수열 문제에서는 순환이 매우 간단하고 이해하기 쉽게 구현할 수 있지만 불행히도 매우 비효율적이다.

피보나치 수열을 구하는 다양한 알고리즘들이 있는데, 이들은 보통 알고리즘 관련 도서에서 다룬다. 피보나치 수열을 반복구조나 동적계획법으로 구현하면 $O(n)$의 시간이 걸리는데, 행렬의 거듭제곱으로 구하는 방법도 있다. 만약 행렬을 사용하고 앞에서의 거듭제곱 구하기 방법을 적용한다면 피보나치 수열의 n번째 수를 심지어 O(log_2 n)만에도 구할 수 있다!

### 순환은 복잡한 문제를 쉽게 해결할 수 있다 : 하노이의 탑

순환의 위력을 가장 극명하게 보여주는 예제가 하노이탑 문제이다. 고대 인도의 베나레스에는 세계의 중심이 있고, 그 곳에는 아주 큰 사원이 있었다. 이 사원에는 높이 50cm 정도 되는 다이아몬드 막대 3개가 있는데, 그 중 한 막대에는 천지창조 때에 신이 구멍이 뚫린 64장의 순금으로 된 원판을 크기가 큰 것부터 아래로 놓이도록 하면서 차례로 쌓아놓았다. 그리고 신은 승려들에게 밤낮으로 쉬지 않고 한 장씩 원판을 옮겨 빈 다이아몬드 막대 중 어느 한 곳으로 모두 옮겨 놓도록 명령하였다. 원판은 한 번에 한 개씩 옮겨야 하고, 절대로 작은 원판 위에 큰 원판을 올려놓을 수 없다. 단, 64개의 원판의 크기는 모두 다르고, 원판의 이동 횟수는 최소로 해야 한다.


![11](https://user-images.githubusercontent.com/76824867/169798850-fb7c6f05-8f2d-418d-ab26-d6c8b7494c63.PNG)


고대 인도의 이 전설의 탑을 **하노이의 탑(The Tower of Hanoi)**이라고 부른다. 주어진 문제를 이해하기 위해 원판의 개수가 3개인 경우를 살펴보자. 문제는 막대 A에 쌓여있는 원판 3개를 막대 C로 옮기는 것이다.


![12](https://user-images.githubusercontent.com/76824867/169798853-5938b0ab-d65b-4920-a781-3d2e44064ca3.PNG)


다음은 3개의 원판이 있는 경우에 대한 다음과 같은 이동의 순서이다.


![13](https://user-images.githubusercontent.com/76824867/169798855-d199fff1-aa9f-4114-b3ec-cec2e7d203eb.PNG)


그림을 보면 3개를 움직이는데도 꽤 복잡하다. 4개의 원판이 있는 경우에는 더 복잡해진다. 만약 일반적으로 n개의 원판이 있는 경우를 해결하려면 상당히 복잡할 것이다.

이제 이 문제를 순환적으로 해결해보자. 순환 알고리즘에서는 **순환이 일어날수록 문제의 크기가 작아져야 한다**. 이 때 문제의 크기는 이동해야 하는 디스크의 수가 될 것이다. n개의 원판이 A에 쌓여있는 문제를 다음과 같이 해결할 수 있을 것이다.

1. 먼저 위에 쌓여있는 n-1개의 원판을 B로 옮긴다. C를 임시막대로 사용한다.
2. 이제 제일 밑에 있는 원판을 바로 C로 옮긴다.
3. B로 옮겨져 있는 n-1개의 원판을 C로 옮긴다. A를 임시막대로 사용한다.

단계 2는 1개의 원판을 이동하는 것이므로 매우 쉽다. 이제 n-1개의 원판을 옮기는 1과 3만 처리할 수 있으면 문제는 해결된다. 중요한 것은 1과 3에서 문제의 크기가 작아졌다는 것이다. n개가 아니라 n-1개만 옮길 수 있으면 된다. 이 방법을 계속 적용한다면 뭔가 답이 보일 것 같다. 1과 3은 동일한 문제이다. 각각 C와 A를 임시로 사용하면 되고, 두 경우 모두 바닥에는 움직일 원판보다 더 큰 원판이 있으므로 원판 크기 조건을 걱정할 필요가 없다.

이제 이 방법으로 해결하는 코드를 작성해보자. 순환을 사용하면 대부분 코드가 다음과 같이 놀라울 정도로 짧아진다.

![그림 1 9](https://user-images.githubusercontent.com/76824867/169798876-10879bc3-e8ab-49e8-baab-250cc3d27e22.PNG)

[그림 1.9] n개의 원판을 가지는 하노이의 탑 문제에 대한 순환적인 해결 방법


``` Python
def hanoi_tower(n, fr, tmp, to):

    if n == 1:                                          # 종료조건
        print('원판 1: {} --> {}'.format(fr, to))       # 가장 작은 원판을 옮김
    else:
        hanoi_tower(n - 1, fr, to, tmp)                 # n-1개를 to를 이용해 tmp로
        print('원판 {} : {} --> {}'.format(n, fr, to))  # 하나의 원판을 옮김
        hanoi_tower(n - 1, tmp, fr, to)                 # n-1개를 fr을 이용해 to로

hanoi_tower(4, 'A', 'B', 'C') # 4개의 원판이 있는 경우
```

원판을 이동한다는 것은 그냥 화면에 어디서 어디로 이동한다고 출력해주면 된다. 복잡해보였던 문제가 순환을 이용하여 의외로 매우 쉽게 해결되었다.

마지막으로 이 알고리즘의 시간복잡도를 분석해보자. 이번에는 시간복잡도 함수 $T(n)$을 구한다. 그런데 순환을 사용하므로 $T(n)$은 다음과 같다.

$$ T(n) = 2 T(n-1) + 1 = 2 ( 2 T(n-2) + 1) + 1 = 2( 2( 2( T(n-3) + 1) + 1) + 1) = 2^{n-1} T(1) + ... = 2^{n-1} + ... = O(2^n) $$

T(1)은 하나를 옮기는 문제이므로 1이다. 따라서 하노이의 탑 알고리즘은 $O(2^n)$의 시간이 걸린다.

---

## Reference 

* <파이썬으로 쉽게 풀어쓴 자료구조>, 최영규, 천인국 저, 생능출판사
