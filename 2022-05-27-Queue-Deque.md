

* Date : 2022-05-27
* Last Devised : 2022-05-28

# Chapter 5. Queue and Deck

## 5.1 큐란?

### 큐는 선입선출(First-In First-Out : FIFO)의 자료구조이다.

여행을 가기 위해 공항 카운터에 줄을 서서 기다리는 대기열을 생각하면 큐를 쉽게 이해할 수 있다. 큐(Queue)는 먼저 들어온 데이터가 먼저 나가는 선입선출(FIFO : First-In First-Out)의 특성을 갖는 자료구조이다. 가장 앞에 있는 사람, 즉 가장 먼저 온 사람이 가장 먼저 서비스를 받아야 하고, 방금 도착한 사람은 줄의 맨 뒤에 서서 기다려야 한다.



큐는 뒤에서 새로운 데이터가 추가되고 앞에서 데이터가 하나씩 삭제되는 구조를 가지고 있다. 구조상으로 큐가 스택과 다른 점은 삽입과 삭제 연산의 위치가 같은 쪽이 아니라 서로 다른 쪽에서 일어난다는 것이다. 큐에서 삽입이 일어나는 곳을 **후단(Rear)**이라 하고 삭제가 일어나는 곳을 **전단(Front)**이라 한다. 다음은 큐의 구조를 보여준다.



[그림 5.1] 큐의 구조



### 큐의 추상자료형

큐에 저장하는 자료에도 특별한 제한이 없다. 연산들은 스택과 매우 유사한데, 삽입과 삭제 연산의 이름이 각각 enqueue와 dequeue인 것만 다르다. 큐의 추상자료형을 정의하면 다음과 같다.


정의 5.1 Queue ADT

* 데이터 : 선입선출(FIFO)의 접근 방법을 유지하는 항목들의 모음
* 연산
    - Queue() : 비어있는 새로운 큐를 만든다.
    - **isEmpty()** : 큐가 비어있으면 True를 아니면 False를 반환한다.
    - **enqueue(x)** : 항목 x를 큐의 맨 뒤에 추가한다.
    - **dequeue()** : 큐의 맨 앞에 있는 항목을 꺼내 반환한다.
    - peek() : 큐의 맨 앞에 있는 항목을 삭제하지 않고 반환한다.
    - size() : 큐의 모든 항목들의 개수를 반환한다.
    - clear() : 큐를 공백상태로 만든다.

isEmpty()는 큐의 공백상태를 검사하고 peek(), size(), clear() 연산도 스택에서와 동일한 의미를 갖는다. 큐에서도 가장 중요한 연산은 삽입 연산인 enqueue()와 삭제 연산인 dequeue()이다. 물론 삽입은 후단을 통해서만, 삭제는 전단을 통해서만 가능하다. 다음은 큐에서 일련의 삽입과 삭제가 이루어지는 과정을 보여주는데, 자료가 큐에 들어온 순서대로 나가는 것을 알 수 있다.


[그림 5.2] 큐의 삽입과 삭제 연산 예시



### 큐는 어디에 사용할까?

일상생활에서 대부분의 일들이 먼저 들어온 순서대로 처리되는 것과 같이 컴퓨터에서도 큐는 매우 광범위하게 사용된다. 특히 컴퓨터에서 데이터를 주고받을 때 각 주변장치들 사이에 존재하는 속도의 차이나 시간차이를 극복하기 위한 임시 기억장치로 큐가 사용되는데, 이것을 **버퍼(Buffer)**라고 한다. 그림과 같이 서비스 콜 센터에서도 **콜 큐(Call Queue)**를 사용한다. 큐에 많은 요청이 들어있으면 고객은 기다려야 한다. 그러나 먼저 신청한 사람은 반드시 먼저 서비스를 받는다. 큐의 활용 분야를 알아보자.





* 컴퓨터와 프린터 사이에 **인쇄작업 큐**가 존재한다. 프린터는 CPU에 비해 상대적으로 속도가 느리다. 따라서 CPU는 빠른 속도로 인쇄 데이터를 만들어 프린터의 인쇄작업 큐에 보낸 다음 다른 작업으로 넘어간다. 프린터는 일정한 속도로 인쇄작업 큐에서 순서대로 데이터를 가져와 인쇄한다.
* 실시간 비디오 스트리밍에서 다운로드된 데이터가 비디오를 재생하기에 충분하지 않으면 큐에 순서대로 모아두었다가 충분한 양이 되었을 때 비디오를 복원하여 재생한다. 이것을 **버퍼링(Buffering)**이라고 한다.
* 컴퓨터로 현실세계를 **시뮬레이션**하는 분야에서도 큐가 폭넓게 사용된다. 예를 들어 은행에서 대기표를 뽑고 기다리는 고객들, 공항에서 활주로를 이용해 이륙하는 비행기들, 인터넷에서 전송되는 데이터 패킷들을 모델링하는데 큐가 이용된다. 이러한 시뮬레이션을 잘 활용하면 은행이나 공항 시스템을 최적화할 수 있고, 따라서 최소의 비용으로 최고의 수익을 올릴 수 있다.

큐도 프로그래머의 중요한 도구로서 폭넓게 이용되고 있다.



## 5.2 큐의 구현

### 선형 큐에는 어떤 문제가 있을까?

큐 항목들을 저장하는 가장 쉬운 방법은 배열구조인 파이썬의 리스트를 사용하는 것이다. 이 리스트의 이름을 items라 하자. 맨 처음에 이 리스트는 공백이 되어야 한다.

``` Python
items = []      # 큐 항목을 위한 리스트
```

이제 front와 rear를 결정해야 한다. 일단 리스트의 맨 앞을 front라 하고, 맨 뒤를 rear라 하자. 이렇게 되면 **front와 rear를 위한 변수를 따로 관리할 필요가 없다**. front의 인덱스는 항상 0이고, rear는 항상 len(items) - 1, 또는 -1이기 때문이다.

이제 연산들을 구현하자. 리스트를 사용하면 연산들은 매우 간단해진다. 연산은 먼저 함수로 구현하자.



#### isEmpty() : 공백상태 검사

큐가 공백상태이면 items는 빈 리스트가 된다. 스택에서와 같이 len() 함수를 이용해 구현하면 된다.

``` Python
def isEmpty():
    return len(items) == 0      # 리스트 항목수가 0이면 공백상태
```



#### enqueue(item) : 삽입 연산

삽입 연산은 rear에 항목을 추가하는 것이다. 따라서 리스트의 맨 뒤에 item을 삽입하면 된다. 리스트의 append() 메소드를 사용하면 간단히 구현된다.


``` Python
def enqueue(item):
    items.append(item)      # 리스트의 맨 뒤에 item 추가
```

대부분의 경우 append()는 상수 시간에 항목을 추가할 수 있다. 따라서 이 연산의 시간복잡도는 $O(1)$이다.


#### dequeue() : 삭제 연산

삭제 연산은 front에서 항목을 하나 꺼내고 이를 반환하면 된다. 리스트에서 맨 앞의 항목을 꺼내는 것은 리스트의 pop() 메소드를 사용하면 된다. 즉, items.pop(0)으로 리스트 items의 맨 앞의 항목을 추출할 수 있다. 물론 큐가 공백상태이면 삭제할 수 없으므로 공백상태를 먼저 검사해야 한다.

``` Python
def dequeue():
    if not isEmpty():           # 공백상태가 아니면
        return items.pop(0)     # 맨 앞 항목을 꺼내서 반환
```


이 연산의 시간복잡도는 어떻게 될까? 3.2절에서 공부한 바와 같이 리스트의 pop(0) 연산은 모든 항목들을 앞으로 1칸씩 당겨야 하므로 항목수에 비례하는 시간이 걸린다. 따라서 삭제연산의 복잡도는 $O(n)$이다.


[그림 5.3] 선형큐의 문제점 : 삭제연산(pop(0))의 시간복잡도가 $O(n)$이다.


스택에서도 비슷한 문제가 있었음을 기억하라. 스택에서는 스택 상단의 위치를 바꾸어 해결했다. 그러나 큐에서는 전단과 후단을 바꾼다고 해결되지 않는다. 둘 중 하나에서는 같은 문제가 발생하기 때문이다.



### 기타 연산들

peek는 front 항목을 반환하기만 하고, 큐는 건드리지 않는다.

``` Python
def peek():                 # 전단 항목을 삭제하지 않고 반환
    if not is Empty():
        return items[-1]
```


나머지 연산(size와 clear 등)들은 스택과 비슷하게 간단히 구현된다. 이러한 큐를 선형 큐라고 한다. **선형 큐**에서는 삽입과 삭제 연산의 시간복잡도를 모두 $O(1)$으로 만들 수 없다. 구현된 코드에서는 삭제연산의 시간복잡도가 $O(n)$이다. 삭제연산도 $O(1)$으로 동작하도록 구현할 수는 없을까?


### 원형 큐가 훨씬 효율적이다.

배열을 선형으로 생각하지 않고 원형으로 생각하면 선형 큐의 문제를 해결할 수 있다. 이것은 리스트의 맨 끝과 맨 앞을 연결하는 개념이다. 물론 실제로 리스트가 원형인 것은 아니고, 원형으로 생각하고 사용하는 것일 뿐이다.

원형 큐에서는 기본적으로 리스트의 크기가 고정되어야 한다. C언어의 배열과 같이 리스트에 항상 그림과 같이 고정된 크기(MAX_QSIZE)의 칸이 있다고 생각하자. 원형 큐에서는 front와 rear를 위한 변수가 필요하다. rear는 **큐에 가장 최근에 삽입된 항목의 위치**를 front는 **가장 최근에 삭제된 항목의 위치**를 저장한다. 맨 처음에는 front = rear = 0 이다. 삽입연산은 rear를 하나 증가시킨 후 그 위치에 항목을 넣는 것이다. 삭제연산도 front를 하나 증가시키고 그 위치의 항목을 반환하면 된다. 크기가 8인 원형 큐에서 삽입과 삭제 연산의 예는 다음과 같다.



[그림 5.4] 원형 큐의 삽입과 삭제 과정


중요한 것은 인덱스가 원형으로 움직인다는 것이다. 0부터 계속 증가하다가 MAX_QSIZE - 1이 되면 다음은 MAX_QSIZE가 아니라 다시 0이 되는 것이다. 그렇다면 front와 rear를 어떻게 원형으로 회전시킬까? 다음과 같이 나머지 연산자를 사용하면 간단하게 해결된다.

``` Python
front <- (front + 1) % MAX_QSIZE
rear  <- (rear  + 1) % MAX_QSIZE
```

삭제를 하더라도 선형 큐와 같이 항목들을 앞으로 하나씩 당길 필요가 없다. 삽입도 마찬가지이다. 인덱스만 변경된다. 따라서 **삽입과 삭제 연산이 모두 $O(1)$**이다.

마지막으로 큐의 상태를 살펴보자. **공백상태**는 **front == rear**인 경우이다. 이들이 반드시 0일 필요는 없다. **같은 곳을 가리키기만 하면** 공백상태이다.



[그림 5.5] 원형 큐의 3가지 상태



**포화상태**는 어떨까? 선형 큐에서는 포화상태를 정의하지 않았다. 필요한 만큼 리스트를 확장해 저장할 수 있었기 때문이다. 원형큐에서는 크기는 `MAX_QSIZE`로 고정하였으므로 리스트가 꽉 차서 더 이상 항목을 추가할 수 없는 포화상태가 발생할 수 있다. 그렇다면 어떤 경우가 포화상태일까? 그림 5.5의 (c)와 같은 상태를 생각하기 쉽지만 문제가 있다. (c)는 공백상태인 (a)와 구분이 안 된다. 즉, 모두 front == rear 이다. 따라서 원형 큐에서는 하나의 자리를 비워두는 전략을 사용한다. (b)와 같이 **front**가 **rear보다 하나 앞**에 있으면 포화상태라고 정의한다. 이것은 **front == (rear + 1) % MAX_QSIZE**인 상태를 의미한다.





### 원형 큐의 구현

원형 큐를 클래스로 정의하자. 이름은 CircularQueue로 한다. 항목들은 파이썬의 리스트에 저장하고, 크기는 MAX_QSIZE라 하자. 생성자에서 리스트인 items와 정수형 변수 front와 rear를 선언한다. 이때, items가 ```MAX_QSIZE```개의 항목을 이미 가지고 있어야 하는 것에 유의하라. 코드는 다음과 같다.


``` Python
MAX_QSIZE = 10                              # 원형 큐의 크기
class CircularQueue():                      
    def __init__(self):                     # CircularQueue 생성자
        self.front = 0                      # 큐의 전단 위치
        self.rear = 0                       # 큐의 후단 위치
        self.items = [None] * MAX_QSIZE     # 항목 저장용 리스트 [None, None, ...]
    
    # 공백상태와 포화상태 검사 및 초기화 연산은 다음과 같다.
    # 포화상태 검사를 위해 나머지 연산자를 사용해야 한다.
    def isEmpty(self):
        return self.front == self.rear

    def isFull(self):
        return self.front == (self.rear + 1) % MAX_QSIZE

    def clear(self):
        self.front = self.rear

    # 삽입, 삭제 및 peek 연산은 다음과 같다.
    # front와 rear를 원형으로 회전시키는 코드에 유의하라.
    def enqueue(self, item):
        if not self.isFull():
            self.rear = (self.rear + 1) % MAX_QSIZE
            self.items[self.rear] = item
        
    def dequeue(self):
        if not self.isEmpty():
            self.front = (self.front + 1) % MAX_QSIZE
            return self.items[self.front]
        
    def peek(self):
        is not self.isEmpty():
            return self.items[(self.front + 1) % MAX_QSIZE]
```

이 코드에서도 예외적인 경우에 대한 처리코드를 생략하였다. 예를 들어, 포화상태에서 enqueue()가 호출되거나(Overflow), 공백상태에서 dequeue()가 호출된(Underflow) 상황 등이 예외적인 상황이다.

현재 큐에 저장된 항목의 개수는 어떻게 구할까? rear-front로는 충분하지 않다. 왜냐하면 rear가 회전되어 front보다 작아질 수 있기 때문이다. 다음과 같이 큐의 크기 ```MAX_QSIZE```와 모듈러 연산을 이용해야 한다.

``` Python
    def size(self):
        return (self.rear - self.front + MAX_QSIZE) % MAX_QSIZE
```



아직 모두 끝난 것이 아니다. 큐의 내용을 출력하려면 어떻게 할까? 선형 큐는 front가 항상 0이므로 그냥 리스트를 출력하면 된다. 그러나 원형 큐는 다르다. front 다음 항목부터 rear 항목까지를 순서대로 출력해야 한다. 이를 위해 클래스에 display() 연산을 추가하자. 파이썬 리스트의 **슬라이싱** 기능을 이용하면 좀 더 쉽게 큐의 내용을 순서대로 출력할 수 있다. front와 rear가 뒤집히면 front 이후 MAX_QSIZE 전까지와 0부터 rear까지의 항목을 모아 출력하면 된다. 구현된 코드는 다음과 같다.




[그림 5.6] 원형 큐 출력의 2가지 경우




``` Python
def display(self):
    out = []
    if self.front < self.rear:                              # 슬라이싱
        out = self.items[self.front + 1 : self.rear + 1]    
    else:                                                   # 슬라이싱
        out = self.items[self.front + 1 : MAX_QSIZE] + self.items[0 : self.rear + 1] 
    print('[f = %s, r = %d] ==>' % (self.front, self.rear), out)
```

이 코드에서는 파이썬의 슬라이싱 기능과 리스트를 합하는 + 연산을 사용하였다. 예를 들어, 그림 5.6의 Case1에서 리스트 items는 다음과 같다.

``` Python
items = [None, None, 'B', 'C', 'D', None, None, None]
```

이때 슬라이싱을 이용한 items[front + 1 : rear + 1]은 items[2:5]와 같고, 이것은 리스트 ['B', 'C', 'D']가 된다. 또한 두 리스트의 + 연산도 가능하다. 그림의 Case2와 같은 상황에서 ['F'] + ['G', 'A', 'B']는 리스트 ['F', 'G', 'A', 'B']가 된다.

이제 원형 큐를 테스트해보자. 큐의 크기는 10으로 설정하였다. 인덱스의 회전이 잘 되는지를 보이기 위해 8번의 삽입, 5번의 삭제, 그리고 6번의 삽입연산을 실행하였다. 테스트 코드와 실행 결과는 다음과 같다.

``` Python
q = CircularQueue()         # 원형 큐 만들기 (MAX_QSIZE = 10)
for i in range(8):          # 0, 1, ..., 7 삽입 (f = 0, r = 8)
    q.enqueue(i)            
q.display()                 # 원형 큐에서 구현한 print() 호출
for i in range(5):
    q.dequeue()             # 5번 삭제 (f = 5, r = 8)
q.display()
for i in range(8, 14):      # 8, 9, ..., 13 삽입 (f = 5, r = 4)
    q.enqueue(i)
q.display()
```


이 코드에서 마지막 상태는 포화상태이다. 더 이상 항목을 추가할 수 없다. 이와 같이 구현된 원형 큐는 크기가 제한된다. 그렇지만 항목의 이동이 필요없으므로 삽입이나 삭제연산이 모두 $O(1)$으로 매우 효율적이다. 따라서 원형 큐를 사용할 때는 문제의 특성을 고려해서 큐의 크기를 충분히 크게 만들어 사용하는 것이 좋을 것이다.



## 5.3 큐의 응용 : 너비우선탐색

실생활에서와 마찬가지로 컴퓨터에서도 큐는 매우 광범위하게 사용된다. 이 책에서도 큐를 사용하는 응용들은 다음과 같이 다양하다.

* 이진트리의 레벨 순회를 위해 큐가 사용된다. (8장)
* 기수정렬에서 레코드의 정렬을 위해 큐가 사용된다. (12장)
* 그래프의 탐색에서 너비우선탐색을 위해 큐가 사용된다. (10장)


### 큐를 이용한 너비우선탐색

우리는 4장에서 스택을 이용한 깊이우선탐색에 의해 미로를 탈출하는 방법을 공부했다. 미로 탐색을 위해 너비우선탐색(BFS, Breadth First Search)을 사용할 수도 있다. 너비우선탐색은 출발점에서부터 인접한 위치들을 먼저 방문한 다음, 방문한 위치들에 인접한 위치들을 순서대로 찾아가는 방법이다. 이 과정은 출구를 찾거나 모든 위치를 방문할 때까지 계속된다. 깊이우선탐색이 하나의 경로를 선택해 끝까지 가보고 막히면 다시 다른 경로를 시도하는 것과 달리, 너비우선탐색은 가까운 위치부터 차근차근 찾아가는 전략을 사용한다. 이러한 전략은 미로탐색 뿐만 아니라 일반적인 그래프 탐색에서도 사용되는 매우 중요한 기법이다. 이러한 너비우선탐색을 위해서는 큐를 사용해야 한다. 다음은 너비우선탐색으로 미로를 탈출하는 과정과 큐의 변화를 보여준다.


[그림 5.7] 너비우선탐색에 의한 미로탐색 및 큐의 상태변화



너비우선탐색에 의한 미로탐색을 구현해보자. 깊이우선탐색과의 차이는 스택을 사용하느냐 큐를 사용하느냐 밖에 없다. 따라서 4.5절의 코드에서 스택을 큐로 바꾸고 관련 멤버함수의 이름만 수정하면 된다. isValidPos()는 4장의 함수를 그대로 사용한다. CircularQueue를 이용한 깊이우선탐색 코드는 다음과 같다.

``` Python
def BFS():                          # 너비우선탐색 함수
    que = CircularQueue()
    que.enqueue((0, 1))
    print('BFS:')                   # 출력을 'BFS'로 변경

    while not que.isEmpty():
        here = que.dequeue()
        print(here, end = '->')
        x, y = here
        if map[y][x] == 'x':
            return True
        else:
            map[y][x] = '.'
            if isValidPos(x, y - 1):        
                que.enqueue((x, y - 1))    # 상
            if isValidPos(x, y + 1):
                que.enqueue((x, y + 1))    # 하
            if isValidPos(x - 1, y):
                que.enqueue((x - 1, y))    # 좌
            if isValidPos(x + 1, y):
                que.enqueue((x + 1, y))    # 우
    return False
```

미로탐색 테스트 코드와 실행되는 결과는 다음과 같다.

``` Python
map = [['1', '1', '1', '1', '1', '1'],
       ['e', '0', '1', '0', '0', '1'],
       ['1', '0', '0', '0', '1', '1'],
       ['1', '0', '1', '0', '1', '1'],
       ['1', '0', '1', '0', '0', 'x'],
       ['1', '1', '1', '1', '1', '1']]

MAZE_SIZE = 6
result = BFS()
if result:
    print('--> 미로탐색 성공')
else:
    print('--> 미로탐색 실패')
```


### 파이썬의 queue 모듈은 큐와 스택 클래스를 제공한다.

파이썬에서는 큐 클래스를 모듈로 제공해준다. 큐를 사용하기 위해서는 다음과 같이 **queue 모듈**을 포함해야 한다.

``` Python
import queue    # 파이썬의 큐 모듈 포함
```

queue 모듈의 큐 클래스 이름은 **Queue**이다. 따라서 다음과 같이 새로운 큐 Q를 만들 수 있다. 이때, 생성될 큐의 최대크기를 키워드 인수 maxsize를 통해 지정할 수 있다. maxsize가 0인 것은 큐의 크기가 무한대라는 것이다.

``` Python
Q = queue.Queue(maxsize = 20)   # 큐 객체 생성(최대크기 20)
```

삽입과 삭제연산의 이름이 변경되었다. 삽입은 enqueue()가 아니라 put()이고, 삭제는 dequeue()가 아니라 get()을 사용해야 한다.

``` Python
for v in range(1, 10):
    Q.put(v)
print('큐의 내용 :', end = '')
for _ in range(1, 10):
    print(Q.get(), end = ' ')
print()
```

공백상태의 큐에 get() 연산을 수행하면 **언더플로우(Underflow)**가 발생한다. 마찬가지로 maxsize 이상의 항목을 put()하는 경우 **오버플로우(Overflow)**가 발생한다. **get()과 put() 함수는 언더플로우나 오버플로우가 발생하더라도 에러를 반환하지 않고, 단순히 무한루프에 빠지게 되는 것**에 유의하라. 따라서 이 연산을 처리하기 전에 empty()와 full()를 이용해 큐의 상태를 먼저 확인하는 것이 안전하다.

스택 클래스도 큐 모듈에서 제공하는 것에 유의하라. 클래스의 이름이 **LifoQueue**인 것을 제외하고 객체생성 방법이나 연산들은 큐와 동일하다.

``` Python
S = queue.LifoQueue(maxsize = 20)   # 스택객체 생성 (최대크기 20)
```

이제 스택이나 큐를 직접 구현할 필요없이 파이썬의 큐 모듈을 이용해 깊이우선탐색과 너비우선탐색을 구현할 수 있다. 실습문제 5.1에 도전하라.



## 5.4 덱이란?

### 덱은 스택이나 큐보다는 입출력이 자유로운 구조이다.

덱(deque)는 double-ended queue의 줄임말로서 큐의 전단(front)과 후단(rear)에서 모두 삽입과 삭제가 가능한 큐를 의미한다. 그렇지만 여전히 중간에 삽입하거나 삭제하는 것은 허용하지 않는다.

[그림 5.8] 덱의 구조



덱을 추상자료형으로 정의하면 다음과 같다.

정의 5.2 Deque ADT

* 데이터 : 전단과 후단을 통한 접근을 허용하는 항목들의 모음
* 연산
    - Deque() : 비어있는 새로운 덱을 만든다.
    - isEmpty() : 덱이 비어있으면 True를 아니면 False를 반환한다.
    - addFront(x): 항목 x를 덱의 맨 앞에 추가한다.
    - deleteFront() : 맨 앞의 항목을 꺼내서 반환한다.
    - getFront() : 맨 앞의 항목을 꺼내지 않고 반환한다.
    - addRear(x) : 항목 x를 덱의 맨 뒤에 추가한다.
    - deleteRear() : 맨 뒤의 항목을 꺼내서 반환한다.
    - getRear() : 맨 뒤의 항목을 꺼내지 않고 반환한다.
    - isFull() : 덱이 가득 차 있으면 True를 아니면 False를 반환한다.
    - size() : 덱의 모든 항목들의 개수를 반환한다.
    - clear() : 덱을 공백상태로 만든다.

덱은 스택과 큐의 연산들을 모두 가지고 있다.

* 덱의 addRear, deleteFront, getFront 연산은 각각 큐의 enqueue, dequeue, peek 연산과 정확히 동일하다.
* 덱의 후단(rear)을 스택의 상단(top)으로 사용한다면, 덱의 addRear, deleteRear, getRear 연산은 스택의 push, pop, peek 연산과 정확히 동일하다.




덱은 구조상 큐와 더 비슷하다. 따라서 원형 덱으로 구현하는 것이 연산들의 시간복잡도를 $O(1)$으로 만들 수 있는 좋은 방법이다. 주의해야 할 연산은 front와 rear를 감소시켜야 하는 deleteRear와 addFront이다. 다음 그림과 같이 인덱스를 감소시키는 것은 반대방향, 즉 반시계방향의 회전을 의미한다. front와 rear를 반대방향으로 회전시키는 코드는 다음과 같다.

``` Python
front <- (front - 1 + MAX_QSIZE) % MAX_QSIZE
rear  <- (rear  - 1 + MAX_QSIZE) % MAX_QSIZE
```


[그림 5.9 원형 덱의 삽입/삭제 연산 예]



## 5.5 덱의 구현

### 원형 큐를 상속하여 원형 덱 클래스를 구현하자.

상속이 나온다고 겁먹을 필요는 없다. 상속은 대표적인 객체지향 프로그래밍 기법으로 코드 재사용을 극대화할 수 있다. 이것은 매우 짧은 코드만으로도 기존의 복잡한 클래스에 기능을 추가한 새 클래스를 만드는 멋진 방법이다.

앞에서 구현한 원형 큐 클래스 CircularQueue를 상속하여 새로운 원형 덱 클래스 CircularDeque를 만들어보자. 많은 기능들이 이미 CircularQueue에서 구현되었기 때문에 CircularDeque 클래스에서 작성해야 할 코드는 많지 않을 것이다. 2.12절의 상속을 참조하라. CircularQueue를 상속하여 CircularDeque 클래스를 만드는 문법은 다음과 같다.

``` Python
class CircularDeque(CircularQueue):     # CircularQueue에서 상속

    def __init__(self):                 # CircularDeque 생성자
        super().__init__()              # 부모 클래스의 생성자를 호출함.

    
    def addRear(self, item):            # enqueue 호출
        self.enqueue(item)

    def deleteFront(self):              # 반환에 주의
        return self.dequeue()

    def getFront(self):                 # 반환에 주의
        return self.peek()


    def addFront(self, item):               # 새로운 기능 : 전단 삽입
        if not self.isFull():
            self.items[self.front] = item   # 항목 저장
            self.front = self.front - 1     # 반시계 방향으로 회전
            if self.front < 0:
                self.front = MAX_QSIZE - 1

    def deleteRear(self):                   # 새로운 기능 : 후단 삭제
        if not self.isEmpty():
            item = self.items[self.rear]    # 항목 복사
            self.rear = self.rear - 1       # 반시계 방향으로 회전
            if self.rear < 0:
                self.rear = MAX_QSIZE - 1
        return item                         # 항목 반환

    def getRear(self):                      # 새로운 기능 : 후단 peek
        return self.items[self.rear]

```

상속을 하면 **자식 안에 부모가 들어있는** 것과 같다. 따라서 이 클래스는 이미 많은 기능(부모 클래스에서 정의된 멤버변수와 메소드)을 갖고 있다. 그러나 **생성자는 상속되지 않는다**. 따라서 자식 클래스에서 다시 정의해야 한다.

* 자식클래스에서 부모를 부르는 함수가 **super()**이다.
* **생성자에서 front, rear, items와 같은 변수를 선언하지 않은 것**에 유의하라. 이들은 부모 클래스의 데이터 멤버로 이미 자식 클래스에 들어있다. 따라서 self.front와 같이 바로 사용하면 된다.
* 부모 클래스의 멤버들은 super() 함수를 통해서도 사용할 수 있다. 예를 들어, super().front는 self.front와 동일하다.
* 생성자는 예외이다. 자식에도 생성자가 있고 부모도 생성자가 있으므로 부모의 생성자를 구분하여 호출하기 위해서는 반드시 ```super().__init__()``` 과 같이 기술해야 한다.
* isEmpty, isFull, size, clear와 같이 부모에서 구현된 연산들도 클래스에 구현되어 있다고 생각하고 그냥 사용하기만 하면 된다. 예를 들어, 공백상태의 검사가 필요하면 self.isEmpty()를 호출하면 된다. **코드를 재사용**하는 것이다.


그렇다면 자식 클래스에는 어떤 코드를 넣어야 할까? 자식에서만 필요한 연산들을 구현하면 된다. 먼저 이미 큐에 있는 기능이지만 이름이 바뀌는 연산들(addRear, deleteFront, getFront)을 생각해보자. 이들은 이미 "구현"이 되어 있으므로 **인터페이스**만 잘 만들어주면 된다. 즉, 위와 같이 부모의 해당 메소드를 적절히 호출해주면 끝이다.

이제 덱에만 있는 기능들을 구현해보자. addFront와 deleteRear는 반대 방향의 회전에만 신경을 써주면 된다. getRear는 현재 rear가 가리키는 항목을 반환하면 된다.

생성자와 6개의 메소드만을 구현했지만 이 클래스는 이미 덱 ADT에서 정의한 모든 기능을 갖고 있다. 즉 클래스의 구현이 끝난 것이다.

이제 만들어진 덱을 활용해보자. 다음 코드는 덱 객체를 생성하고, 0~8의 숫자들 중에서 홀수는 전단에, 짝수는 후단에 삽입한다. 전단에서 2번, 후단에서 3번의 삭제를 하고, 마지막으로 전단에 5번의 삽입을 하였다.

``` Python
dq = CircularDeque()        # 덱 객체 생성, f = r = 0
for i in range(9):          # i : 0, 1, 2, ..., 8
    if i % 2 == 0:          
        dq.addRear(i)       # 짝수는 후단에 삽입
    else:                   
        dq.addFront(i)      # 홀수는 전단에 삽입
dq.display()                # front = 6, rear = 5
for i in range(2):
    dq.deleteFront()        # 전단에서 2번의 삭제 : f = 8
for i in range(3):
    dq.deleteRear()         # 후단에서 3번의 삭제 : r = 2
dq.display()
for i in range(9, 14):      # i : 9, 10, ..., 13 : f = 3
    dq.addFront(i)
dq.display()
```

화면 출력도 큐 클래스의 display()를 그대로 사용했다. 결과는 다음과 같다.



구현된 덱의 시간복잡도를 생각해보자.

* 이름만 바뀌는 연산들(addRear, deleteFront, getFront)은 이미 큐에서 모두 $O(1)$임을 확인하였다.
* getRear는 명백히 $O(1)$이다.
* 새로 추가한 삽입연산 addFront와 삭제연산 deleteRear에서도 항목의 이동을 발생시키지 않고, 인덱스만 변경하면 된다. 따라서 시간복잡도는 $O(1)$이다.

이 책에서는 상속을 많이 사용하지 않는다. (9.4절에서만 한번 더 사용함) 따라서 어려우면 넘어가도 좋다. 그렇지만 상속은 매우 효과적이고 강력한 방법이므로 관심을 갖고 활용해보는 것을 권장한다.




## 5.6 우선순위 큐

(오늘은 여기까지!! 내일부터 다시 시작!!)
































