* Date : 2022-05-19
* Last Devised : 2022-05-22

# Data Structures Using Python Chapter 8. Tree

## 8.1 트리란?

### 계층적인 자료의 표현에 적합한 자료구조

리스트나 스택, 큐, 덱 등은 모두 자료들이 일렬로 나열된 형태인 선형자료구조이다. 만약 자료들이 선형이 아니라 **계층적인 구조(Hierarchial Structure)**를 가지고 있다면 어떻게 표현할 수 있을까? 예를 들어, 직장의 조직도, 가족의 가계도, 컴퓨터의 폴더구조 등과 같이 **계층적인 관계를 가진 자료의 표현**에 유용한 자료구조가 **트리(Tree)**이다. 다음은 전형적인 계층적 자료의 예를 보여주는데, 이러한 구조를 트리라고 부르는 이유는 이들이 마치 실제 나무를 거꾸로 엎어놓은 것과 비슷한 모양을 하고 있기 때문이다.

컴퓨터에서도 트리는 다양한 응용을 갖는다. 폴더구조를 표현하는 것은 물론이고, 효율적인 탐색을 위한 탐색트리, 우선순위 큐를 위한 힙 트리, 인공지능 문제에서 의사결정 구조를 표현하기 위한 **결정트리(Decision Tree)** 등 매우 광범위하게 활용된다.

![[그림 8.1] 다양한 트리의 응용분야](https://user-images.githubusercontent.com/76824867/169660280-49216f7e-6be3-4a8b-8100-c7c53699b4c0.PNG)

[그림 8.1] 다양한 트리의 응용분야


### 트리의 용어

트리는 한 개 이상의 **노드(Node)**로 이루어진다. 트리 용어들을 살펴보자.

![[그림 8.2] 트리와 관련된 용어들](https://user-images.githubusercontent.com/76824867/169660281-546006f1-64fb-42e4-9a50-01c0c61b55a6.PNG)

[그림 8.2] 트리와 관련된 용어들


* 루트(Root) 노드 : 계층적인 구조에서 가장 높은 곳에 있는 노드. 트리에서 **모든 노드는 자신의 서브트리의 루트 노드**이다.
* 간선 또는 에지(Edge) : 노드와 노드를 연결하는 선
* 부모(Parent) 노드와 자식(Child) 노드 : 간선으로 직접 연결된 노드 중에 상위노드와 하위노드
* 형제(Sibling) 노드 : 동일한 부모노드를 가진 노드
* 조상(Ancestor) 노드와 자손(Descendent) 노드 : 어떤 노드에서 루트 노드까지의 경로상에 있는 모든 노드들과, 어떤 노드 하위에 연결된 모든 노드
* 단말(Terminal, Leaf) 노드 : 자식 노드가 없는 노드, 자식이 있으면 비단말 노드
* 노드의 차수(Degree) : 어떤 노드가 가지고 있는 자식의 수
* 트리의 차수 : 트리가 가지고 있는 노드의 차수 중에서 가장 큰 차수
* 레벨(Level) : 트리의 각 층에 번호를 매기는 것. 루트의 레벨은 1이 되고, 한 층씩 내려갈수록 1씩 증가
* 트리의 높이(Height) : 트리가 가지고 있는 최대 레벨
* 포레스트(Forest) : 트리들의 집합

트리는 **순환적으로 정의**되는데, 트리의 모든 노드는 자신의 서브트리의 루트 노드이다. 즉, 결국 각 노드가 하나의 서브트리를 대표한다고 볼 수 있다. 이러한 특징에 의해 트리에서는 순환 알고리즘이 흔히 사용된다.


### 일반트리의 표현방법

트리를 표현하는 가장 일반적인 방법은 **트리 노드**를 6장에서 공부한 연결된 구조에서의 노드 형태로 표현하는 것이다. 이때, 노드는 항목 값을 저장하는 **데이터 필드**와 자식 노드를 가리키는 **여러 개**의 **링크**를 갖는다. 그렇다면 링크는 몇 개가 되어야 할까? 자식 노드의 수에 따라 다르다. 즉, 노드의 차수만큼의 링크가 필요하다. 노드들이 **임의의 개수의 자식을 가질 수 있는 트리**를 **일반 트리**라 하는데, 일반 트리에서는 노드마다 링크의 수가 다르고, 따라서 이들 링크를 리스트와 같이 복잡한 형태로 관리해야 한다.

![[그림 8.3] 임의의 개수의 자식을 가질 수 있는 일반트리의 노드 구조](https://user-images.githubusercontent.com/76824867/169660283-63e3c033-8961-4da3-91d2-10844d47efc2.PNG)

[그림 8.3] 임의의 개수의 자식을 가질 수 있는 일반트리의 노드 구조

노드의 형태를 더 단순화하여 일반 트리를 표현할 수도 있다. 그림과 같이 2개의 링크를 갖도록 하는 방법인데, 하나는 **첫번째 자식(Child)**를 가리키고, 다른 하나는 **다음 형제(Sibling)**를 가리키기 위해 사용하는 것이다. 이 방법은 다음 그림과 같이 임의의 일반 트리를 표현할 수 있지만, 표현이 복잡하고 특히 루트인 A에서 G까지 찾아가기 위해 필요없이 많은 노드를 거쳐야 하는 문제가 있다.

![[그림 8.4] 2개의 링크를 갖는 노드 구조로 일반트리를 표현한 경우, 매우 복잡함.](https://user-images.githubusercontent.com/76824867/169660284-2bd372a0-c0f9-4d1d-aa31-7686f0d939a2.PNG)

[그림 8.4] 2개의 링크를 갖는 노드 구조로 일반트리를 표현한 경우, 매우 복잡함.

다행히 실제로는 좀 더 단순한 형태의 트리인 이진트리를 많이 사용한다. **이진트리(Binary Tree)**는 자식 노드의 개수가 항상 2개 이하인 트리를 말한다. 왼쪽 자식과 오른쪽 자식은 정확히 구별되는데, 부모는 왼쪽과 오른쪽 자식에 바로 접근할 수 있다. 이진트리는 가장 많이 사용되는 트리의 형태로 이 책에서는 앞으로 이진트리만을 다루기로 한다.


## 8.2 이진트리

### 이진트리는 순환적으로 정의된다.

**이진트리(Binary Tree)**는 **모든 노드가 2개의 서브트리를 갖는 트리**이다. 이때 서브트리는 공집합일 수도 있다. 모든 노드의 차수가 2 이하로, 최대 2개까지의 자식 노드를 가질 수 있는데, **자식들 사이에도 순서가 존재**하므로 왼쪽 자식과 오른쪽 자식은 반드시 구별되어야 한다. 이진트리는 다음과 같이 순환적으로 정의된다.

![[그림 8.5] 이진트리의 구조](https://user-images.githubusercontent.com/76824867/169660285-757231cf-0dd6-4bfe-b3f0-25a14e344793.PNG)

[그림 8.5] 이진트리의 구조

정의 8.1 이진트리의 정의

1. 공집합이거나
2. 루트와 왼쪽 서브트리, 오른쪽 서브트리로 구성된 노드들의 집합, 이진트리의 서브트리들은 모두 이진트리여야 함.

이 정의를 바탕으로 다음 트리가 이진트리인지를 살펴보자.


![[그림 8.6] 이진트리의 검증 과정](https://user-images.githubusercontent.com/76824867/169660288-be3aea45-7eb2-4abe-80c1-fe2b0826379e.PNG)

[그림 8.6] 이진트리의 검증 과정

노드 D, B, C, A의 순서로 살펴보면 모든 서브트리가 이진트리이므로 전체 트리는 이진트리이다.


### 이진트리의 종류와 성질

#### 이진트리의 종류

* **포화이진트리(Full Binary Tree)**는 트리의 **각 레벨에 노드가 꽉 차있는 이진트리**를 말한다. 높이 k인 포화 이진트리의 노드의 수를 계산해보자.

$$ \mathrm{전체 노드 개수} : 2^{1-1} + 2^{2-1} + 2^{3-1} + ... + 2^{k-1} = \sum_{i=0}^{k-1} 2^i = 2^k - 1  $$

포화 이진트리에서는 각 노드에 순서대로 번호를 붙일 수 있다. 레벨 단위로 왼쪽에서 오른쪽으로 순서대로 번호를 붙이면 되는데, 이 번호는 항상 일정하다. 예를 들어, 루트 노드의 번호는 항상 1이며, 루트 노드의 오른쪽 자식 노드의 번호는 항상 3이다.


![[그림 8.7] 포화이진트리에서의 노드 번호](https://user-images.githubusercontent.com/76824867/169660289-05f7172e-e415-42e4-b126-bd731837281a.PNG)

[그림 8.7] 포화이진트리에서의 노드 번호

* **완전이진트리(Complete Binary Tree)**는 높이가 k인 트리에서 레벨 1부터 k-1까지는 노드가 모두 채워져 있고, 마지막 레벨 k에서는 왼쪽부터 오른쪽으로 노드가 순서대로 채워져 있는 이진트리를 말한다. 마지막 레벨에서는 노드가 꽉 차있지 않아도 되지만, **중간에 빈 곳이 있으면 안 된다**. 따라서 포화이진트리는 완전이진트리이지만, 그 역은 항상 성립하지는 않는다. **힙(Heap)**은 완전이진트리의 대표적인 예이다.

![[그림 8.8] 이진트리의 종류](https://user-images.githubusercontent.com/76824867/169660293-bb6a2034-b462-465e-8c7c-f9820e5e20ca.PNG)

[그림 8.8] 이진트리의 종류


#### 이진트리의 성질

* $n$개의 노드를 가진 트리는 $n-1$개의 간선을 가진다. 그 이유는 루트를 제외한 트리의 모든 노드가 하나의 부모노드를 가지기 때문이다. 부모와 자식 간에는 하나의 간선만이 존재한다. 따라서 간선의 개수는 $n-1$이다.

![[그림 8.9] 트리에서 노드의 개수와 간선의 개수의 관계](https://user-images.githubusercontent.com/76824867/169660294-70b2d13a-8a3f-4a7d-8a36-d6cc588ba01d.PNG)

[그림 8.9] 트리에서 노드의 개수와 간선의 개수의 관계

* 높이가 $h$인 이진트리는 $h$개 이상, $2^h - 1$개 이하의 노드를 가진다. 한 레벨에는 적어도 하나의 노드는 존재해야 하므로 높이가 $h$인 이진트리는 최소한 $h$개의 노드를 가져야 한다. 또한 하나의 노드는 최대 2개의 자식을 가질 수 있으므로 레벨 $i$에서의 노드의 최대 개수는 $2^{i-1}$이 된다. 따라서 높이가 $h$인 이진트리의 최대 노드 개수는 $\sum_{i=1}^{h} 2^{i-1} = 2^{h} - 1$이 된다.

![그림 8 10](https://user-images.githubusercontent.com/76824867/169660296-57576c7c-e9ce-43f1-b84c-d4b0fd2ef361.PNG)

[그림 8.10] 같은 높이의 이진트리에서의 최소와 최대 노드 개수

* $n$개의 노드를 가지는 이진트리의 높이는 $ log_2 (n+1) $ 이상이고 $n$이하이다. 먼저, 한 레벨에서 최소한 하나의 노드는 있어야 하므로 높이가 $n$을 넘을 수는 없다. 앞의 성질에서 높이 $h$의 이진트리가 가질 수 있는 노드의 최대값은 $2^h - 1$이다. 따라서 $n \leq 2^h - 1$의 부등식이 성립하고 양변에 log를 취하면 $h \geq log_2 (n+1)$이 된다. $h$는 정수이므로 $ h \geq log_2 (n+1)$이 된다.

![그림 8 11](https://user-images.githubusercontent.com/76824867/169660297-6ea3c7fd-102f-44c7-863f-d2afd7ae2c2d.PNG)

[그림 8.11] 같은 개수의 노드로 만들 수 있는 최대와 최소 높이의 이진트리


### 이진트리의 표현 방법

#### 배열 표현법

앞에서 포화이진트리에서 노드에 번호를 붙이는 방법을 공부했는데, 이 번호를 배열의 인덱스로 사용하면 이진트리를 배열구조로 표현할 수 있다. 과정은 다음과 같다.

1. 트리의 높이를 구해 배열(또는 파이썬의 리스트)을 할당한다. 예를 들어, 높이가 $k$이면 길이가 $2^k - 1$인 배열이 필요하다.
2. 포화이진트리의 번호를 인덱스로 사용하여 배열에 노드들을 저장한다.

보통 루트 노드의 번호를 1로 하는데, 계산의 편의를 위해 인덱스 0은 사용하지 않는다. 이 번호를 배열의 인덱스로 사용하면 각 노드에 대한 위치가 결정된다. 이러한 방법은 **포화이진트리나 완전이진트리에 가장 적합**한데 배열 항목 사이에 빈칸이 발생하지 않기 때문이다. 배열 표현법으로 다음 그림과 같이 일반 이진트리도 표현할 수 있다. 그러나 트리가 심한 경사를 나타내는 경우에는 배열 항목 사이에 사용하지 않는 빈 칸이 많이 발생하여 메모리의 낭비가 심해질 수 있다.

![그림 8 12](https://user-images.githubusercontent.com/76824867/169660298-3d128edb-5f2f-40ec-97ac-47b48467c861.PNG)

[그림 8.12] 이진트리의 배열표현 방법 : 완전이진트리와 경사이진트리의 예

배열 표현법에서 어떤 노드의 인덱스를 알면 그 노드의 부모나 자식 노드의 인덱스를 다음과 같이 계산할 수 있다.

* 노드 $i$의 **부모 노드 인덱스 = $i/2$**
* 노드 $i$의 **왼쪽 자식 노드 인덱스 = $2i$**
* 노드 $i$의 **오른쪽 자식 노드 인덱스 = $2i + 1$**

부모 노드의 인덱스 계산에 정수간의 나눗셈이 사용되어야 하는 것에 유의하라. 이와 같은 배열 표현법은 간단하지만 기억공간의 낭비와 함께 표현할 수 있는 트리의 높이가 배열의 크기에 따라 제한되는 단점이 있다.


#### 링크표현법

연결된 구조로도 이진트리를 표현할 수 있다. 이진트리를 위한 노드의 구조는 다음과 같은데, 2개의 링크 필드가 필요하다. 이들은 각각 왼쪽과 오른쪽 자식 노드를 가리킨다. 좌우 링크가 반드시 구별되어야 하는 것에 유의하라.

![그림 8 13](https://user-images.githubusercontent.com/76824867/169660299-7bad670c-25c3-4c36-9ab2-36b9132f263a.PNG)

[그림 8.13] 연결된 구조의 이진트리를 위한 노드의 구조

다음은 링크 표현법으로 이진트리를 표현하는 예를 보여주고 있다. 트리 표현에서 부모와 자식의 관계를 나타내기 위해서는 에지를 화살표로 나타내는 것이 더 정확하다. 그러나 화살표가 없이 연결된 경우 위쪽을 부모 노드, 아래쪽을 자식 노드로 생각하면 된다.

![그림 8 14](https://user-images.githubusercontent.com/76824867/169660300-8d098c54-8e2b-404c-ae5e-7e095b4ea09f.PNG)

[그림 8.14] 이진트리의 링크 표현 방법 : 완전이진트리와 경사이진트리의 예

이진트리의 노드 구조를 클래스로 나타내보자. 노드 클래스 TNode는 다음과 같이 표현할 수 있다. 생성자에서 트리 노드를 위한 데이터와 왼쪽 자식 및 오른쪽 자식에 대한 링크를 생성하고 초기화한다.

``` Python
class TNode():                                  # 이진트리를 위한 노드 클래스
    def __init__(self, data, left, right):      # 생성자
        self.data = data                        # 노드의 데이터
        self.left = left                        # 왼쪽 자식을 위한 링크
        self.right = right                      # 오른쪽 자식을 위한 링크
```


## 8.3 이진트리의 연산

### 트리의 모든 노드를 방문하는 방법

트리를 **순회(Traversal)**한다는 것은 **트리에 속하는 모든 노드를 한 번씩 방문**하여 노드의 데이터를 목적에 맞게 처리하는 것을 의미한다. 예를 들어, 트리의 모든 노드들을 화면에 출력하기 위해서는 순회가 필요하다. 이와 같이 순회는 트리에서 가장 기본적인 연산이다.

다음은 선형자료구조에서의 순회와 트리에서의 순회를 비교하고 있다. 선형자료구조에서는 항목들이 일렬로 저장되어 있으므로 순회 방법이 단순하다. 그러나 트리에서는 그렇게 단순하지 않다. 그림과 같이 동일한 트리에 대해서도 다양한 순서로 노드들을 방문할 수 있다.

![그림 8 15](https://user-images.githubusercontent.com/76824867/169660301-cf4aa677-9220-4ec7-9440-5f7e30bcec35.PNG)

[그림 8.15] 선형자료구조와 트리의 순회방법 비교

이진트리의 표준 순회에는 전위, 중위, 후위의 3가지 방법이 있다. 이들은 **루트의 왼쪽 서브트리, 오른쪽 서브트리를 각각 어떤 순서로 방문하느냐**에 따라 구분된다. 루트를 방문하는 작업을 $V$, 왼쪽과 오른쪽 서브트리를 방문하는 작업을 각각 $L$과 $R$이라 하자. 이진트리의 기본 순회 방법들은 다음과 같다.

* 전위 순회(Preorder Traversal) : VLR
* 중위 순회(Inorder Traversal) : LVR
* 후위 순회(Postorder Traversal) : LRV

![그림 8 16](https://user-images.githubusercontent.com/76824867/169660302-b583b72c-14ca-47b5-9433-8de9a9db9d51.PNG)

[그림 8.16] 이진트리의 순회 환경

그러면 각 **서브트리**의 노드들은 또 어떤 식으로 방문할까? 이진트리에서는 각각의 서브트리도 이진트리이다. 따라서 **동일한 순회 방법이 적용**되어야 한다. 예를 들어, 전위 순회의 경우 서브트리에 들어있는 모든 노드들도 VLR의 순서대로 순회하여야 한다.

트리에서는 **순환기법**이 많이 사용된다. 다음 그림을 보면 전체 트리나 서브트리나 기본구조는 완전히 동일한 것을 알 수 있다. 따라서 전체 트리 순회에 사용된 알고리즘을 똑같이 서브트리에 적용할 수 있다. 물론 문제의 크기는 작아진다. 따라서 순환이 최선의 해결책이다.

![그림 8 17](https://user-images.githubusercontent.com/76824867/169660303-34181eb2-c97d-4078-a71f-395d20ebb1bf.PNG)

[그림 8.17] 전체 트리와 서브트리의 구조가 동일하다.


#### 전위 순회(Preorder)

전위 순회는 루트를 먼저 방문하고 그 다음에 왼쪽 서브트리를 방문하고 오른쪽 서브트리를 마지막으로 방문하는 것이다. 구현된 함수는 다음과 같다.

![1](https://user-images.githubusercontent.com/76824867/169660274-4702ae60-7571-450f-a3ff-7b284297bf2c.PNG)

``` Python
def preorder(n):                    # 전위 순회 함수
    if n is not None:
        print(n.data, end = ' ')    # 먼저 루트노드 처리(화면출력)
        preorder(n.left)            # 왼쪽 서브트리 처리
        preorder(n.right)           # 오른쪽 서브트리 처리
```

전위순회에서 루트노드의 방문을 마쳤다고 가정하자. 그러면 왼쪽 서브트리를 방문할 차례이다. 그러면 왼쪽 서브트리의 어떤 노드를 먼저 방문하여야 할까? 왼쪽 서브트리도 하나의 이진트리이다. 따라서 전체트리와 똑같은 방식으로 서브트리를 방문하면 된다. 즉, 왼쪽 서브트리의 루트를 먼저 방문하고 왼쪽 서브트리의 왼쪽 서브트리를 그 다음에, 마지막으로 왼쪽 서브트리의 오른쪽 서브트리를 방문하면 된다. 즉, 모든 서브트리에 같은 알고리즘을 반복한다.

![2](https://user-images.githubusercontent.com/76824867/169660275-6b6e0fcb-5efb-4241-a58d-e142eaf6ca1c.PNG)


### 중위 순회(Inorder)

중위 순회에서는 왼쪽 서브트리, 루트, 오른쪽 서브트리 순으로 방문한다.

![3](https://user-images.githubusercontent.com/76824867/169660277-d22a2c11-dac8-42b1-a192-7908a55161ec.PNG)

``` Python
def inorder(n):                     # 중위 순회 함수
    if n is not None:
        inorder(n.left)             # 왼쪽 서브트리 처리
        print(n.data, end = ' ')    # 루트노드 처리(화면출력)
        inorder(n.right)            # 오른쪽 서브트리 처리
```

### 후위 순회(Postorder)

후위 순회는 왼쪽 서브트리, 오른쪽 서브트리, 루트 순으로 방문한다.

![4](https://user-images.githubusercontent.com/76824867/169660278-a6ee2434-a31d-4ff4-bb87-1ed9ba425ce3.PNG)

``` Python
def postorder(n):
    if n is not None:
        postorder(n.left)
        postorder(n.right)
        print(n.data, end = ' ')
```


### 순회 방법의 선택

다음은 동일한 트리의 노드들을 전위, 중위, 후위순회 방식으로 방문한 순서를 숫자로 표시하고 있다.

![그림 8 18](https://user-images.githubusercontent.com/76824867/169660305-5bd33efd-be23-4347-a837-aef7755ce6a0.PNG)

[그림 8.18] 전위, 중위, 후위순회에 따른 노드 방문 순서 비교

트리와 관련된 문제들 중에는 순회 알고리즘만 이용해도 해결되는 것들이 많다. 그렇다면 어떤 순회 방법을 사용해야 할까?

* 순서는 중요하지 않고 노드를 전부 방문하기만 하면 된다면 3가지의 방법 중에 어떤 것이든지 관계없다. 예를 들어, 트리의 모든 노드 값을 순서와 상관없이 출력해야 한다면 순회 방법은 중요하지 않다.
* 자식 노드를 처리한 다음에 부모 노드를 처리해야 하는 문제라면 당연히 후위순회를 사용하여야 한다. 예를 들어, 컴퓨터에서 각 폴더의 용량을 계산하려면 후위순회를 사용하여야 한다. 하위 폴더의 용량이 계산되어야 이를 이용해 현재 폴더의 용량을 계산할 수 있기 때문이다.
* 부모 노드를 처리한 다음에 자식 노드를 처리해야 한다면 전위순회를 사용하여야 한다. 예를 들어, 모든 노드에서 레벨을 계산하기 위해서는 전위순회를 사용해야 한다. 루트노드의 레벨이 1이 되고, 모든 노드들은 부모 노드의 레벨보다 1이 크기 때문이다.


### 레벨 순회

**레벨 순회(Level Order)**는 각 노드를 레벨 순으로 검사하는 방법이다. 루트 노드의 레벨이 1이고 아래로 내려갈수록 레벨이 증가한다. 동일한 레벨에서는 좌에서 우로 방문한다. 이러한 **레벨 순회에는 큐가 사용**된다.

알고리즘을 생각해보자. 레벨 순회는 큐에서 노드를 하나 꺼내 방문하고 그 자식들을 큐에 삽입한다. 삽입에도 순서가 있다. 먼저 왼쪽 자식을 삽입하고 오른쪽 자식을 삽입해야 한다. 물론 자식이 없으면 삽입하지 않는다. 이 과정은 큐가 공백상태가 될 때까지 반복된다. 맨 처음에는 큐에 루트 노드만 들어있다.

![그림 8 19](https://user-images.githubusercontent.com/76824867/169660306-6d9973c6-e6a9-4cbb-a0ac-465b05514941.PNG)

[그림 8.19] 레벨순회의 예

그림 8.19를 예로 들어보자. 먼저 루트 노드인 +가 큐에 입력된 상태에서 순회가 시작된다. 큐에서 하나를 삭제하면 +가 나오게 되고, 노드 +를 방문하고 왼쪽 자식 l과 오른쪽 자식 r을 순서대로 큐에 삽입한다. 다시 큐에서 하나(l노드)를 꺼내고 같은 과정을 반복한다. 그림은 트리를 레벨 순회로 방문하는 전체 순서를 보여주고 있다. 이제 레벨 순회를 구현해보자. **순환은 사용되지 않는다**.

``` Python
def levelorder(root):
    queue = CircularQueue()             # 큐 객체 초기화
    queue.enqueue(root)                 # 최초의 큐에는 루트 노드만 들어있음.
    while not queue.isEmpty():          # 큐가 공백상태가 아닌 동안
        n = queue.dequeue()             # 큐에서 맨 앞의 노드 n을 꺼냄
        if n is not None:
            print(n.data, end = ' ')    # 먼저 노드의 정보를 출력
            queue.enqueue(n.left)       # n의 왼쪽 자식 노드를 큐에 삽입
            queue.enqueue(n.right)      # n의 오른쪽 자식 노드를 큐에 삽입
```

레벨 순회 결과를 보면 루트 노드부터 각 레벨별로 순차적으로 노드를 출력하는 것을 알 수 있다. 이것은 트리의 노드를 위에서 아래로, 좌에서 우로 출력하므로 다른 순회 방법에 비해 출력 결과를 이해하기가 쉽다.


### 트리의 전체 노드 개수, 단말 노드의 수, 높이 계산

#### 노드 개수 구하기

이진트리에서 전체 노드의 개수를 세기 위해서는 모든 노드들을 한 번씩 방문해야 한다. 어떤 방법이 있을까? 역시 순환을 사용하면 쉬워진다. 어떤 노드를 루트로 하는 이진트리의 노드의 개수는 **왼쪽 서브트리의 노드수와 오른쪽 서브트리의 노드수**에 **루트 노드의 수(1)**을 더하면 된다. 이것은 **후위순회** 방식의 순환호출이다.

``` Python
def count_node(n):      # 순환을 이용해 트리의 노드 수를 계산하는 함수.
    if n is None:       # n이 None이면 공백트리 --> 0을 반환
        return 0
    else:               # 좌우 서브트리의 노드수의 합 + 1을 반환 (순환이용)
        return 1 + count_node(n.left) + count_node(n.right)
```

좌우 서브트리의 노드수를 각각 순환으로 구한 후 이들의 합에 1을 더하는 코드에 유의하라.

사실 약간은 무식하지만 다른 방법도 가능하다. 예를 들어 전역변수로 count를 선언해 0으로 초기화하고, 임의(전위, 중위, 후위)의 방법으로 노드들을 순회하면서 count를 증가시키는 것이다. 순회가 끝나면 노드 수는 전역변수 count에 저장되어 있을 것이다. 가능은 하지만 모듈화가 되지 않은 위험하고 아름답지 않은 방법이다.


### 단말 노드 개수 구하기

순환을 이용하면 단말 노드의 개수도 간단하게 계산할 수 있다. 단말 노드는 왼쪽자식과 오른쪽 자식이 모두 None인 노드이다. 만약 노드 n이 단말 노드이면 1을 반환하면 된다. 단말 노드가 아니면 자신의 두 서브트리의 단말 노드 개수를 순환호출을 통해 각각 계산하고, 계산된 두 값의 합이 전체 단말 노드의 개수이므로 이를 반환하면 된다. 코드는 다음과 같다.

``` Python
def count_left(n):              
    if n is None:                               # 공백트리 --> 0을 반환
        return 0
    elif n.left is None and n.right is None:    # 단말노드 --> 1을 반환
        return 1
    else:                                       # 비단말 노드 : 좌우 서브트리의 결과 합을 반환
        return count_leaf(n.left) + count_left(n.right)
```


### 트리의 높이 구하기

트리의 높이를 구하는 알고리즘도 순환을 이용하여 해결할 수 있다. 트리의 높이도 후위순회 구조를 사용해야 한다. 루트 노드의 높이를 구하려면 먼저 좌우 서브트리의 높이를 구해야 한다. 루트노드를 포함한 현재 트리의 높이는 좌우 서브트리의 높이 중에서 더 높은 값에 1을 더한 값이다.

![그림 8 20](https://user-images.githubusercontent.com/76824867/169660307-236fe991-657d-4e79-aa7e-6d4edd3b58cc.PNG)

[8.20] 이진트리의 높이를 구하는 방법

서브트리의 높이 계산을 위해 순환호출이 사용된다. 다음은 순환으로 구현된 트리의 높이를 구하는 함수이다. 순환호출의 반환 값을 서로 더하는 것이 아닌 것에 유의하라.

``` Python
def calc_height(n):                  
    if n is None:                       # 공백트리 --> 0을 반환
        return 0
    hLeft = calc_height(n.left)         # 왼쪽 트리의 높이 --> hLeft
    hRight = calc_height(n.right)       # 오른쪽 트리의 높이 --> hRight
    if (hLeft > hRight):                # 더 높은 높이에 1을 더해 반환.
        return hLeft + 1
    else:
        return hRight + 1
```

### 테스트 프로그램

지금까지 구현한 트리의 여러가지 연산들을 테스트해보자. 먼저 그림과 같은 이진트리를 만들어야 한다. 이를 위해 TNode의 생성자를 이용하여 링크를 하나씩 연결해야 한다. 테스트 코드는 다음과 같은데, Root가 트리의 루트노드 A를 가리킨다. 트리를 생성한 후 3가지 기본 순회와 순회 결과를 출력하고, 트리의 노드 수, 단말 노드의 개수 및 트리의 높이를 계산해 출력하였다.

``` Python
d = TNode('D', None, None)
e = TNode('E', None, None)
b = TNode('B', b, e)
f = TNode('F', None, None)
c = TNode('C', f, None)
root = TNode('A', b, c)

print('\n In-Order : ', end = '')
inorder(root)
print('\n Pre-Order : ', end = '')
preorder(root)
print('\n Post-Order : ', end = '')
postorder(root)
print('\nLevel-Order : ', end = '')
levelorder(root)
print()

print('노드의 개수 = {}개'.format(count_node(root)))
print('단말의 개수 = {}개'.format(count_leaf(root)))
print('트리의 높이 = {}'.format(calc_height(root)))
```

이 코드의 실행결과는 다음과 같다.


## 8.4 이진트리의 응용 : 모르스 코드 결정트리

모르스 부호는 **도트(점)**와 **대시(선)**의 조합으로 구성된 메시지 전달용 부호로 1830년대에 미국의 사뮤엘 모르스(Samuel Morse)에 의해 고안되었다. 이 코드는 메시지를 전선을 통해 장거리로 전송할 수 있도록 하여 통신에 혁명을 일으켰으며, 미국 철도 회사들에서 광범위하게 사용되었다. 가장 유명한 모르스 코드로는 SOS를 나타내는 ... --- ...이 있는데, 각 알파벳들에 대해 다음과 같이 점과 선으로 이루어진 코드가 부여되어 있다.

![표 8 1](https://user-images.githubusercontent.com/76824867/169660270-118e4817-c94e-455a-8697-35805ffc298b.PNG)

[표 8.1] 영문 대문자에 대한 모르스 코드 표

### 인코딩 : 알파벳에서 모르스 코드로 변환

알파벳을 모르스 부호로 변환(Encoding)하는 방법은 간단하다. 표에서 찾아 해당 코드를 적으면 되기 때문이다. 예를 들어 'PYTHON'의 모르스 코드는 다음과 같다.

.--.  -.--  -  ....  ---  -. 

만약 표에 모르스 부호가 알파벳 'A'부터 순서대로 들어있다면 각 알파벳에 대한 모르스 부호는 바로 찾을 수 있다. 예를 들어, 'P'에 대한 모르스 부호는 표의 'P'-'A' 위치에 있을 것이기 때문이다. 따라서 알파벳을 탐색키로 해당 모르스 코드를 찾는 연산은 O(1)만에 가능하다.


### 디코딩 : 모르스 코드에서 알파벳 변환

반대로 모르스 코드가 있을 때 알파벳을 추출(Decoding)하는 방법을 생각해보자. 예를 들어, 위의 코드에서 **.--.**에 대한 알파벳을 찾는 것이다. 어떻게 찾아야 할까? 이 경우는 앞에서와 같이 모르스 코드 **.--.**의 **주소를 바로 계산할 수 없다**. 어쩔 수 없이 표의 모든 항목을 조사하여 모르스 코드 .--.가 있는지 검사하여야 한다. 이것은 순차탐색이고, 탐색의 시간복잡도는 $O(n)$이다. 만약 숫자와 특수기호 등 더 많은 알파벳에 대해 모르스 코드를 부여해 사용한다면 표가 더 커질 것이고, 더 많은 시간이 걸릴 것이다.


### 결정트리를 이용한 모르스 코드의 디코딩

보다 효율적인 방법이 있다. **결정트리(Decision Tree)**를 이용하는 것이다. 결정트리는 **여러 단계의 복잡한 조건을 갖는 문제에 대해 조건과 그에 따른 해결방법을 트리 형태로 나타낸 것**을 말한다.

다음 그림은 위의 표에 대한 결정트리를 나타낸다. 루트를 제외한 모든 노드는 하나의 알파벳을 나타낸다. 루트에서 시작하여 코드에 점(.)이 나타나면 왼쪽 자식으로 움직인다. 선(-)이 나타나면 오른쪽 자식으로 움직인다. 이 과정을 코드 전체에 대해 수행하면 해당 코드의 알파벳 노드에 도착한다.

![그림 8 21](https://user-images.githubusercontent.com/76824867/169660310-9c714b49-1c00-4722-863a-8f02091812d8.PNG)

[그림 8.21] 모르스 코드를 위한 결정트리

.--. 코드에 대해 적용해보자. 루트에서 시작하여 왼쪽(E) -> 오른쪽(A) -> 오른쪽(W) -> 왼쪽(P)으로 움직인다. 결국 P에서 탐색이 끝난다. 없는 코드는 어떻게 처리될까? 예를 들어 --..를 찾아보자. 오른쪽(T) -> 오른쪽(M) -> 왼쪽(G) -> 왼쪽(Z)까지는 움직일 수 있다. 마지막으로 왼쪽으로 가야 하는데 노드가 없고, 이것은 잘못된 모르스 코드임을 나타낸다. 이 방법으로 코드에서 알파벳을 찾는데 걸리는 시간은 $O(log_2 n)$이다. 어떤 코드도 트리의 높이 이상의 이동이 필요하지 않기 때문이다. 따라서 단순히 표에서 찾는 방법 ($O(n)$)보다 훨씬 효율적이다.

모르스 코드표가 주어졌을 때 결정트리를 만들어보자. 방법은 다음과 같다.

1. 빈 루트노드를 만든다. 한 번에 하나의 문자를 추가한다.
2. 문자를 추가할 때 루트부터 시작하여 트리를 타고 내려간다. 만약 타고 내려갈 자식 노드가 None이면 새로운 노드를 추가한다. 이 **노드의 문자는 아직 결정되지 않았다**.
3. 마지막 코드의 노드에 도달하면 그 노드에 문자를 할당한다.

모르스 코드표는 다음과 같이 파이썬 튜플의 리스트로 주어진다고 생각하자.

``` Python
table = [('A', '.-'), ('B', '-...'), ('C', '-.-.'), ('D', '-..'),
         ('E', '.'), ('F', '..-.'), ('G', '--.'), ('H', '....'),
         ('I', '..'), ('J', '.---'), ('K', '-.-'), ('L', '.-..'),
         ('M', '--'), ('N', '-.'), ('O', '---'), ('P', '.--.'),
         ('Q', '--.-'), ('R', '.-.'), ('S', '...'), ('T', '-'),
         ('U', '..-'), ('V', '...-'), ('W', '.--'), ('X', '-..-'),
         ('Y', '-.--'), ('Z', '--..')]
```

모르스 코드의 결정트리는 이진트리이므로 노드를 앞에서 사용한 TNode 클래스를 그대로 사용하면 된다. 코드 표를 이용해 결정트리를 만들고 루트노드를 반환하는 코드는 다음과 같다.

``` Python
def make_morse_tree():
    root = TNode(None, None, None)
    for tp in table:
        code = tp[1]                                        # 모르스 코드
        node = root
        for c in code:                                      # 맨 마지막 문자 이전까지 --> 이동
            if c == '.':                                    # 왼쪽으로 이동
                if node.left == None:                       # 비었으면 빈 노드 만들기
                    node.left = TNode(None, None, None)
                node = node.left                            # 그쪽으로 이동
            elif c == '-':                                  # 오른쪽으로 이동
                if node.right == None:                      # 비었으면 빈 노드 만들기
                    node.right = TNode(None, None, None)
                node = node.right                           # 그쪽으로 이동
        
        node.data = tp[0]                                   # 코드의 알파벳
    return root
```

결정트리를 이용해 모르스 코드에 대한 문자를 찾는 decode 함수는 다음과 같다.

``` Python
def decode(root, code):
    node = root
    for c in code:                  # 맨 마지막 문자 이전까지 --> 이동
        if c == '.':                # 점(.) : 왼쪽으로 이동
            node = node.left
        elif c == '-':              # 선(-) : 오른쪽으로 이동
            node = node.right
    return node.data                # 문자 반환
```

문자에 대한 코드를 찾아 반환하는 encode 함수는 다음과 같다. 파이썬의 내장함수 ord()는 문자를 아스키 코드로 바꿔주는 함수이다.

``` Python
def encode(ch):
    idx = ord(ch) - ord('A')    # 리스트에서 해당 문자의 인덱스
    return table[idx][1]        # 해당 문자의 모르스 부호 반환
```

마지막으로 문자열을 입력받아 모르스 코드로 바꾸고, 이 코드를 다시 문자열로 변경하는 테스트 프로그램은 다음과 같다.

``` Python
morseCodeTree = make_morse_tree()
str = input('입력 문장 :')
mlist = []
for ch in str:
    code = encode(ch)
    mlist.append(code)
print('Morse Code : {}'.format(mlist))
print('Decoding :', end = '')
for code in mlist:
    ch = decode(morseCodeTree, code)
    print(ch, end = '')
print()
```

입력 문장으로 GAMEOVER를 입력하고 이를 모르스 코드로 바꾼(encoding) 결과와, 이 모르스 코드를 다시 알파벳으로 변환(decoding)한 결과는 다음과 같다. GAMEOVER가 원래대로 복원되었다.



## 8.5 힙 트리

### 힙(Heap)이란?

**힙(heap)**을 영어사전에 찾아보면 "더미"라고 되어 있다. 컴퓨터 분야에서 힙은 "더미"와 모습이 비슷한 완전이진트리 기반의 자료구조를 의미한다. 힙은 **여러 개의 값들 중에서 가장 큰(또는 작은) 값을 빠르게 찾아내도록** 만들어진 자료구조이다. 가장 큰 값만 빨리 찾으면 되기 때문에 모든 자료를 힘들게 정렬할 필요는 없다. 힙은 이진트리 구조를 갖는데, 특히 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있도록 하는 정도의 **느슨한 정렬상태만을 유지**한다. 힙은 **최대 힙(Max Heap)**과 **최소 힙(Min Heap)**으로 나눌 수 있는데 다음과 같이 정의된다.

정의 8.2 최대 힙, 최소 힙의 정의

* **최대 힙(Max Heap)** :
    부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전이진트리
    ( **key(부모노드) >= key(자식노드)** )
* **최소 힙(Min Heap)** :
    부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전이진트리
    ( **key(부모노드) <= key(자식노드)** )

이들은 단지 부등호만 달라지고 나머지는 완전히 동일하다. 따라서 특별한 언급이 없으면 힙을 최대 힙이라고 가정하자. 다음은 힙 트리의 예시이다.

![그림 8 22](https://user-images.githubusercontent.com/76824867/169660312-838f577b-c7da-495f-a458-7f603c4096f4.PNG)

[그림 8.22] 최대 힙과 최소 힙

힙은 완전이진트리이다. 다음은 힙의 특성을 만족하는 것처럼 보이지만 완전이진트리가 아니기 때문에 힙이 아니다.

![5](https://user-images.githubusercontent.com/76824867/169660279-d09b5d24-334e-43d9-96f6-5a8df5e775d8.PNG)


### 삽입 연산

힙에 새로운 항목을 삽입하더라도 **힙의 순서 특성(최대 힙, 최소 힙)**과 **트리의 형태적 특성(완전이진트리)**을 반드시 유지해야 한다. 힙의 삽입 연산을 알아보자. 힙의 삽입 연산은 회사에서 신입사원이 들어오면 일단 말단 위치에 앉힌 다음에, 신입사원의 능력을 봐서 위로 승진시키는 과정과 유사하다.

1. 새로운 항목이 들어오면 힙의 마지막 노드의 다음 위치에 삽입한다. 이렇게 하면 **완전이진트리 조건은 만족**하지만 힙의 순서 특성은 만족하지 않는다.
2. 마지막에 삽입된 새로운 노드를, **부모 노드들과 교환해서 힙의 순서 특성을 만족시켜주는 과정**을 처리한다. 최대 트리의 높이만큼의 이동이 필요하다.

예를 들어, 다음 최대 힙에 8을 삽입해보자.

(1) 항목 8을 위한 노드를 생성하고, 완전이진트리의 마지막 노드로 삽입한다. 여전히 완전이진트리이지만 순서 특성은 만족하지 않는다.

![그림 8 23](https://user-images.githubusercontent.com/76824867/169660314-55ba10e8-5101-42ec-8af6-eeeae181e44a.PNG)

[그림 8.23] 최대 힙의 삽입연산 : 1단계

(2) 부모 노드 4와 비교한다. 삽입 노드 8이 더 크므로 교환(Shift-Up)한다.

![그림 8 24](https://user-images.githubusercontent.com/76824867/169660315-097ad215-0997-456f-8ae2-09abe84c860c.PNG)

[그림 8.24] 최대 힙의 삽입연산 : 2단계

(3) 부모 노드 7과 비교한다. 삽입 노드 8이 더 크므로 교환(Shift-Up)한다.

![그림 8 25](https://user-images.githubusercontent.com/76824867/169660316-7ba4a235-3c4b-4ad0-a3ed-c6e12536e0d8.PNG)

[그림 8.25] 최대 힙의 삽입연산 : 3단계

(4) 부모 노드 9와 비교한다. 부모노드가 더 크므로 더 이상 교환하지 않는다.

힙의 순서 특성을 만족하기 위해 마지막 노드로 삽입된 새 항목은 루트 노드까지의 경로에 따라 적절한 위치를 찾을 때까지 부모노드와 교환하면서 위로 올라가야 한다. 이러한 과정을 **시프트업(Sift-Up)** 또는 **업힙(Up-Heap)**이라 부른다. 이 과정은 몇 번 이루어질까? 최악의 경우는 루트 노드까지 올라가야 하므로 트리의 높이에 해당하는 비교 연산 및 이동 연산이 필요하다. 힙은 완전이진트리이므로 노드의 개수가 $n$이면 힙의 높이는 $log_2 n$이다. 따라서 삽입연산의 **시간복잡도는 $O(log_2 n)$**이다.


### 삭제 연산

힙에서 삭제 연산은 루트 노드를 꺼내는 것이다. 꺼내기만 하면 완전이진트리가 아니다. 어떻게 힙의 성질을 계속 유지하도록 힙 트리를 재구성할까? 기본 아이디어는 회사에서 사장의 자리가 비면 제일 말단 사원을 사장 자리로 옮기고 순차적으로 강등시키는 것과 비슷하다. 최대 힙에서 삭제연산을 생각해보자.

1. 루트 노드에 마지막 노드를 올린다. 이렇게 하면 완전이진트리 조건은 만족하지만 힙의 순서 특성은 만족하지 않는다.
2. 루트 노드를 자식과 비교하여 자식이 더 크면 교환한다. 이때, **자식들 중에서 더 큰 자식이 교환후보**가 된다. 이 과정을 자식이 없거나 자식이 더 작을 때까지 반복한다.

다음의 힙 트리에서 루트 노드를 삭제해보자.

(1) 루트 노드를 삭제하고 빈 루트 노드 자리에는 힙의 마지막 노드를 가져온다.

![그림 8 26](https://user-images.githubusercontent.com/76824867/169660317-e15bcabe-29bd-4c85-9b23-82915a762b2b.PNG)

[그림 8.26] 최대 힙의 삭제연산 : 1단계

(2) 새로운 루트인 3과 자식 노드들을 비교한다. 이때 최대 힙에서는 반드시 더 큰 노드와 비교해야 한다. 최소 힙에서는 더 작은 노드와 비교한다. 3과 자식 노드 7을 비교하고, 자식이 크므로 **교환(Sift-Down or Down-Heap)**한다.

![그림 8 27](https://user-images.githubusercontent.com/76824867/169660319-93b1588a-e9da-4273-89b0-dc9cf8a2989b.PNG)

[그림 8.27] 최대 힙의 삭제연산 : 2단계

(3) 더 큰 자식노드 5와 비교한다. 5가 더 크므로 교환한다.

![그림 8 28](https://user-images.githubusercontent.com/76824867/169660320-f92ba4fc-b387-4ab1-abc7-a14fe0a4b6e7.PNG)

[그림 8.28] 최대 힙의 삭제연산 : 3단계

(4) 더 큰 자식 노드인 2와 비교한다. 3이 더 크므로 교환은 필요없고 종료한다.

![그림 8 29](https://user-images.githubusercontent.com/76824867/169660321-50c7f3b7-9ff8-40b2-86fc-a1ae43d5a34d.PNG)

[그림 8.29] 최대 힙의 삭제연산 : 4단계

다운 힙 과정도 최악의 경우 트리의 높이에 해당하는 비교가 필요하다. 따라서 삭제연산의 **시간복잡도는 $O(log_2 n)$**이다.


### 힙을 저장하는 효과적인 자료구조는 배열이다.

#### 배열을 이용한 힙의 표현

모든 이진트리를 포화이진트리라고 생각하고 각 노드에 번호를 붙일 수 있었다. 특히 힙은 완전이진트리이기 때문에 중간에 비어있는 요소가 없다. 따라서 이 번호를 인덱스로 생각하고 배열구조에 힙의 노드들을 저장할 수 있다. 즉, 힙을 저장하는 효과적인 자료구조는 배열이다. 프로그램 구현이 쉽도록 배열의 첫번째 인덱스 0은 사용하지 않는다. 트리에 새로운 노드가 추가되더라도 기존 노드의 번호는 변하지 않는다. 다음은 힙 트리를 배열 구조로 표현한 것이다.

![그림 8 30](https://user-images.githubusercontent.com/76824867/169660322-bb7dbf08-65ca-4e3c-b271-3fe7bb93f986.PNG)

[그림 8.30] 배열구조를 이용한 힙의 표현

배열로 힙을 표현하면 자식과 부모 노드의 위치(인덱스)를 쉽게 계산할 수 있다. 어떤 노드의 부모나 왼쪽, 오른쪽 자식노드의 위치는 다음과 같이 계산된다.

* 부모의 인덱스 = (자식의 인덱스) / 2
* 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
* 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1

![그림 8 31](https://user-images.githubusercontent.com/76824867/169660323-e0ed22f7-8345-4623-a650-732ea52f015f.PNG)

[그림 8.31] 힙 트리에서 자식과 부모노드의 인덱스 관계


### 최대 힙의 구현

최대 힙 클래스 MaxHeap을 구현해보자. 항목을 저장하기 위해 생성자에서 배열구조인 파이썬의 리스트로 Heap을 선언한다. 0번 인덱스를 사용하지 않으므로, 공백 상태에도 Heap에는 하나의 항목(0번 항목)이 들어있어야 한다. 따라서 Size 연산은 리스트 크기 - 1이다. 출력함수 display에서도 리스트의 0번 항목은 제외하고 출력해야 한다. 리스트의 슬라이싱 기법을 사용하는데, Heap[1:]은 1번 항목부터 리스트의 마지막 항목까지를 의미한다.

``` Python
class MaxHeap:                                  # 최대 힙 클래스
    def __init__(self):                         # 생성자
        self.heap = []                          # 리스트(배열)을 이용한 힙
        self.heap.append(0)                     # 0번 항목은 사용하지 않음
    
    def size(self):                             # 힙의 크기
        return len(self.heap) - 1
    
    def isEmpty(self):                          # 공백검사
        return self.size() == 0
    
    def Parent(self, i):                        # 부모노드 반환
        return self.heap[i//2]
    
    def Left(self, i):                          # 왼쪽 자식 반환
        return self.heap[i * 2]
    
    def Right(self, i):                         # 오른쪽 자식 반환
        return self.heap[i * 2 + 1]
    
    def display(self, msg = 'Heap Tree: '):
        print(msg, self.heap[1:])               # 파이썬 리스트의 슬라이싱 사용
```

삽입 연산의 업힙 과정에서 두 노드를 바꿀 필요는 없다. 부모 노드만 계속 끌어내리고 삽입할 노드는 마지막에만 처리하면 된다. 코드는 다음과 같다.

``` Python
    def insert(self, n):
        self.heap.append(n)                         # 맨 마지막 노드로 일단 삽입
        i = self.size()                             # 노드 n의 위치
        while (i != 1 and n > self.Parent(i)):      # 부모보다 큰 동안 계속 업힙
            self.heap[i] = self.Parent(i)           # 부모를 끌어내림
            i = i // 2                              # i를 부모의 인덱스로 올림
        self.heap[i] = n                            # 마지막 위치에 n 삽입
```

삭제 연산의 다운힙에서도 마찬가지이다. 큰 자식 노드를 계속 끌어올리고, 마지막 노드는 한 번만 복사하면 된다. 다운힙은 두 자식 노드 중에서 더 큰 자식에 대해 처리해야 하는 것에 유의하라.

``` Python
    def delete(self):
        parent = 1
        child = 2
        if not self.isEmpty():
            hroot = self.heap[1]                        # 삭제할 루트를 복사해 둠
            last = self.heap[self.size()]               # 마지막 노드
            while (child <= self.size()):               # 마지막 노드 이전까지
                # 만약 오른쪽 노드가 더 크면 child를 1 증가 (기본은 왼쪽 노드)
                if child < self.size() and self.Left(parent) < self.Right(parent):
                    child += 1
                if last >= self.heap[child]:            # 더 큰 자식이 더 작으면
                    break                               # 삽입 위치를 찾음. down-heap 종료
                self.heap[parent] = self.heap[child]    # 아니면 down-heap 계속
                parent = child
                child *= 2
            
            self.heap[parent] = last                    # 맨 마지막 노드를 parent 위치에 복사
            self.heap.pop(-1)                           # 맨 마지막 노드 삭제
            return hroot                                # 저장해두었던 루트를 반환
```

테스트 코드와 실행결과는 다음과 같다.

``` Python
heap = MaxHeap()                        # MaxHeap 객체 생성
data = [2, 5, 4, 8, 9, 3, 7, 3]         # 힙에 삽입할 데이터
print('[삽입 연산] :', data)

for elem in data:                       # 모든 데이터를
    heap.insert(elem)                   # 힙에 삽입

heap.display('[ 삽입 후 ] : ')            # 현재 힙 트리를 출력
heap.delete()                           # 한 번의 삭제연산
heap.display('[ 삭제 후 ] : ')            # 현재 힙 트리를 출력
heap.delete()                           # 또 한 번의 삭제연산
heap.display('[ 삭제 후 ] : ')            # 현재 힙 트리를 출력
```

힙은 삽입과 삭제 연산의 시간복잡도가 모두 $O(log_2 n)$으로 매우 효율적이다. 특히 힙은 많은 데이터 중에서 **가장 큰 몇 개를 뽑을 때 매우 유용**하다.


### 우선순위 큐의 가장 좋은 구현방법은 힙이다.

5장에서 우선순위 큐를 공부했는데, 힙을 이용해 우선순위 큐를 구현할 수 있다. 우선순위 큐를 구현하는 여러 다른 방법들의 성능을 비교해보자.

#### 삽입 연산

* 정렬되지 않은 배열을 이용하면 삽입이 간단하다. 맨 마지막 항목으로 추가하기만 하면 되기 때문이다. 시간복잡도는 $O(1)$이다.
* 배열을 정렬시키려면 우선순위에 따라 삽입할 위치를 먼저 찾아야 한다. 최악의 경우 전체 항목을 비교해야 한다. 위치를 찾더라도 중간에 항목을 끼우기 위해 많은 항목의 이동이 필요했던 것도 기억하라. 시간복잡도는 $O(n)$이다.
* 힙을 이용하면 삽입연산의 시간복잡도가 $O(log_2 n)$이다.


#### 삭제 연산

* 배열이 정렬되어 있지 않으면 삭제가 번거롭다. 먼저 우선순위가 가장 높은 항목을 찾는데 $O(n)$이 걸린다. 삭제시 많은 항목의 이동도 필요하다.
* 배열이 정렬되면 삭제가 단순해진다. 단, 우선순위가 가장 높은 항목이 배열의 맨 끝에 있어야 한다. 삭제 연산은 맨 마지막 항목을 꺼내 반환하는 연산이다. 항목의 이동도 필요 없으므로 시간복잡도는 $O(1)$이다.
* 힙을 이용하면 루트를 반환하고 한 번의 다운힙이 필요하다. 다운힙의 시간복잡도는 $O(log_2 n)$이다.


#### 탐색 연산

* 정렬되지 않은 배열을 이용하면 먼저 우선순위가 가장 높은 항목을 찾아야 한다. 따라서 탐색의 시간복잡도는 $O(n)$이다.
* 배열이 정렬되면 맨 마지막 항목을 반환하면 된다. 시간복잡도는 $O(1)$이다.
* 힙은 루트를 반환하면 되므로 탐색연산의 시간복잡도가 O(1)이다.

![표 8 2](https://user-images.githubusercontent.com/76824867/169660271-c556d4d9-6c73-407b-99af-566377c9912c.PNG)

[표 8.2] 다양한 방법으로 구현한 우선순위 큐의 성능 비교

결국 우선순위 큐를 구현하는 가장 좋은 방법은 힙이다. 최악의 경우도 $O(log_2 n)$의 시간을 보장해주기 때문이다.

> 파이썬에는 힙을 지원하는 heapq 모듈이 있다. 이 모듈은 리스트를 힙으로 변경하는 heapify() 함수를 지원한다. 단, 이 함수는 최소힙을 만든다. 사용 예시는 다음과 같다.

``` Python
import heapq
arr = [5, 3, 8, 4, 9, 1, 6, 2, 7]
print(arr)
heapq.heapify(arr)
print(arr)
print(heapq.heappop(arr))
print(heapq.heappop(arr))
print(heapq.heappop(arr))
print(arr)
```


## 8.6 힙의 응용 : 허프만 코드

영어단어들을 공부하다보면 많은 알파벳 'e'가 많이 나오는 것에 비해 'z'가 들어있는 단어는 많지 않음을 알 수 있다. 만약 어떤 문서에 있는 각 알파벳의 빈도를 미리 알 수 있다면 이진트리를 이용하여 이 문서를 압축하여 용량을 줄일 수 있다. 이런 종류의 이진트리를 **허프만 코딩 트리**라고 부른다.

![그림 8 32](https://user-images.githubusercontent.com/76824867/169660325-24f30de9-7be8-45b2-9c96-d0591b42fd26.PNG)

[그림 8.32] 허프만 코드를 위한 문자별 빈도수 분석

어떤 영문 신문에 실린 기사에서 분석한 각 문자의 빈도수가 그림과 같다고 가정하자. 테이블의 각 숫자들은 영문 텍스트에서 해당 글자가 나타나는 빈도수이다. E가 123인데 비해 Z는 1이다. 이것은 E가 Z에 비해 123배 더 자주 사용되었다는 것을 의미한다. 우리가 흔히 사용하는 아스키(ASCII) 코드는 모든 문자를 동일한 비트수로 표현하는데, 압축의 관점에서는 효율적이지 않다. 자주 사용되는 문자에는 적은 비트수를 부여하고 그렇지 않은 문자에는 많은 비트수를 부여해 문서의 크기를 줄일 수 있기 때문이다. 다음 2가지 방법을 생각해보자. E와 Z만을 표현하려고 한다.


1. 모든 문자를 7비트로 표현 : 7bit * (E 123회 + Z 1회)
2. E는 2비트로, Z를 20비트로 표현 : 2bit * (E 123회) + 20bit * (Z 1회)

첫번째 방법이 868 비트가 필요한데 비해 두번째 방법은 266 비트만 있으면 동일한 문서를 표현할 수 있다. 따라서 압축할 때는 아스키(ASCII) 코드와 같은 **고정길이코드**를 사용하지 않고 **가변길이코드**를 흔히 사용한다. 각 문자의 빈도수에 따라서 가장 많이 등장하는 문자에는 짧은 비트열을 사용하고 잘 나오지 않는 문자에는 긴 비트열을 사용하여 전체의 크기를 줄이는 방법이다.

텍스트가 A ~ J로만 이루어져 있고 각 글자의 빈도수가 다음 표와 같다고 가정하자. 10가지 문자를 표현하기 위해 고정길이 코드를 사용하면 최소 4비트($2^4 = 16$가지 표현가능)가 필요하다. 만약 오른쪽과 같은 가변길이 코드를 사용하면 글자마다 코드의 비트수가 달라진다. 고정길이 코드에 비해 어떤 문자(A, E 등)는 더 적은 비트를 사용하고 어떤 문자(G, J 등)는 더 많은 비트로 표현된다.

![표 8 3](https://user-images.githubusercontent.com/76824867/169660273-ed26d089-b63a-4bbb-8569-58ffea9f9020.PNG)

[표 8.3] 빈도수가 알려진 문자에 대한 고정길이코드와 가변길이코드의 비교

100개의 문자로 이루어진 전체 텍스트를 표현하기 위한 비트수를 계산해보자. 각 코드의 비트수를 빈도수에 곱하여 모두 더하면 전체 비트수가 계산된다. 고정길이의 경우 모든 글자가 4비트이므로 전체 비트수는 4 * 100으로 400비트가 필요하다. 가변길이코드에서는 292 비트만 있으면 동일한 텍스트를 표현할 수 있다. (실제로는 각각의 문자에 대해 사용한 코드표가 있어야 하지만, 전체 텍스트가 충분히 길다면 이는 무시할 수 있다.)

그러면 실제로 단어를 어떻게 표현하고 읽는지를 살펴보자. 'FACE'란 단어의 경우 다음 그림과 같이 표현된다.

![그림 8 33](https://user-images.githubusercontent.com/76824867/169660326-399d2a95-8d50-4d2b-8bbd-f674f536cb46.PNG)

[그림 8.33] "FACE"를 표 8.3의 코드로 표현하는 방법

고정길이코드에서는 0101 0000 0010 0100과 같이 순서대로 4비트씩 끊어서 코드를 적거나 읽으면 된다. 가변길이 코드로 코딩된 011100011010는 어떻게 해독할까? 한 비트씩 읽으면서 테이블에 코드가 있으면 한 문자로 처리한다. 예를 들어 첫 문자인 0은 테이블에 없으므로 다음 코드까지 읽는다. 01도 테이블에 없다. 011도 마찬가지이다. 마지막으로 0111은 테이블에서 F에 해당하는 코드이다. 따라서 첫 문자는 4비트를 사용한 F가 된다. 이 방법을 계속 진행하면 "FACE"라는 원문을 추출할 수 있다.

이런 해독과정이 가능하려면 위의 표와 같이 **모든 가변길이코드가 다른 코드의 첫 부분이 아니어야 한다**. 따라서 코딩된 비트열을 왼쪽에서 오른쪽으로 조사해보면 정확히 하나의 코드만 일치하는 것을 알 수 있다. 이런 종류의 코드를 **허프만 코드(Huffman Codes)**라고 하고, 허프만 코드를 만들기 위해 이진트리를 사용할 수 있다.


### 허프만 코드 생성 방법

허프만 코드를 만드는 절차를 살펴보자. 단순화를 위해 문자는 's', 'i', 'n', 't', 'e'만 사용하고, 빈도수가 각각 4, 6, 8, 12, 15로 주어졌다고 하자.

* 1단계 : 각 문자별로 노드를 생성. 노드의 값은 빈도수가 됨. 각 노드는 모두 독립적인 트리의 루트가 됨.
* 2단계 : **가장 작은 빈도수의 두 노드**를 찾아 묶어 이진트리를 구성. 이 때 **루트의 값은 자식 노드의 값의 합**이 됨. 's'와 'i'가 하나의 트리로 묶이고, 이제 10, 8, 12, 15를 루트로 하는 4개의 트리가 남음.

![그림 8 34](https://user-images.githubusercontent.com/76824867/169660327-b8602dc9-55ed-4f90-8a7d-c94cdb77825d.PNG)

[그림 8.34] 허프만 코딩 트리 생성과정 : 1~2 단계

* 3단계 : 남은 트리에서 가장 작은 빈도수의 루트를 2개 찾아 묶어 이진트리를 구성. 10과 8이 선택되고, 이제 18, 12, 15를 루트로 하는 3개의 트리가 남음.
* 4단계 : 남은 트리에 대해서도 동일한 처리를 함. 12와 15가 선택되고, 이제 18과 27을 루트로 하는 2개의 트리만 남음.

![그림 8 35](https://user-images.githubusercontent.com/76824867/169660267-6fb3cbf6-0b63-4fb4-a960-b38399ec13d4.PNG)

[그림 8.35] 허프만 코딩 트리 생성과정 : 3~4 단계

* 5단계 : 마지막으로 18과 27을 묶음. 최종 허프만 트리는 1개가 됨.
* 6단계 : 마지막으로 코드를 할당함. 트리에서 왼쪽 간선은 비트 1을 나타내고 오른쪽 간선은 비트 0을 나타낸다고 하고, 루트에서부터 그 노드로 이동하면서 코드를 순서대로 적으면 각 문자별로 최종 코드가 됨.

![그림 8 36](https://user-images.githubusercontent.com/76824867/169660268-699a6e84-9652-4e35-8fc9-1d68a1a6dcc1.PNG)

[그림 8.36] 허프만 코딩 트리 생성과정 : 5~6 단계


허프만 코드 알고리즘에서 여러 문자의 빈도수들 중에서 가장 작은 2개를 찾는 과정이 있다. 이때 힙 트리를 사용하면 효과적이다. 작은 값 2개를 찾아야 하므로 여기서는 **최소힙을 이용**하여야 함에 유의하라. 최소 힙은 앞에서 구현한 MaxHeap을 약간만 수정하면 된다. 허프만 트리를 만드는 함수 make_tree()에서는 각 문자의 빈도수를 입력받아 모든 노드를 힙에 삽입한다. 다음으로 현재 힙에서 최소 노드 2개를 뽑고 이들을 묶어서 만든 새로운 노드를 다시 힙에 삽입하는 과정을 반복한다. 전체 문자의 수가 $n$개인 경우 이 과정을 $n-1$번 실행하면 최종적으로 허프만 코드가 만들어진다.

``` Python
def make_tree(freq):
    heap = MinHeap()
    for n in freq:
        heap.insert(n)
    
    for i in range(1, len(freq)):
        e1 = heap.delete()
        e2 = heap.delete()
        heap.insert(e1 + e2)
        print(' ({} + {})'.format(e1, e2))
```

``` Python
label = ['E', 'T', 'N', 'I', 'S']
freq = [15, 12, 8, 6, 4]
make_tree(freq)
```

프로그램의 실행결과에서는 최소 빈도수의 노드들이 합해지는 과정을 보여준다. 만약 이 프로그램으로 만들어진 트리에서 각 문자별 가변길이 코드를 만들기 위해서는 추가적인 코드가 필요할 것이다.


# Reference

* <파이썬으로 쉽게 풀어쓴 자료구조>, 최영규, 천인국 저, 생능출판사, 2020.02.24

---
