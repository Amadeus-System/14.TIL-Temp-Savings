

# Chapter 6. 연결된 구조

## 6.1 연결된 구조란?

### 연결된 구조는 흩어진 데이터를 링크로 연결해서 관리한다.

많은 자료를 저장하고 관리하기 위해 **배열구조**나 **연결된 구조**를 사용할 수 있다는 것은 공부했지만, 지금까지는 리스트, 스택, 큐, 덱 등 모든 자료구조를 배열 구조로 구현하였다. 이제 연결된 구조로 자료구조를 표현하는 방법을 알아보자.

**배열 구조**의 가장 큰 특징은 모든 항목들을 **연속된 메모리 공간**에 저장하는 것인데, 연결된 구조에서는 이와 같이 데이터를 한 곳에 모아두는 것을 포기한다. 즉, 항목들이 메모리상에서 여기저기 흩어져서 존재할 수 있다. 그렇다면 어떻게 흩어진 데이터를 모아서 관리할 수 있을까? **링크(Link)**를 이용한다. 즉, 항목들이 다른 항목을 가리키는 하나 이상의 링크(그림에서 상자에 연결된 줄)를 갖도록 하여 전체 항목들이 하나로 연결되도록 하는 것이다.

이와 같이 항목들을 링크로 연결하여 표현하는 방법을 **연결된 구조(Linked Structure)**라 한다. 특히 항목들을 링크를 통해 **일렬로 나열할 수 있는 연결된 구조**를 **연결 리스트(Linked List)**라 부른다. 그림에서 하나의 상자를 **노드(Node)**라고 하는데, **데이터**와 함께 **링크**를 갖는다. 연결된 구조에서 링크의 수를 늘리면 선형자료구조 뿐 아니라 트리나 그래프와 같이 더 복잡한 구조도 효율적으로 표현할 수 있다. 그렇지만 배열 구조에서와 같이 한번에 $k$번째 항목의 주소를 계산해서 바로 찾아갈 수 없음에 유의하라. 시작 항목에서부터 링크를 따라 각 항목을 하나씩 찾아갈 수 밖에 없다. 모든 것에는 장점과 단점이 있다.


[그림 6.1] 배열 구조와 연결된 구조의 비교



### 배열 구조와 연결된 구조의 장단점

* 배열 구조와 달리 연결된 구조는 **용량이 고정되지 않는다**. 즉 필요한 것만 필요할 때 만들어 쓰기 때문에 메모리를 효율적으로 사용한다. 또한 컴퓨터에 메모리가 남아 있는 한 계속 자료를 넣을 수 있다.


[그림 6.2] 연결된 구조에서는 용량이 고정되지 않는다.



* 중간에 자료를 **삽입하거나 삭제하는 것이 용이**하다. 파이썬의 리스트와 같은 배열 구조에서는 많은 항목들의 이동이 필요함을 기억하라. 연결된 구조에서는 그림과 같이 링크만 수정하면 되므로 시간복잡도가 $O(1)$이다.



[그림 6.3] 연결된 구조에서는 중간에 데이터를 삽입하거나 삭제하는 것이 용이하다.


* 연결된 구조에서는 **$n$번째 항목에 접근하는데 $O(n)$의 시간이 걸린다**. 이것은 배열 구조의 $O(1)$과 비교하면 큰 단점이다. 또한 배열에 비해 상대적으로 구현이 어렵고 오류가 발생하기도 쉽다.


### 연결 리스트의 구조

#### 노드(Node)

그림의 연결된 구조에서 하나의 상자는 컴퓨터 용어로 **노드(Node)**라고 한다. 배열 구조에서 각 항목들은 데이터만을 갖는 것과 달리 노드는 **데이터 필드(Data Field)**와 함께 **하나 이상**의 **링크 필드(Link Field)**를 갖는다. 연결 리스트의 대표적인 노드 구조는 다음과 같다.


[그림 6.4] 연결된 구조에서의 노드 구조



**데이터 필드**에는 우리가 저장하고 싶은 데이터가 들어간다. 이것은 정수가 될 수도 있고 복잡한 클래스의 객체나 심지어 다른 리스트도 될 수 있다. **링크 필드**는 다른 노드를 **가리키는**, 즉 다른 노드의 **주소를 저장하는 변수**이다. 이것을 이용해 연결된 다음 노드에 접근할 수 있다. 배열에 비해 링크를 위한 약간의 추가 공간이 필요하지만, 대부분의 경우 데이터 필드가 훨씬 크므로 링크를 위한 공간은 무시할 수 있다.



#### 헤드 포인터(Head Pointer)

연결 리스트는 첫번째 노드만 알면 링크로 매달려 있는 모든 노드에 순차적으로 접근할 수 있다. 따라서 시작 노드의 주소를 반드시 저장해야 한다. 연결 리스트에서 첫번째 노드의 주소를 저장하는 변수를 헤드 포인터(Head Pointer)라고 한다. 마지막 노드는 더 이상 연결할 노드가 없다. 따라서 링크의 값을 None으로 설정하여 이 노드가 마지막임을 표시한다.


[그림 6.5] 연결된 구조에서의 시작 노드의 주소를 잘 관리해야 한다.



포인터(Pointer)는 다른 객체를 **가리키고(Pointing) 있는 변수**라는 의미이다. C나 C++ 등에서는 포인터의 개념이 매우 중요하게 사용되고 있고, 이들 언어 측면에서 보면 파이썬의 모든 변수는 **포인터나 참조자(Reference)**와 같은 의미로 사용된다고 볼 수 있다. 그렇지만 파이썬에서 메모리의 해제와 같은 포인터와 관련된 번거로운 작업들이 자동으로 처리되기 때문에 부담없이 포인터를 그냥 변수로 생각하고 사용하면 된다.



### 연결 리스트의 종류

#### 단순연결리스트(Singly Linked List)

하나의 방향으로만 연결되어 있는 구조를 갖는다. 따라서 링크는 하나이며, 이 변수는 다음 노드의 주소를 기억하고 있다. 마지막 노드의 링크는 아무것도 연결되어 있지 않다는 것을 나타내기 위해 반드시 None 값을 가져야 한다는 것을 명심하라. 6.2와 6.3절에서 **스택**과 **리스트**를 단순연결리스트로 다시 구현해 볼 것이다.


[그림 6.6] 단순연결리스트의 구조



#### 원형연결리스트(Circular Linked List)

단순연결리스트와 동일한 노드 구조를 사용하지만 맨 마지막 노드의 링크 값이 None이 아니라 다시 첫번째 노드를 가리킨다는 것이 다르다. 따라서 노드들을 순서대로 방문할 때 **종료조건**에 유의해야 한다. 6.4절에서 **큐**를 원형연결리스트로 다시 구현해보자.

[그림 6.7] 원형연결리스트의 구조



#### 이중연결리스트(Doubly Linked List)

하나의 노드가 이전 노드와 다음 노드를 모두 알고 있도록 설계되었다. 따라서 2개의 링크를 갖는데, 하나는 **선행 노드(Previous Node)**를 다른 하나는 **후속 노드(Next Node)**를 가리킨다. 이중연결리스트의 노드 구조는 다음과 같다.

[그림 6.8] 이중연결리스트에서의 노드의 구조



선행 노드를 위한 링크가 있으면 어떤 노드에서 이전 노드를 바로 찾아갈 수 있다는 장점이 있다. 편리한 만큼 이중으로 링크를 정확히 유지해야 하기 때문에 코드가 복잡해진다. 6.5절에서 덱을 이중연결리스트로 구현해 볼 것이다.


[그림 6.9] 이중연결리스트의 구조



## 6.2 단순연결리스트 응용 : 연결된 스택

단순연결리스트로 스택을 구현하자. 이러한 스택을 **연결된 스택(Linked Stack)**이라 한다. 스택은 입출력이 상단으로 제한되는 자료구조이다. 4장에서 배열 구조로 스택을 구현하였다. 이때 top은 파이썬의 리스트를 가리켰으며, 삽입과 삭제 연산은 리스트인 top의 후단을 통해 이루어졌다.

단순연결리스트 구조의 연결된 스택에서는 무엇을 top으로 사용해야 할까? 단순연결리스트의 **헤드 포인터를 스택의 top**으로 사용하면 된다. 모든 자료의 입출력이 top을 통해 가능하므로 추가적인 변수도 필요없다. 이와 같이 연결된 스택은 **단순연결리스트의 가장 간단한 응용**이다. 스택의 구현 방법이 달라지더라도 사용 방법은 동일하다. 따라서 연결된 스택을 4장에서 공부한 스택의 테스트 코드에 그대로 활용할 수 있다.




### 클래스 정의

연결된 스택을 위해서는 노드와 스택 클래스를 각각 구현해야 한다. 먼저 노드 클래스를 구현하자. 단순연결리스트를 위한 노드는 데이터 필드와 하나의 링크만 있으면 되고, 이들은 생성자에서 선언 및 초기화된다. 다음 코드는 Node 클래스의 구현을 보여주는데, 링크는 디폴트 인수 기능을 이용해 인수가 전달되지 않으면 None으로 초기화하도록 하였다.

``` Python
class Node():                                   # 단순연결리스트를 위한 노드 클래스
    def __init__(self, elem, link = None):      # 생성자, 디폴트 인수 사용
        self.data = data                        # 데이터 멤버 생성 및 초기화
        self.link = link                        # 링크 생성 및 초기화
```

C++나 Java 등과는 달리 생성자의 매개변수로 데이터 멤버와 같은 이름을 사용해도 문제가 없다. 왜냐하면 **클래스의 모든 멤버는 self를 통해 접근**해야 하기 때문이다. 예를 들어, 위의 코드에서 **link는 매개변수**이고, **self.link**는 **데이터 멤버**이다. 이들은 정확히 구별되기 때문에 파이썬에서는 멤버와 같은 이름의 매개변수를 많이 사용한다.

스택 클래스의 이름은 LinkedStack 이라 하자. **데이터 멤버**로는 **시작노드를 가리키는 변수 top**만 있으면 된다. 4장에서는 top을 배열(파이썬의 리스트)로 사용하였다. 맨 처음에는 top이 None으로 초기화되어야 하고, 따라서 연결된 스택의 공백상태는 top이 None을 가리키는 경우이다. 스택의 초기화는 스택을 공백상태로 만드는 것이므로 top이 None을 가리키도록 하면 된다. 클래스 정의와 이들 멤버 함수의 구현은 다음과 같다.

``` Python
class LinkedStack():
    def __init__(self):             # 생성자
        self.top = None             # top 생성 및 초기화
    
    def isEmpty(self):
        return self.top == None     # 공백상태 검사
    def clear(self):
        self.top = None             # 스택 초기화
```


#### push(E): 삽입 연산

배열 구조에서와는 달리 연결된 스택에서는 삽입할 데이터를 직접 스택에 넣을 수 없다. 먼저 데이터를 넣을 **새로운 노드를 만들고, 이 노드를 스택의 top에 추가**해야 한다. 전체 삽입 연산은 다음과 같이 3단계로 이루어진다.

1. 입력 데이터 E를 이용해 새로운 노드 $n$을 생성함 : $n = Node(E)$
2. $n$의 링크가 시작노드를 가리키도록 함 : n.link = top
3. top이 n을 가리키도록 함 : top = n

[그림 6.10] 연결된 스택에서의 삽입 과정



실제 구현 코드에서는 Node의 생성자를 이용하여 데이터와 링크를 동시에 (단계 1과 2를 한번에 처리) 초기화할 수 있다. 코드는 다음과 같다.

``` Python
    def push(self, item):           # 연결된 스택의 삽입연산
        n = Node(item, self.top)    # Step 1 + Step 2
        self.top = n                # Step 3
```


#### pop() : 삭제 연산

삭제는 상단 항목을 꺼내서 반환하는 연산이다. 연결된 구조에서는 **top이 가리키는 노드를 꺼내고 데이터 필드만을 반환**하면 된다. 이 과정은 다음과 같다.

1. 변수 n이 시작노드를 가리키도록 함 : n = top
2. top이 다음 노드를 가리키도록 함 : top = n.link
3. n이 가리키는 노드의 데이터를 반환함 : return n.data



[그림 6.11] 연결된 스택에서의 삭제 과정



코드는 다음과 같다. 공백상태를 반드시 검사해야 하는 것에 유의하라. 공백이 아니면 top이 가리키는 노드를 꺼내고 데이터 필드를 반환한다. 4장의 배열 구조로 구현한 스택에서와 같이 **노드가 아니라 스택 항목을 반환함**에 유의하라.

``` Python
    def pop(self):                  # 연결된 스택의 삭제연산
        if not self.isEmpty():      # 공백이 아니면
            n = self.top            # Step 1
            self.top = n.link       # Step 2
            return n.data           # Step 3
```

연결된 구조에서 삭제 연산으로 꺼낸 노드의 메모리를 프로그래머가 직접 해제할 필요가 없음에 유의하라. 예를 들어, 위의 그림에서 노드 A를 삭제하는 코드가 필요없다. 파이썬에서는 어떤 **객체를 참조하는 변수가 하나도 없으면 그 객체는 자동으로 삭제**된다. C나 C++에서 포인터와 관련하여 프로그래머를 괴롭히던 메모리 관리라는 큰 골칫거리 하나가 사라졌다.



#### peek()

peek는 시작노드의 데이터를 반환하면 된다. 물론 공백상태이면 안 된다.

``` Python
    def peek(self):                 # 연결된 스택의 peek 연산
        if not self.isEmpty():      # 공백이 아니면
            return self.top.data    # 시작 항목의 데이터 반환
```


#### size()

연결된 구조에서는 스택의 항목 수를 구하기가 어렵다. 왜냐하면 링크를 따라 맨 마지막 노드까지 움직여보기 전에는 몇 개의 노드들이 매달려 있는지 알 수 없기 때문이다. 마지막 노드는 링크가 None인 노드이다. 시작 노드에서부터 전체 노드를 순회하여 노드의 개수를 구하는 방법은 다음 그림과 같다. 배열 구조(파이썬 리스트)를 사용할 때에는 리스트의 크기를 반환하는 함수 len()을 호출하면 되었던 것을 기억하라. 연결된 구조에서는 이렇게 할 수 없다.


[그림 6.12] 연결된 구조에서의 순차적인 노드 방문 과정


``` Python
    def size(self):                 # 스택의 항목 수 계산
        node = self.top             # 시작 노드
        count = 0
        while not node == None:     # node가 None이 아닐 때까지
            node = node.link        # 다음 노드로 이동
            count += 1              # count 증가
        return count                # count 반환
```


스택 클래스에 노드의 개수를 저장하는 count와 같은 데이터 멤버를 추가하면 좋을 것처럼 보인다. 그러나 이 경우 삽입연산이나 삭제 연산에서 count를 정확히 관리해주어야 하는 문제가 있다. **변수를 많이 사용하면 편리**한 점이 있다. 그러나 반드시 모든 함수에서 이들을 **일관성 있게 관리해야 한다는 부담**이 따른다.



#### display()

size() 연산에서의 노드 방문 방법은 스택 내용을 모두 출력할 때에도 동일하게 적용된다. 모든 노드의 데이터를 출력하기 위해서는 모든 노드들을 방문해야 하기 때문이다. 다음은 연결된 구조에서 시작노드부터 순서대로 마지막 노드까지 방문하는 전형적인 코드이다.

``` Python
    def display(self, msg = 'LinkedStack :'):   # 스택의 항목 출력 함수
        print(msg, end = '')                    # 메시지를 먼저 출력
        node = self.top                         # 시작 노드
        while not node == None:                 # node가 None이 아닐 때까지
            print(node.data, end = ' ')         # node의 데이터 멤버 출력
            node = node.link                    # 다음 노드로 이동
        print()
```

연결된 스택의 테스트에는 4장에서 사용한 코드를 그대로 사용하자. 2개의 스택 객체를 만드는 코드는 다음과 같이 수정되어야 한다. 출력은 print() 함수가 아니라 display() 메소드를 이용한다.

``` Python
odd  = LinkedStack()    # 홀수 저장을 위한 연결된 스택
even = LinkedStack()    # 짝수 저장을 위한 연결된 스택
```

실행 결과는 4장과 동일한데, 스택의 출력은 가장 최근에 삽입된 항목부터이다. 즉, 4장에서 슬라이싱을 이용해 리스트를 역순으로 뒤집은 경우의 출력과 같다. 이것은 구현된 스택의 display() 연산이 가장 최근 노드부터 방문하기 때문이다.


#### 연결된 스택의 시간복잡도 분석

연결된 스택의 삽입과 삭제 연산의 시간복잡도도 $O(1)$이다. 그러나 배열 구조에서 파이썬의 리스트가 **용량을 증가**시켜야 하는 상황이 발생하면 $O(n)$의 시간이 걸릴 수 있는 점을 감안한다면 연결된 스택이 더 유리하다. size는 배열에서는 $O(1)$이지만 연결된 스택에서는 $O(n)$이다. 물론 크기를 위한 변수를 하나 추가하고, 삽입과 삭제 연산에서 이 변수를 잘 관리한다면 $O(1)$이 될 수 있다. 연습문제 6.2에 도전하라.




## 6.3 단순연결리스트 응용 : 연결된 리스트

(오늘은 여기까지!! 내일부터 다시 시작!!)










































