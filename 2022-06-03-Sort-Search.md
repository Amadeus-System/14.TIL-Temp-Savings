

# Chapter 7. 정렬과 탐색

## 7.1 정렬이란?

우리가 데이터를 저장하기 위해 복잡한 자료구조를 사용하는 이유는 무엇일까? 대부분의 경우는 효율적인 탐색과 정렬을 위해서이다. **탐색(Searching)**은 많은 자료 중에서 무언가를 찾는 작업이고, **정렬(Sorting)**은 데이터를 순서대로 재배열하는 것을 말한다. 이들은 컴퓨터에서 가장 중요한 응용으로 효율적인 탐색과 정렬을 위해서는 적절한 자료구조가 반드시 요구된다. 이 장에서는 간단한 정렬과 탐색 방법들을 알아보자. 복잡한 정렬 방법들은 12장에서 다룬다.




정렬을 위해서는 사물들을 서로 **비교**할 수 있어야 한다. **비교할 수 있는 모든 속성**들은 **정렬의 기준**이 될 수 있다. 예를 들어, 다음 그림은 말들을 키 순서대로 정렬한 것인데, 나이순으로 정렬한다면 다른 결과가 나올 것이다. 이때 순서에는 **오름차순(Ascending Order)**과 **내림차순(Descending Order)**이 있다.


정렬은 자료의 탐색에서도 매우 중요하다. 사전에서 우리가 단어를 쉽게 찾을 수 있는 것은 단어들이 **알파벳**순으로 정렬되어 있기 때문이다. 만약 사전이 정렬되어 있지 않다면 어떤 단어를 빨리 찾는 것은 거의 불가능할 것이다. 컴퓨터도 마찬가지이다. 정렬되어 있지 않은 자료에 대해서는 탐색의 효율이 크게 떨어진다.




정렬시켜야 할 대상을 보통 **레코드(Record)**라고 부른다. 또한 레코드는 여러개의 **필드(Field)**로 이루어진다. 예를 들어, 경주마의 경우 번호, 이름, 키, 나이, 품종, 연락처 등의 여러 속성들이 있는데, 이들이 필드가 된다. 또한, 이들 중에서 정렬의 기준이 되는 필드를 **키(Key)** 또는 **정렬 키(Sort Key)**라고 한다. 결국 **정렬이란 레코드들을 키(Key)의 순서로 재배열**하는 것이다.


[그림 7.1] 정렬의 대상인 레코드와 필드, 키의 개념


### 정렬 장소에 따른 분류

* **내부(Internal) 정렬** : 모든 데이터가 메인 메모리에 올라와 있는 정렬을 의미한다. 이 책에서는 내부 정렬만을 다룬다.
* **외부(External) 정렬** : 외부 기억장치에 대부분의 데이터가 있고, 일부만 메모리에 올려 정렬하는 방법으로 대용량 자료를 정렬하기 위해 사용한다.


### 구현복잡도와 알고리즘 효율성에 따른 분류

* 단순하지만 비효율적인 방법 : 삽입정렬, 선택정렬, 버블정렬 등
* 복잡하지만 효율적인 방법 : 퀵 정렬, 힙 정렬, 병합정렬, 기수 정렬 등


### 안정성에 따른 분류

**안정성(Stability)**이란 입력 데이터에 동일한 키 값을 갖는 레코드가 여러개 존재할 경우, 정렬 후에도 이들의 상대적인 위치가 바뀌지 않는 것을 말한다. 안정성을 충족하는 정렬에는 삽입정렬, 버블정렬, 병합정렬 등이 있다.

[그림 7.2] 안정성을 충족하지 않는 정렬의 예



## 7.2 간단한 정렬 알고리즘

### 선택 정렬(Selection Sort)

**선택 정렬**은 리스트에서 가장 작은 숫자를 선택해서 앞쪽으로 옮기는 방법을 사용한다. 전체 숫자들은 아직 정렬되지 않은 **오른쪽 리스트**와 정렬이 완료된 **왼쪽 리스트**로 나누어지는데, 맨 처음에는 모든 숫자가 오른쪽 리스트에 들어있다. 선택 정렬은 **오른쪽 리스트에서 가장 작은 숫자를 선택하여 왼쪽 리스트의 맨 뒤로 이동하는 작업**을 반복하는 것이다. 다음 표와 같이 이 과정은 오른쪽 리스트가 공백상태가 될 때까지 되풀이된다.




실제로 선택정렬을 구현하기 위해 2개의 배열을 사용할 필요는 없다. 정렬이 안 된 리스트에서 최소값이 선택되면 이 값을 배열의 첫번째 요소와 **교환**하면 되기 때문이다. 예를 들어, 다음 그림에서 최소값 1과 첫번째 요소 5를 교환하면 전체 배열은 정렬된 부분과 되지 않은 부분으로 나뉜다. 다음에는 2번째 요소부터 나머지들 중에서 가장 작은 값을 선택하고 선택된 값을 2번째 요소와 교환한다. 전체 요소의 개수가 $n$이면 이 절차를 $n-1$번 반복하면 전체 리스트가 정렬된다.



[그림 7.3] 선택 정렬의 과정


선택 정렬 알고리즘을 파이썬 함수로 구현한 코드는 다음과 같다. 최소 항목을 찾는 범위와 튜플을 이용해 배열의 두 항목을 서로 교환하는 코드에 유의하라.

``` Python
def selection_sort(A):                      # 선택 정렬
    n = len(A)                              # n : 리스트 A의 길이
    for i in range(n - 1):                  # 0, 1, 2, ..., n-2 [외부루프]
        least = i
        for j in range(i + 1, n):           # i+1, ..., n-1 [내부루프]
            if A[j] < A[least]:             # 비교연산
                least = j                   # 최소항목 갱신
        A[i], A[least] = A[least], A[i]     # 배열 항목 교환
        printStep(A, i + 1)                 # 중간과정 출력용 문장
```

정렬의 각 단계에서 현재 리스트의 정렬 상태를 출력해보기 위한 다음 함수는 다른 정렬 알고리즘에서도 사용할 것이다.

``` Python
def printStep(arr, val):                    # 중간과정 출력용 함수
    print('Step %2d =' % val, end = '')
    print(arr)
```


선택 정렬 알고리즘의 테스트 프로그램과 실행결과는 다음과 같다. 입력 리스트의 정렬 전과 후의 상태와 함께, 알고리즘의 각 단계별 리스트 상태를 출력하고 있다.

``` Python
data = [5, 3, 8, 4, 9, 1, 6, 2, 7]
print('Original :', data)
selection_sort(data)
print('Selection :', data)
```







선택 정렬은 입력 배열 이외의 추가적인 배열을 사용하지 않는다. 이러한 정렬 방법을 **제자리 정렬(In-place Sorting)**이라 한다.

선택정렬의 시간복잡도를 분석해보자. 정렬 함수에서 이중루프가 사용되는데, 외부루프는 $n-1$번 반복하고, 내부루프는 0에서 $n-2$까지 변하는 $i$에 대하여 $(n-1)-i$번 반복된다. 따라서 전체 비교횟수는 다음과 같다.

$$ (n-1) + (n-2) + ... + 1 = n (n-1) / 2 = O(n^2) $$

결국, 선택 정렬은 시간복잡도가 $O(n^2)$으로 효율적인 알고리즘도 아니고 안정성을 만족하지도 않는다. 그러나 알고리즘이 간단하고, 입력자료의 구성과 상관없이 **자료이동 횟수가 결정**된다는 장점을 갖는다.


### 삽입 정렬(Insertion Sort)

삽입 정렬은 카드를 정렬하는 방법과 유사하다. 손 안에 정렬된 카드가 있고, 카드를 추가로 1장씩 더 받을 때마다 그 카드를 순서대로 끼워넣는 것이다. 물론 삽입 후에도 전체 카드는 정렬이 되어 있어야 한다. 이 과정을 새로 받는 모든 카드에 대해 수행하면 전체 카드가 정렬된다.


[그림 7.4] 삽입 정렬의 원리


배열에서도 마찬가지이다. 정렬이 안 된 부분의 숫자를 하나씩 정렬된 부분의 적절한 위치를 찾아 끼워넣는 과정을 반복한다. 한 번의 삽입이 끝나면 정렬이 안 된 부분의 항목수가 하나 줄어드는데, 이 과정을 정렬되지 않은 항목이 하나도 없을 때까지 반복하면 정렬이 끝난다. 그런데, 숫자를 **끼워 넣는** 과정이 문제이다. 예를 들어, 그림에서 4를 3과 5 사이에 삽입하기 위해서는 4보다 큰 항목들(8, 5)을 모두 **한 칸씩 뒤쪽으로 이동**해야 한다. 특히 이 과정은 정렬된 부분의 **맨 뒤쪽 항목부터 처리**해야 되는 것에 유의하라. 다음은 [5, 3, 8, 4, 9, 1, 6, 2, 7]을 삽입 정렬하는 과정을 보여준다.




[그림 7.5] 삽입 정렬의 과정




삽입정렬 알고리즘과 실행결과는 다음과 같다.

``` Python
def insertion_sort(A):                  # 선택 정렬
    n = len(A)
    for i in range(1, n):               # 외부 루프 : 1, 2, ..., n-1
        key = A[i]
        j = i - 1
        while j >= 0 and A[j] > key:    # 내부 루프
            A[j + 1] = A[j]             # 항목들을 뒤로 1칸씩 이동
            j -= 1
        A[j + 1] = key                  # 항목 삽입
        printStep(A, i)
```



삽입 정렬의 **복잡도는 입력 자료의 구성에 따라서 달라진다**. 먼저 입력 자료가 이미 **정렬되어 있는 경우는 가장 빠르다**. 내부 루프가 모든 항목에서 1번만에 빠져나올 것이기 때문이다. 삽입 정렬의 외부 루프는 $n-1$번 실행되고 각 단계에서 1번의 비교와 2번의 이동만 이루어지므로 총 비교 횟수는 $n-1$번, 총 이동 횟수는 $2(n-1)$번이 되어 이 경우의 시간복잡도는 $O(n)$이다.

**최악의 경우는 입력 자료가 역으로 정렬된 경우이다**. 각 단계에서 앞에 놓인 자료들은 전부 1칸씩 뒤로 이동하여야 한다. 따라서 외부 루프 안의 각 반복마다 $i$번의 비교가 수행되므로 총 비교 횟수는 다음과 같다. 


$$ \sum_{i=0}^{n-1} i = 1 + 2 + ... + (n - 1) = \frac {n (n-1)}{2} = O(n^2) $$

삽입 정렬은 시간 복잡도가 $O(n^2)$인데, 특히 많은 **레코드들의 이동을 포함**하므로 레코드의 크기가 크고 양이 많은 경우 효율적이지 않다. 반면에 알고리즘이 간단하므로 레코드의 수가 적을 경우 효과적이다. 특히 **대부분의 레코드가 이미 정렬되어 있는 경우 효율적**으로 사용될 수 있다.


### 버블 정렬(Bubble Sort)

인접한 2개의 레코드를 비교하여 크기가 순서대로가 아니면 서로 교환하는 방법을 사용한다. 이러한 **비교-교환 과정**은 리스트의 왼쪽 끝에서 시작하여 오른쪽 끝까지 진행한다. 비교-교환 과정이 1번 완료되면 (1번의 스캔) 가장 큰 레코드가 리스트의 오른쪽 끝으로 이동된다. 이것은 마치 물속에서 거품(Bubble)이 보글보글 떠오르는 것과 유사하여 버블정렬이라 부른다. 비교-교환 과정은 더 이상 교환이 일어나지 않을 때까지 계속된다.

다음은 버블 정렬의 1번의 스캔 과정을 보여준다. 먼저 5와 3을 비교하면 5가 더 크므로 서로 교환하고, 다음으로 5와 8을 비교하면 8이 더 크므로 교환없이 다음 단계로 진행한다. 이러한 과정이 반복되면 배열에서 가장 큰 값인 9가 오른쪽 끝으로 이동하게 된다.



[그림 7.6] 버블 정렬의 과정



리스트를 1번 스캔하면 오른쪽 끝에 가장 큰 레코드가 위치하게 되고 전체 리스트는 오른쪽의 정렬된 부분과 정렬이 안 된 왼쪽 부분으로 나누어진다. 이러한 스캔 과정은 정렬되지 않은 부분에 대해 **더 이상 교환이 일어나지 않을 때까지** 수행된다. 그림에서는 6번의 스캔만에 교환이 발생하지 않는 상황이 되었고, 정렬이 완료되었다. 버블정렬 알고리즘은 다음과 같다.

``` Python
def bubble_sort(A):                                 # 버블 정렬
    n = len(A)
    for i in range(n-1, 0, -1):                     # 외부 루프 : n-1, n-2, ..., 2, 1
        bChanged = False
        for j in range(i):                          # 내부 루프 : 0, 1, ..., I-1
            if (A[j] > A[j + 1]):                   # 순서가 맞지 않으면
                A[j], A[j + 1] = A[j + 1], A[j]     # 교환! 코드에 유의할 것.
                bChanged = True                     # 교환이 발생했음
        
        if not bChanged:                            # 교환이 없으면
            break                                   # 종료
        printStep(A, n - i)                         # 중간과정 출력용 문장
```

실행 결과는 다음과 같다. 6번의 스캔만에 정렬이 완료되었다.

버블 정렬의 비교 횟수와 이동 횟수를 계산하여 보자. 버블 정렬의 비교 횟수는 최악의 경우 다음과 같다.

$$ \sum_{i=1}^{n-1} i = \frac {n (n-1)}{2} = O(n^2) $$

따라서 시간 복잡도는 $O(n^2)$이다. 어떤 경우가 최악일까? 최악의 경우는 입력 자료가 역순으로 정렬되어 있는 경우에 발생한다. 최선의 경우는 입력 자료가 이미 정렬이 되어 있는 경우로 1번의 스캔만에 알고리즘이 종료된다. 버블 정렬은 매우 단순하지만 효율적이지는 않다. 그러나 입력 데이터가 어느 정도 정렬되어 있는 경우에 효과적으로 사용될 수 있다.


### 7.3 정렬 응용 : 집합 다시보기

3장에서 리스트와 함께 집합을 공부했다. 집합은 원소의 중복을 허용하지 않으며 원소들 사이에 순서가 없다는 면에서 리스트와는 다르다. 3장에서 집합의 추상자료형을 정의하였고 파이썬의 리스트를 이용해 구현해보았다. 이제 집합을 다른 방법으로 구현해보자. 정렬의 개념을 사용하는 것이다.

이제 **집합의 원소들을 항상 정렬된 순으로 저장**하려고 한다. 이를 위한 코드는 기본적으로 3.6절에서 구현한 것과 동일하다. 변경되는 것은 멤버함수 몇 개다. 그렇다면 어떤 멤버함수가 변경되어야 할까? 당연히 삽입연산은 변경되어야 한다. 원소들이 정렬되어야 하므로 넣을 때마다 자기 자리를 먼저 찾아야하기 때문이다. 삭제연산은 동일하다. 중요한 것은 집합의 원소들이 정렬되어 있으면 **집합의 비교나 합집합, 차집합, 교집합 등을 훨씬 효율적으로 구현**할 수 있다는 것이다.


### 삽입 연산 : insert

집합에 원소를 삽입할 때 먼저 중복을 검사해야 한다. 중복되었으면 삽입하지 않아야하기 때문이다. 중복이 아니라면 삽입하는데, 이때는 반드시 삽입할 위치를 먼저 찾아야 한다. 리스트를 정렬된 상태로 유지해야 하기 때문이다. 이것은 삽입 정렬에서 하나의 항목을 정렬된 리스트에 끼워넣는 과정과 동일하다. 위치를 찾으면 리스트의 insert() 연산을 이용해 삽입하면 된다.

``` Python
def insert(self, elem):                     # 정렬된 상태를 유지하면서 elem을 삽입
    if elem in self.items:                  # 이미 있음
        return
    for idx in range(len(self.items)):      # loop : n번
        if elem < self.items[idx]:          # 삽입할 위치 idx를 찾음
            self.items.insert(idx, elem)    # 그 위치에 삽입
            return
    self.items.append(elem)                 # 맨 뒤에 삽입
```

리스트가 정렬되어 있든 그렇지 않든 삭제 연산은 바뀌는 것이 없다.


### 비교 연산 : ```__eq__```

두 집합이 같은 집합인지는 어떻게 비교할 수 있을까? 만약 정렬이 되어 있지 않은 상태에서 두 집합 A와 B가 같은 집합인지를 판단하려면 A의 모든 원소가 B에 있고, 반대로 B의 모든 원소가 A에 있는지를 검사해야 한다. 각 집합의 원소의 개수가 모두 $n$이라고 가정하면, 이 연산은 $n$의 제곱에 비례하는 비교가 필요하고 따라서 $O(n^2)$ 알고리즘이 된다. 

배열이 정렬되었다면 비교 연산은 다음과 같이 단순해진다.

* 두 집합의 원소의 개수가 같아야 같은 집합이 될 수 있다.
* 두 집합이 모두 정렬되어 있으므로 순서대로 같은 원소를 가져야 한다. 즉 가장 작은 원소부터 하나씩 끝까지 서로 비교하여 모두 같아야 같은 집합이다.

이를 구현한 코드는 다음과 같다.

``` Python
    def __eq__(self, setB):                         # 두 집합 self, setB가 같은 집합인가?
        if self.size() != setB.size():              # 원소의 개수가 같아야 함
            return False
        for idx in range(len(self.items)):          # loop : n번
            if self.items[idx] != setB.items[idx]:  # 원소별로 같은지 검사
                return False
        return True
```


```__eq___```는 파이썬에서 미리 정의된 특별한 메소드로 == 연산자에 대한 연산자 중복 함수이다. Set 클래스에서 이 메소드를 구현하면 두 Set 객체 A와 B를 A == B 와 같이 == 연산자를 이용해 비교할 수 있다. 산술 연산자(+, -, *, /)나 비교 연산자 등을 포함한 다양한 연산자 중복 메소드가 정의되어 있는데, 이들은 모두 __로 시작하여 __로 끝나는 이름을 갖는다. 2.11절을 복습하라.


이 알고리즘의 시간복잡도는? 한 집합의 원소의 개수만큼만 반복하면 같은 집합인지를 검사할 수 있다. 따라서 시간복잡도는 $O(n)$이다.


### 합집합 연산 : Union

합집합을 구하는 연산도 개선이 가능하다. 원소들이 크기순으로 정렬되어 있으면 1번의 스캔만으로 합집합을 구할 수 있다. 코드가 약간 복잡해 보이지만 핵심은 다음과 같다. 

* 두 집합의 원소들이 크기순으로 정렬되어 있으므로, 가장 작은 원소들부터 비교하여 더 작은 원소를 새로운 집합에 넣고 그 집합의 인덱스를 증가시킨다.
* 만약 두 집합의 현재 원소가 같으면 하나만을 새 집합에 넣으면 된다. 인덱스는 모두 증가시킨다.
* 한쪽 집합이 모두 처리되면 나머지 집합의 남은 모든 원소를 순서대로 새 집합에 넣는다.


``` Python
    def union(self, setB):                              # 집합 self와 집합 setB의 합집합
        newSet = Set()                                  # 반환할 합집합
        a = 0                                           # 집합 self의 원소에 대한 인덱스
        b = 0                                           # 집합 setB의 원소에 대한 인덱스
        while a < len(self.items) and b < len(setB.items):
            valueA = self.items[a]                      # 집합 self의 현재 원소
            valueB = self.items[b]                      # 집합 setB의 현재 원소
            if valueA < valueB:                         # self의 원소가 더 작으면
                newSet.items.append(valueA)             # 이 원소를 합집합에 추가
                a += 1                                  # self의 현재 원소 인덱스 증가
            elif valueA > valueB:                       # setB의 원소가 더 작으면
                newSet.items.append(valueB)             # 이 원소를 합집합에 추가
                b += 1                                  # setB의 현재 원소 인덱스 증가
            else:                                       # 중복되는 원소
                newSet.items.append(valueA)             # 하나만 추가
                a += 1                                  # self와 setB의 인덱스 모두 증가
                b += 1
        while a < len(self.items):                      # self에 남은 원소를 모두 추가
            newSet.items.append(self.items[a])
            a += 1
        while b < len(setB.items):                      # setB에 남은 원소를 모두 추가
            newSet.items.append(setB.items[b])
            b += 1
        return newSet                                   # 합집합 반환
```

이 연산의 시간복잡도는? 두 집합의 원소의 개수 합에 비례하는 비교가 필요하다. 만약 두 집합의 크기를 $n$이라고 한다면 이 연산의 시간복잡도는 $O(n)$이다. 이것은 3.6절에서 구현한 동일한 연산의 $O(n^2)$에 비해 엄청난 개선이다. 교집합이나 차집합도 같은 방법으로 구현할 수 있다. 실습문제 P7.3과 P7.4에 도전하라.

다음 표는 이들 연산에 대한 시간복잡도를 비교하고 있다. 결국, 정렬을 사용하면 삽입이 약간 번거롭기는 하지만 집합의 여러 연산들을 훨씬 효율적으로 처리할 수 있다.

[표 7.1] 정렬되지 않은 리스트와 정렬된 리스트로 구현한 집합에서의 복잡도 비교





## 7.4 탐색과 맵 구조

우리는 매일 인터넷에서 원하는 상품을 찾고, 특정한 단어나 문장이 들어있는 웹사이트를 검색한다. 이러한 모든 작업들이 모두 탐색이다. 효율적인 탐색을 위해서는 무엇이 필요할까? 미리 물건들을 일정한 규칙에 따라 잘 정리해 두어야 할 것이다. 자료를 효율적으로 탐색하기 위해 데이터를 잘 정리하는 방법을 살펴보자.





탐색은 **레코드(Record)**의 집합에서 원하는 레코드를 찾는 작업이다. 보통 이러한 레코드들의 집합을 **테이블(Table)**이라고 부른다. 레코드들은 서로를 구별하여 인식할 수 있는 키(Key)를 가지고 있는데, 이것을 **탐색키(Search Key)**라고 한다. 결국 탐색은 **테이블에서 원하는 탐색키를 가진 레코드를 찾는 작업**이다.

탐색에서는 테이블을 구성하는 방법에 따라 효율이 달라진다. **맵(Map)** 또는 **딕셔너리(Dictionary)**는 자료를 저장하고 탐색키를 이용해 원하는 자료를 빠르게 찾을 수 있도록 하는 **탐색을 위한 자료구조**를 말한다. 맵은 **엔트리(Entry)**라고 불리는 **키를 가진 레코드(Keyed Record)**의 집합이다. 엔트리는 2개의 필드를 가진다.

* **키(Key)** : 영어 단어나 사람의 이름과 같은 레코드를 구분할 수 있는 탐색키
* **값(Value)** : 영어 단어의 의미나 어떤 사람의 주소와 같은 탐색키와 관련된 값

결국 맵은 키-값의 쌍(key, value)으로 이루어진 엔트리의 집합이다. 파이썬은 내장 자료형으로 **딕셔너리**를 제공하는데, 이것은 **자료구조 맵을 구현한 하나의 예**이다. 다음은 딕셔너리의 사용 예시인데, 컬러 테이블에 몇 가지 색을 키(색상 이름)와 값(색상의 R, G, B 값)으로 저장하고 있다. 파이썬 딕셔너리는 2.6절을 복습하라.





이 장에서는 자료구조 맵이 어떻게 구성되어 있는지를 공부한다. 맵에는 어떤 연산이 있을까? 역시 가장 중요한 연산은 항목의 삽입과 삭제, 그리고 탐색 연산이다. 맵의 추상자료형을 정의해보자.

정의 7.1 Map ADT

* 데이터 : 키를 가진 레코드(엔트리)의 집합
* 연산
    - search(key) : 탐색키 key를 가진 레코드를 찾아 반환한다.
    - insert(entry) : 주어진 entry를 맵에 삽입한다.
    - delete(key) : 탐색키 key를 가진 레코드를 찾아 삭제한다.

맵에서는 유일한 탐색키를 사용하기도 하고, 동일한 탐색키를 허용하기도 한다. 예를 들어, 학생생활 기록부에서는 '학번'과 같은 유일한 탐색키를 반드시 사용해야 할 것이다. 그러나 영어사전에서는 철자가 동일한 여러 단어가 있으므로 탐색키의 중복을 허용해야 할 것이다. 맵을 효율적으로 구현하기 위해서는 이들 3가지 연산을 효율적으로 할 수 있는 자료구조를 사용해야 한다. 맵을 구현하는 여러가지 방법들을 살펴보자.

* 가장 간단한 방법은 엔트리들을 **리스트**에 저장하는 것이다. 이때, 엔트리들을 키 값에 따라 정렬하여 맵을 만들 수도 있고, 정렬하지 않고 맵을 만들수도 있다. 방법에 따라 연산들의 성능에 차이가 발생한다.
* 맵의 탐색 성능을 향상하고자 한다면 **이진탐색트리**를 사용할 수 있다. 이 방법은 9장에서 공부한다.
* 맵을 구현하는 가장 좋은 방법은 **해싱(Hashing)**이다. 이 장에서 공부한다.






## 7.5 간단한 탐색 알고리즘

### 순차 탐색(Sequential Search)

(오늘은 여기까지!! 내일부터 다시 시작!!)



























