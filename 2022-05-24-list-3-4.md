## 3.3 배열로 구현한 리스트

### 배열구조로 자료구조 리스트를 구현하자.

자료구조 리스트의 항목들을 저장하는 가장 간단한 방법은 배열구조를 이용하는 것이다. 물론 배열구조로는 파이썬의 리스트를 이용한다. 이 리스트의 이름을 items라고 하고 다음과 같이 전역변수로 정의한다. 맨 처음에는 items가 공백이 되어야 한다.

``` Python
items = []      # 리스트 항목 저장을 위한 파이썬 리스트
```

리스트 ADT의 연산들을 하나씩 구현해보자. 사실 필요한 연산이 대부분 파이썬 리스트에 있기 때문에 할 일이 별로 없다. 파이썬의 리스트가 "자료구조 리스트를 구현한 하나의 예"라는 것을 기억하라. 이미 파이썬의 리스트에 많은 기능들이 구현되어 있다. 따라서 리스트 ADT에서 정의한 연산들을 위해 파이썬 리스트 클래스의 멤버함수들을 적절히 호출해주기만 하면 된다.


# Insert(pos, elem) : 삽입 연산

삽입연산은 파이썬 리스트의 insert()를 사용하면 간단히 처리된다. append가 항상 맨 뒤에 삽입하는 것과 달리 이 함수는 위치를 지정해 삽입할 수 있다.

``` Python
def insert(pos, elem):          # pos 위치에 새로운 요소 elem을 삽입한다.
    items.insert(pos, elem)     # 파이썬 리스트 클래스의 insert 연산
```


### delete(pos) : 삭제 연산

삭제 연산도 파이썬 리스트의 pop 연산을 이용하면 간단하다. pop은 삭제할 위치를 지정하여 그 항목을 삭제한다.

``` Python
def delete(pos):            # pos 위치에 있는 요소를 꺼내고 반환한다.
    return items.pop(pos)   # 파이썬 리스트 클래스의 pop 연산
```


### getEntry(pos) : 항목 접근 연산

리스트의 pos번째 항목에 접근하는 것은 리스트에 인덱스 연산자를 적용해 간단히 처리할 수 있다. 즉, items[pos]는 리스트 items의 pos번째 항목을 반환한다. 이 연산은 다음과 같이 **한 줄로 간결하게 표현**해도 어려워보이지 않는다.

``` Python
def getEntry(pos):
    return items[pos]   # pos번째 항목 반환
```


### isEmpty() : 공백상태 검사와 기타 함수들

리스트가 공백상태인지를 검사하기 위해서는 항목의 개수를 알아야 한다. 이때 항목 수를 반환하는 파이썬 내장함수 len()을 사용하면 된다. 공백상태는 다음과 같이 구현된다.

``` Python
def isEmpty():
    if len(items) == 0:     # 크기가 0이면
        return True         # True를 반환
    else:                   # 크기가 0이 아니면
        return False        # False를 반환
```

공백상태는 리스트의 크기가 0인 경우이다. 이러한 문장들은 더 간결하게 나타낼 수 있다. 즉, len(items) == 0 문장 자체가 맞으면 True 아니면 False이므로 if문을 사용하지 않고 다음 코드와 같이 return으로 바로 반환하면 된다.

``` Python
def isEmpty():
    return len(items) == 0  # 크기가 0이면 True 아니면 False
```

이 코드는 여러 줄로 구현한 것과 정확히 동일하며 코드가 간결해진다. 동일한 기능이라면 코드가 길어서 좋은 점은 거의 없다.


### 기타 함수들

리스트의 크기는 isEmpty와 같이 len() 함수를 사용하면 된다. 리스트 초기화는 items = []로 처리되었다. 이 코드는 사실 문제가 있다. 어떤 문제일까? 쉽지는 않겠지만 한번 생각해보자.

``` Python
def size():             
    return len(items)   # 리스트의 크기 반환. len() 함수 이용

def clear():
    items = []          # items를 초기화 --> 오류
```

리스트 ADT의 나머지 연산들도 파이썬 리스트의 멤버함수로 쉽게 구현된다. 다음 코드에서 리스트의 멤버함수가 어떻게 사용되는지 살펴보자.

``` Python
def find(item):
    return items.index(item)    # 탐색 후 인덱스 반환

def replace(pos, elem):
    items[pos] = elem           # pos번째 항목 변경

def sort():
    items.sort()                # 정렬(sort 메소드 이용)

def merge(lst):
    items.extend(lst)           # 병합(확장)
```


### display() : 화면출력 함수

리스트는 어떻게 화면으로 출력할 수 있을까? print() 함수를 사용하면 된다. (2.4절 참조) 특히 이 함수에 리스트와 같은 내장 자료형의 객체를 인수로 전달해도 알아서 잘 출력해준다. 코드는 다음과 같다.

``` Python
def display(msg = 'ArrayList'):     # 출력 : 디폴트 인수 사용
    print(msg, size(), items)       # 메시지 + 크기 + 배열내용 출력
```

화면출력을 위한 display 함수에서는 **디폴트 인수(Default Argument)**를 사용하였다. 이 함수로 출력하고자 하는 리스트의 형태는 다음과 같다.

``` Python
메시지 항목수 [항목0, 항목1, ..., 항목n-1]
```

``` Python
디폴트 인수는 함수의 매개변수에 기본 값을 부여하는 기능으로, 함수 호출시 인수가 주어지면 그 인수를 사용하고, 만약 인수가 생략되면 기본 값을 사용하는 방법이다. (2.7절 참조) C++, Java 등 다른 언어에서도 많이 사용되지만 파이썬에서도 매우 유용하게 사용되므로 잘 이해하고 활용하는 것이 좋다.
```


### 테스트 프로그램

지금까지 구현한 리스트를 사용해보자. 테스트 코드는 다음과 같다. 파이썬에서는 코드의 들여쓰기가 매우 중요하고, 따라서 가급적 한 줄에 한 문장을 기술하는데, 다음 코드는 2~3번째 줄에서 한 줄에 여러 문장(비슷한)을 넣기 위해 세미콜론(;)을 사용하였다. (특별한 의미는 없고, 라인 수를 줄이기 위해 사용됨)

``` Python
display('파이썬 리스트로 구현한 리스트 테스트')
insert(0, 10); insert(0, 20); insert(1, 30)
insert(size(), 40); insert(2, 50)   # 한 줄에 여러 문장을 넣기 위해 ; 사용
display('파이썬 리스트로 구현한 List(삽입 x 5):')
sort()
display('파이썬 리스트로 구현한 List(정렬 후):')
replace(2, 90)
display('파이썬 리스트로 구현한 List(교체 x 1):')
delete(2); delete(size() - 1); delete(0)
display('파이썬 리스트로 구현한 List(삭제 x 3):')
lst = [1, 2, 3]
merge(lst)
display('파이썬 리스트로 구현한 List(병합 + 3):')
clear()
display('파이썬 리스트로 구현한 List(정리 후):')
```

리스트에 5개의 항목을 위치를 지정해 삽입하고, 리스트를 출력한다. 다음으로 리스트를 정렬한 후 출력, 항목 변경 후 출력, 삭제 연산과 병합 연산 등을 수행한 후 결과를 출력하였다. 결과는 다음과 같다.


대부분의 결과가 예상대로일 것이다. 그런데 한 가지 문제가 있다. clear()가 제대로 동작하지 않았다. 왜 그럴까? **items를 함수 내의 지역변수로 인식**하기 때문이다. 즉, 전역변수로 items가 있더라도 함수 내에서 이것이 전역변수임을 선언하지 않으면 **items = [] 문장은 새로운 지역변수 items를 만들게 되는 것**이다. (2.8절 변수의 범위 참조) 따라서 items를 전역변수라고 지정해주는 문장이 다음과 같이 필요하다.

``` Python
def clear():
    global items    # items가 전역변수임을 지정
    items = []      # 이제 전역변수 items를 초기화
```

다른 함수들은 모두 새로운 변수 items를 **만드는 것이 아니라** 어딘가에 있는 items를 **"사용"하는 코드**이기 때문에 전역변수로 지정하지 않아도 문제없다.

지금까지 자료구조 리스트를 배열(파이썬의 리스트)을 이용해 구현하였다. 너무 많은 것을 파이썬의 리스트 클래스가 처리해서 사실 우리가 한 일은 별로 없지만 어쨌든 우리만의 리스트가 구현되었고, 이제 이를 이용해 문제를 해결할 수 있다.


### 시간복잡도 분석

연산들의 시간복잡도는 사용한 파이썬 함수들의 시간복잡도에 따라 결정된다. 주요 함수의 복잡도를 따져보자.

* **삽입(insert)과 삭제(delete)** 연산에서 파이썬 리스트의 insert와 pop 메소드를 사용하였다. 따라서 최선의 경우는 pos가 리스트의 맨 뒤쪽인 경우로 시간복잡도가 $O(1)$이다. 그러나 그렇지 않은 대부분의 경우는 그림 3.5나 3.6과 같이 배열의 특성에 따라 많은 항목의 이동이 필요하다. 따라서 최악이나 평균적인 **시간복잡도는 $O(n)$**이다.








### 클래스로 구현하는 것이 더 좋은 방법이다.

그런데 아직 하나의 문제가 있다. 여러개의 리스트를 사용하려면 어떻게 할까? 예를 들어, 다항식을 리스트로 표현하고, 두 다항식을 더한 결과를 구하려면 최소한 3개의 리스트가 필요하다. 그러나 앞에서 구현한 방법에서는 전역변수로 하나의 배열 items를 사용하고 함수를 만들었기 때문에 하나의 리스트만을 이용할 수 있다. 방법이 없을까? 물론 모든 **함수의 매개변수에 배열을 추가**하는 것도 방법이다. (1.2절의 Bag을 함수로 구현한 코드 참조) 예를 들어, 공백상태 검사 함수를 isEmpty()가 아니라 isEmpty(A)로 하고 배열(파이썬의 리스트) A를 전달하면 된다. 이 방법을 사용하면 대부분의 함수에 매개변수가 하나 늘어난다.

**자료구조를 구현하는 가장 좋은 방법은 클래스**이다. 예를 들어, 리스트의 ADT를 클래스로 구현하면 파이썬의 리스트와 같이 리스트 객체를 마음대로 만들어 사용할 수 있다. 2.10절을 참고하여 이제 리스트를 클래스로 만들기 위해 필요한 작업을 구체적으로 살펴보자.

* 필요한 **클래스를 선언**한다.
* 전역변수로 선언되었던 **데이터를 멤버변수**로 클래스에 **넣는다**. 그 방법은 **생성자(Constructor)**로 불리는 `__init__()` 함수에서 그 변수를 선언하는 것이다.
* 일반함수로 구현된 자료구조의 **연산**을 클래스의 **멤버함수(또는 메소드)**로 바꾸어 클래스에 넣는다. 이때 클래스의 멤버함수임을 나타내기 위해 첫번째 매개변수로 self가 추가되어야 한다.
* 클래스의 멤버함수에서 객체 자신의 데이터를 사용하거나 멤버 함수를 호출하기 위해 self.을 앞에 넣어준다. 예를 들어, 멤버함수에서 x = 10은 새로운 변수 x를 만드는 것이고, self.x = 10은 클래스의 데이터 x에 값을 할당하는 것이다. 멤버함수도 마찬가지이다. 클래스 안에서 isEmpty()는 일반함수이고 self.isEmpty()는 그 클래스의 멤버함수를 말한다.

``` Python
사실 이름이 self가 아니고 다른 이름을 사용해도 문제는 없다. 그렇지만 통상적으로 self를 사용한다. 이것은 C++에서의 this와 비슷한 의미이다. this는 C++에서는 키워드이지만 self는 그냥 멤버함수에서 객체 자신을 나타내는 변수로 생각하면 된다.
```

조금 복잡해보인다. 클래스를 만드는 것도 익숙하지 않고, 사용하는 방법도 약간 어색할 것이다. 다음 코드를 통해 함수로 구현한 코드와 비교해보자. 클래스의 이름은 배열을 이용한 리스트의 의미로 ArrayList로 한다. 먼저, 클래스 선언과 생성자 함수는 다음과 같다.

``` Python
class ArrayList():          # 클래스 선언

    def __init__(self):     # 생성자 (2.10절 참조)
        self.items = []     # 클래스 변수 선언 및 초기화
    
    def insert(self, pos, elem):
        self.items.insert(pos, elem)
    
    def delete(self, pos):
        return self.items.pop(pos)
    
    def isEmpty(self):
        return self.size() == 0

    def getEntry(self, pos):
        return self.items[pos]
    
    def size(self):
        return len(self.items)
    
    def clear(self):
        self.items = []     # items는 멤버변수(global 아님)
    
    def find(self, item):
        return self.items.index(item)

    def replace(self, pos, elem):
        self.items[pos] = elem



```

이어서 앞에서 구현한 함수들을 넣으면 된다. 이때 **들여쓰기**를 반드시 고려해야 하는데, 이들은 모두 클래스 정의 블록에 포함되는 멤버함수이기 때문이다. 함수의 **첫번째 매개변수로 self가 추가**되어야 하는 것과 클래스 멤버를 **사용할 때 self.을 앞에 넣어야 한다**는 것만 명심하면 된다. 메소드의 구현내용은 앞에서 구현한 내용과 정확히 동일하다.

items는 더 이상 전역변수가 아니며 클래스의 멤버변수이므로 clear() 메소드에서 global을 이용해 전역변수로 처리할 필요가 없는 것에 유의하자. 클래스를 사용하는 것도 어렵지 않다. 리스트 객체를 먼저 만들고 그 객체를 통해 함수를 호출하면 된다.

* 먼저 리스트 객체를 만들어야 한다. s = ArrayList()와 같이 사용하는데, 이제 여러개의 리스트를 만들어 사용해도 전혀 문제가 없다.
* 리스트의 메소드나 멤버변수를 사용하려면 반드시 스택 객체를 통해야 한다. 예를 들어, 리스트 s의 2번 위치에 50을 삽입하려면 s.insert(2, 50)와 같이 작성해야 한다.

클래스 버전의 테스트 코드는 다음과 같다.

``` Python
s = ArrayList()
s.display('파이썬 리스트로 구현한 리스트 테스트')
s.insert(0, 10);        s.insert(0, 20);     s.insert(1, 30)
s.insert(s.size(), 40); s.insert(2, 50)
s.display('파이썬 리스트로 구현한 List(삽입 x 5):')
s.sort()
s.display('파이썬 리스트로 구현한 List(정렬 후):')
s.replace(2, 90)
s.display('파이썬 리스트로 구현한 List(교체 x 1):')
s.delete(2);    s.delete(s.size() - 1);    s.delete(0)
s.display('파이썬 리스트로 구현한 List(삭제 x 3):')
lst = [1, 2, 3]
s.merge(lst)
s.display('파이썬 리스트로 구현한 List(병합 + 3):')
s.clear()
s.display('파이썬 리스트로 구현한 List(정리 후):')
```

실행결과는 동일하다. 그렇지만 클래스로 만들면 이제 리스트 객체를 마음대로 만들어 사용할 수 있다. 시간복잡도는 함수로 구현한 경우와 동일하다.

> 파이썬에서는 모든 것이 객체이다. 심지어 정수(int)나 실수(float), 부울(bool)조차도 클래스로 구현되어 있다. 결국 클래스와 객체의 개념 및 메소드 호출 등에 익숙해야 파이썬의 강력한 내장 자료형과 다양한 기능들을 효율적으로 사용할 수 있다. 그래도 클래스는 어렵게 느껴질 수 있으므로 이 책에서는 가능한 한 함수로 설명하려고 했으며, 꼭 필요한 경우에 클래스를 이용해 구현하였다.

ArrayList의 대부분의 연산들은 파이썬 리스트의 멤버함수로 구현했지만 이들을 사용하지 않고 직접 구현할수도 있다. 예를 들어, 리스트의 후단에 삽입과 삭제를 하는 append()와 pop(-1) 만을 이용하여 insert()와 delete() 연산을 구현할 수 있다. 실습문제 P3.1에 도전해보자.


## 3.4 리스트의 응용 : 라인 편집기 

우리가 만든 ArrayList 클래스를 이용하여 아주 간단한 텍스트 편집기를 만들어보자. 이것은 **라인 편집기(Line Editor)**라고 불리는데 라인 단위로 입력이나 삭제를 할 수 있는 문서 편집기이다. 이 편집기는 고정된 수의 명령어들을 받아서 동작하며 커서를 사용하지 않는다. 따라서 현재 우리가 사용하고 있는 편집기와는 많은 차이가 있지만 편집기의 기본적인 아이디어를 공부할 수 있다.

라인 편집기는 리스트로 구현할 수 있는데, 리스트의 하나의 항목이 한 줄의 문자열을 나타낸다. 다음과 같은 기능을 갖도록 설계하자.

[그림 3.7] 리스트를 이용한 문서의 내부적인 표현


* 명령 i : 라인 삽입. 행 번호와 문자열을 입력하면 그 행에 한 라인 추가
* 명령 d : 한 라인 삭제. 행 번호를 입력하면 그 행을 삭제
* 명령 r : 한 라인 변경. 행 번호와 문자열을 입력하면 그 행의 내용을 변경
* 명령 p : 현재 내용 출력. 현재 문서의 모든 내용을 라인 번호와 함께 출력
* 명령 l : 파일 입력. 지정된 (test.txt) 파일로부터 라인을 읽어들임.
* 명령 s : 파일 출력. 지정된 (test.txt) 파일로 편집내용을 저장

물론 파일 이름을 지정하지 않고 임의의 파일을 사용하도록 하는 것이 더 일반적일 것이다. 구현한 함수와 테스트 코드는 다음과 같다.

``` Python
def myLineEditor():                             # 라인 편집기 주 함수
    list = ArrayList()                          # 리스트 객체 생성

    while True:
        command = input('[메뉴선택] i-입력, d-삭제, r-변경, p-출력, l-파일읽기, s-저장, q-종료 ==> ')
        
        if command == 'i':                      # 삽입 연산
            pos = int(input(' 입력행 번호:'))    # 삽입할 행 번호 입력
            str = input(' 입력행 내용:')         # 삽입할 행 내용 입력
            list.insert(pos, str)               # insert 메소드로 삽입
        elif command == 'd':                    # 행 삭제
            pos = int(input(' 삭제행 번호:'))    # 삭제할 행 번호 입력
            list.delete(pos)                    # delete 메소드로 삭제
        elif command == 'r':                    # 행 내용 변경
            pos = int(input(' 변경행 번호:'))    # 변경할 행 번호 입력
            str = input(' 변경행 내용:')         # 변경할 행 내용 입력
            list.replace(pos, str)              # replace로 변경
        elif command == 'q':                    # 프로그램 종료
            return
        elif command == 'p':                    # 문서 출력
            print('Line Editor')
            for line in range(list.size()):         # 모든 라인에 대해
                print('[%2d] ' % line, end = '')    # 라인 번호와
                print(list.getEntry(line))          # 행 내용 출력
            print()                                 # 한 줄 띄움
        elif command == 'l':                        # 파일 입력
            filename = 'test.txt'
            infile = open(filename, 'r')            # 파일 열기(읽기 모드)
            lines = infile.readlines()              # 파일의 모든 내용을 읽음
            for line in lines:                      # 읽혀진 각 행에 대해
                list.insert(list.size(), line.rstrip('\n'))
            infile.close()                          # 파일 닫기
        elif command == 's':                        # 파일 저장
            filename = 'test.txt'
            outfile = open(filename, 'w')           # 파일 열기(쓰기 모드)
            for i in range(list.size()):
                outfile.write(list.getEntry(i) + '\n')
            outfile.close()
myLineEditor()      # 라인 편집기 주 함수 호출
```

* 키보드 입력함수 input()을 이용해 사용자 입력을 받는다. input()은 하나의 문자열을 전달하여 사용자에게 어떤 정보를 기다린다는 것을 표시한다.
* 자료형 변환 함수 int()를 사용하였다. input()은 결과를 문자열로 반환하는데, 문자열을 정수(행 번호)로 변경하기 위해 이 함수를 사용한다. 예를 들어 int('12')는 정수 12를 반환한다. 파이썬의 다양한 자료형 변환 함수를 검색해보자.
* 대부분의 명령은 ArrayList의 메소드를 호출했지만 화면출력 명령 p에서는 새로운 코드를 사용하였다. 요구하는 출력형식이 우리가 만든 리스트 클래스의 display와 다르기 때문이다. 리스트의 한 항목을 한 줄로 화면에 출력한다.
* **컴퓨터에서 파일을 사용**하기 위해서는 먼저 열어야 하는데, 이를 위해 open() 함수를 사용하였다. 파일은 읽기 위해, 또는 쓰기 위해 열 수 있는데, 이를 위해 open() 함수의 매개변수로 읽기('r') 또는 쓰기('w') 모드를 지정해야 한다. 성공적으로 파일이 열리면 **open()**은 파일 객체를 반환한다. 파일 객체는 사용이 끝나면 반드시 닫아야 하는데, 이를 위해 **close()** 메소드를 사용한다.
* 파일 객체에서 **readlines()** 메소드를 이용해 파일 내의 모든 문자열을 한꺼번에 읽을 수 있다. 이를 lines에 저장하였는데, lines는 각 라인별로 나누어진 문자열의 리스트이다. 각 문자열의 마지막에 '\n'이 있는 경우 이를 제거하기 위해 문자열 클래스의 **rstrip()** 함수를 사용하였다.
* 파일 저장 명령도 쓰기 명령과 대부분 유사한데, 파일 객체의 **write()** 함수를 이용해 각 항목(각 라인 문자열)을 순서대로 파일에 저장하였다. 다양한 파일 입출력은 인터넷 참고자료를 활용하자.

다음은 구현된 라인 편집기의 사용 예시이다. 원하는 줄에 문장을 삽입하고, 내용을 출력하며, 원하는 행을 삭제하였다.










다음은 ArrayList 클래스의 코드 일부가 저장된 Test.txt를 읽고 5번 줄을 self에서 this로 변경하는 예를 보여준다.









다양한 파일 입출력에 대해서는 관련 도서와 인터넷을 참고하자.
