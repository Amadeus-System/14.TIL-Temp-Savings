

* **Date : 2022-07-04**
* **Last Modified At : 2022-07-04**


# Chapter 11. 가중치 그래프

## 11.1 가중치 그래프란?

간선에 비용이나 가중치가 할당된 그래프를 **가중치 그래프(Weighted Graph)**라고 한다. 가중치 그래프는 정점 사이의 연결정보뿐만 아니라 연결에 필요한 비용을 함께 표현할 수 있다. 예를 들어, 다음은 주요 도시들 사이를 연결하는 고속도로 연결 현황을 보여주는 그래프로, 간선에 도시간의 거리를 표시한 가중치 그래프이다.






가중치 그래프는 수학적으로 $G = (V, E, w)$와 같이 표현된다. $V(G)$는 그래프 $G$의 정점들의 집합을, $E(G)$는 그래프 $G$의 간선들의 집합을 의미하고, $w(e)$는 간선 $e$의 **강도(Weight)**로 **비용(Cost)** 또는 **길이(Length)**라고도 부른다. 어떤 가중치 그래프의 경로를 $p = (v_0, v_1, ..., v_k)$라고 한다면, **경로의 길이**(또는 강도) $w(p)$는 다음과 같이 경로상의 모든 간선의 길이 합으로 표현된다.

$$ w(p) = \sum_{i=1}^{k} w(v_{i-1}, v_i) $$

가중치 그래프의 응용분야는 다양하다. 예를 들어, 인터넷망에 연결된 두 컴퓨터 사이에 데이터를 빠르게 전송해야 하는 상황을 생각해보자. 전체 네트워크에서 어떤 부분은 광통신으로 구축되어 전송속도가 매우 빠르고, 어떤 부분은 전화망을 이용해 속도가 느릴 수 있다. 이 경우 인터넷망을 표현하는 그래프의 모든 간선에 동일한 가중치를 부여하는 것은 적절하지 않을 것이다. 간선마다 연결속도가 다르므로, 속도에 따라 서로 다른 가중치가 부여되는 가중치 그래프로 표현하는 것이 더 적절할 것이다. 가중치 그래프를 표현하는 방법과 응용들을 살펴보자.



## 11.2 가중치 그래프의 표현

### 인접행렬을 이용한 표현

가중치 그래프도 인접행렬과 인접리스트를 이용해 표현할 수 있다. 먼저 인접행렬을 살펴보자. 인접행렬에 가중치를 저장하는 것은 매우 간단하다. 행렬의 각 요소에 0이나 1이 아니라 **가중치 값**을 저장하면 되기 때문이다. 만약 간선이 없으면 어떻게 표현할까? 하나의 방법은 가중치를 무한대($\infty$)로 표시하는 것이다. 예를 들어, 다음 그래프에서 정점 A와 C 사이에 간선이 없다면 A에서 C로 움직이는 비용이 무한대라고 생각할 수 있다. 다음은 가중치 그래프와 이를 인접행렬을 이용해 표현한 예를 보여준다.

[그림 11.1] 인접행렬을 이용한 가중치 그래프의 표현 예시


이러한 인접행렬은 파이썬에서 다음과 같이 **리스트를 요소로 갖는 리스트**로 나타내면 된다. 간선이 없는 요소를 다른 방법으로 나타낼 수도 있다. 간선이 없는 경우 무한대가 아니라 그 행렬요소에 None을 저장하는 것이다. 즉, None이 아닌 값을 가지면 (객체를 참조하면) 간선이 존재하는 것이고, None이면 간선이 없는 것으로 생각할 수 있다. 다음은 앞의 그래프를 이 방법으로 표현한 코드이다.

``` Python
vertex = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
weight = [[None, 29, None, None, None, 10, None],
          [29, None, 16, None, None, None, 15],
          [None, 16, None, 12, None, None, None],
          [None, None, 12, None, 22, None, 18],
          [None, None, None, 22, None, 27, 25],
          [10, None, None, None, 27, None, None],
          [None, 15, None, 18, 25, None, None]]
graph = (vertex, weight)    # 전체 그래프 : 튜플 사용
```

마지막 코드와 같이 정점리스트와 인접행렬을 튜플로 묶어 전체 그래프를 하나의 객체로 관리할 수도 있다. 이 경우 graph[0]은 vertex가 될 것이고, graph[1]은 weight가 된다.

인접행렬 표현에서 **대각선 성분**에 유의하라. 대각선 성분은 어떤 정점에서 자신으로 돌아오는 **자체간선**에 해당하는 요소이다. 만약 자체 간선을 허용하는 그래프라면 자체간선의 가중치를 저장하면 간단히 해결된다. 그러나 그렇지 않은 경우는 어떻게 해야 할까? 간선이 없는 것을 생각하고 `None`을 저장할 수도 있고, 가중치가 0인 간선이 항상 있는 것으로 생각하고 대각선 요소를 모두 0으로 나타낼 수도 있다.


#### 예) 인접행렬에서의 가중치의 합 계산

인접행렬로 표현한 그래프에서 **전체 가중치의 합을 구하는 연산**을 구현해보자. 행렬의 모든 요소를 검사해 간선이 있으면 가중치를 모두 더해 반환하는 함수는 다음과 같다.

``` Python
def weightSum(vlist, W):                    # 매개변수 : 정점 리스트, 인접행렬
    sum = 0                                 # 가중치의 합
    for i in range(len(vlist)):             # 모든 정점에 대해 (i = 0, ..., N-1)
        for j in range(i + 1, len(vlist)):  # 하나의 행에 대해 (삼각영역)
            if W[i][j] != None:             # 만약 간선이 있으면
                sum += W[i][j]              # sum에 추가
    return sum                              # 전체 가중치 합을 반환
```

코드에서 무방향 그래프이므로 인접행렬의 대칭되는 한쪽 삼각영역만을 더하기 위한 반복문에 유의하라. 테스트 코드와 실행결과는 다음과 같다. 행렬의 전체 요소를 더하면 가중치 합의 2배가 출력될 것이다.

``` Python
print('AM : weight sum = {}'.format(weightSum(vertex, weight)))
```

(결과 그림 삽입)



#### 예) 인접행렬에서의 모든 간선 출력

그래프에서 가중치를 가진 모든 간선을 출력해보자. 간선은 양쪽 정점 이름과 가중치를 함께 출력하도록 한다. 전체 코드와 실행결과는 다음과 같다.

``` Python
def printAllEdges(vlist, W):
    for i in range(len(vlist)):
        for j in range(i + 1, len(W[i])):
            if W[i][j] != None and W[i][j] != 0:
                print('({}, {}, {})'.format(vlist[i], vlist[j], W[i][j], end = ' '))
    print()
```

이 코드에서도 간선의 중복 출력을 막기 위한 반복문의 범위에 유의하라. 테스트 코드와 실행결과는 다음과 같다. 9개의 간선이 정상적으로 출력되었다.

``` Python
printAllEdges(vertex, weight)
```

(결과 그림 삽입)



### 인접리스트를 이용한 표현

가중치 그래프를 인접리스트로 표현하는 것은 약간 더 복잡하다. 각 정점의 인접 리스트에 정점만이 아니라 가중치를 추가로 저장해야하기 때문이다. 정점과 가중치는 **(정점, 가중치)의 튜플 형태**로 표현하는 것이 좋다. 파이썬의 다양한 내장 자료형을 다음과 같이 복합적으로 사용하여 인접리스트를 표현해보자.

* 딕셔너리 엔트리의 키(Key)는 정점 데이터, 값(Value)은 간선의 집합이 된다.
* 간선의 집합은 (인접정점, 가중치)의 튜플을 원소로 갖는다.

인접리스트를 이용한 가중치 그래프의 표현 예는 다음과 같다.

``` Python
# 딕셔너리와 집합, 튜플, 리스트를 모두 이용한 그래프 표현
graphA = {'A' : {('B', 29, 'F', 10)},
          'B' : {('A', 29), ('C', 16), ('G', 15)},
          'C' : {('B', 16), ('D', 12)},
          'D' : {('C', 12), ('E', 22), ('G', 18)},
          'E' : {('D', 22), ('F', 27), ('G', 25)},
          'F' : {('A', 10), ('E', 27)},
          'G' : {('B', 15), ('D', 18), ('E', 25)}}
```



#### 예) 인접리스트에서의 가중치의 합 계산과 간선 출력

이 그래프에서 전체 가중치의 합을 구하는 연산은 다음과 같이 구현할 수 있다. 코드에서 가중치를 가진 간선 $e$는 항목이 2개인 튜플인데, e[0]은 인접정점을, e[1]은 가중치를 나타내므로 e[1]을 모두 더해야 한다. 인접리스트로 표현된 무방향 그래프에서도 간선들이 중복되어 나타나므로, 전체 결과를 2로 나누어야 실제 가중치 합이 된다.

``` Python
def weightSum(graph):           # 가중치의 총합을 구하는 함수
    sum = 0
    for v in graph:             # 그래프의 모든 정점 v에 대해 : 'A', 'B', ...
        for e in graph[v]:      # v의 모든 간선 e에 대해 : ('B', 29), ...
            sum += e[1]         # sum에 추가
    return sum // 2             # 하나의 간선이 2번 더해지므로 2로 나눔.
```

전체 간선을 화면에 출력하는 연산은 다음과 같다.

``` Python
def printAllEdges(graph):           # 모든 간선을 출력하는 함수
    for v in graph:                 # 그래프의 모든 정점 v에 대해 : 'A', 'B', ...
        for e in graph[v]:          # v의 모든 간선 e에 대해 : ('B', 29), ...
            print('({}, {}, {})'.format(v, e[0], e[1]), end = ' ')
```

테스트 코드와 실행결과는 다음과 같다. 전체 간선이 중복되어 출력되었음에 유의하라. 간선이 중복되지 않게 출력하려면 어떻게 해야 할까? 실습문제 P11.1에 도전하라.

``` Python
print('AL : weight sum = {}'.format(weightSum(graphAL)))
printAllEdges(graphAL)
```



## 11.3 최소비용 신장 트리

(오늘은 여기까지!! 내일부터 다시 시작!!)













































