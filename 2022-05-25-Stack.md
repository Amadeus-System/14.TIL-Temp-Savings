* Date : 2022-05-25
* Last Devised : 2022-05-26

# Chapter 4. Stack

## 4.1 스택이란?

### 스택은 후입선출(Last-In First Out : LIFO)의 자료구조이다.

스택은 주방의 접시더미를 생각하면 쉽게 이해할 수 있다. 접시를 닦는 사람은 닦은 접시를 항상 접시더미의 맨 위에 올려놓는다. 요리사는 요리를 담을 새 접시가 필요하면 항상 맨 위에 있는 접시를 꺼내 음식을 담아 손님들에게 제공한다. 물론 더미의 중간에 있는 접시를 빼서 사용할 수도 있지만 이것은 매우 조심스럽고 번거로운 작업이 될 것이다.





**스택(Stack)**은 이와 같이 자료의 입출력이 **후입선출(LIFO : Last-In First-Out)**의 형태로 일어나는 자료구조를 말한다. 예를 들어, 스택에 A, B, C, D를 순서대로 입력했다면 꺼낼 때는 D, C, B, A로만 꺼낼 수 있다. 이것은 리스트에서 항목 접근을 위한 다른 통로들은 모두 막고 **후단**만을 열어둔 구조와 같다. 열린 곳을 보통 **스택 상단(Top)**이라 부른다. 그림과 같이 삽입과 삭제는 상단으로만 할 수 있고, 스택의 중간에는 항목을 삽입하거나 삭제할 수 없다. 따라서 연산도 매우 간단해진다.

[그림 4.1] 스택의 구조와 일련의 연산들



### 스택의 추상자료형

스택에는 어떤 것들을 저장할 수 있을까? 숫자나 문자열은 물론이고 복잡한 클래스의 객체나 심지어 여러개의 항목을 가진 리스트 등 어떤 자료든지 저장할 수 있다. 그러면 스택은 어떤 기능을 가져야 할까? 접시를 보관하는 접시함을 이용해 스택으로 무엇을 할 수 있는지 생각해보자. 다음은 접시함의 기본기능이다.

* 보관함이 비어있는지 살핀다(**isEmpty**) --> 스택이 비어있는지 살핀다.
* 접시를 보관함에 넣는다(**push**) --> 새로운 항목을 스택에 삽입한다.
* 접시 하나를 꺼낸다(**pop**) --> 스택에서 하나의 항목을 꺼내온다.

만약 접시함이 최신 고급모델이라면 다양한 고급기능들도 제공할 것이다.

* 보관함의 현재 접시 개수를 알려준다(**size**)
* 접시를 꺼내지 않고 맨 위의 접시가 무엇인지 알려준다(**peek**)
* 보관함을 깨끗이 비운다(**clear**)

고급기능들은 스택의 필수기능이라고 보기는 어려운데, 기본 연산들을 조합해서 구현할 수 있기 때문이다. clear 기능은 모든 접시를 꺼내면(pop) 되고, peek 기능은 pop으로 접시 하나를 꺼내서 확인한 후 다시 스택에 push하면 된다.

입출력에 제한을 가함에 따라 리스트에 비해 연산들이 매우 간단해지는 것에 유의하라. 이제, 스택을 추상자료형으로 정의하자. 앞에서 생각한 연산들에 이름을 붙이고 동작을 조금 더 구체적으로 설명하면 된다.


정의 4.1 Stack ADT

* 데이터 : 후입선출(LIFO)의 접근방법을 유지하는 항목들의 모음
* 연산
    - Stack() : 비어있는 새로운 스택을 만든다.
    - isEmpty() : 스택이 비어있으면 True를 아니면 False를 반환한다.
    - push(e) : 항목 e를 스택의 맨 위에 추가한다.
    - pop() : 스택의 맨 위에 있는 항목을 꺼내 반환한다.
    - peek() : 스택의 맨 위에 있는 항목을 삭제하지 않고 반환한다.
    - size() : 스택 내의 모든 항목들의 개수를 반환한다.
    - clear() : 스택을 공백상태로 만든다.


### 스택은 어디에 사용할까?

스택은 특히 자료의 출력순서가 입력의 역순으로 이루어져야 할 경우에 매우 긴요하게 사용된다.

* 문서나 그림, 수식 등의 편집기에서 **되돌리기(Undo)** 기능을 구현할 때 스택이 사용된다. 되돌리기는 지금까지 실행된 명령어 중에서 가장 최근 것부터 순서대로 취소해야 하기 때문이다. 웹 브라우저의 "**이전 페이지로 이동**" 기능도 마찬가지이다. 가장 최근에 본 페이지로 이동해야 한다. 지금까지 본 페이지 정보를 스택에 저장해야 한다.




* **함수 호출에서 복귀주소**를 기억하는데 스택을 사용한다. C언어로 구현된 다음 코드를 보자. main()에서 함수 a()를 호출하고 a()에서 다시 b()와 c()를 연속적으로 호출하였다. c()가 종료되면 이를 호출한 함수인 b()로 돌아가야 한다. 이러한 복잡한 함수의 호출과 반환을 위해 운영체제는 시스템 스택을 사용한다. **시스템 스택**에는 현재 실행되고 있는 함수가 종료되면 돌아갈 문장의 주소(Program Counter)와 함수 호출시 매개변수나 함수 안에서 선언된 지역변수와 같은 정보들이 저장되어 다시 되돌아갔을 때 이전 상태를 유지할 수 있도록 한다.




* 문서나 소스코드에서 **괄호 닫기**가 정상적으로 되었는지를 검사하는 프로그램에서도 스택을 사용한다. 또한 **계산기 프로그램**에서 입력된 수식을 계산하는 과정에도 스택이 사용된다. 미로에서 출구를 찾기 위해서도 스택을 사용할 수 있다. 이들은 응용 예제를 통해 더 자세히 공부한다.



이 외에도 스택을 사용하는 응용은 매우 다양하므로 잘 이해해야 한다.

스택을 구현하는 방법을 살펴보자. 3장의 리스트에서와 같이 기본적으로 **배열구조와 연결된 구조**로 구현할 수 있다. 물론 각 방법은 장단점을 갖는다. 이 장에서는 파이썬의 리스트를 이용한 배열구조로 구현하는 방법을 공부하고, 연결된 구조는 6장에서 공부한다.





## 4.2 스택의 구현

### 배열구조를 이용한 스택의 함수 구현

스택 항목들을 저장하는 가장 간단한 방법은 배열구조를 사용하는 것이다. 물론 파이썬에서는 리스트를 사용한다. 이 리스트(배열)의 이름을 top이라 하자. 맨 처음에 이 리스트는 공백이 되어야 한다.

``` Python
top = []    # 스택의 데이터 : 항목을 위한 공백 리스트
```

``` Python
C언어에서 배열을 이용해 스택을 구현하는 경우 보통 top을 가장 최근에 들어온 항목의 인덱스(정수)를 저장하는 변수로 사용한다. 파이썬의 리스트는 항목들의 개수를 len() 함수를 이용해 알 수 있기 때문에 이러한 변수를 추가로 사용할 필요가 없다. 리스트만 하나 있으면 되고, 이를 top이라고 하자.
```

데이터가 결정되면 이제 연산들을 구현한다. 일단 가장 간단하게 연산들을 모두 함수로 구현한다.


### isEmpty() : 공백상태 검사

스택이 공백상태이면 top은 빈 리스트이다. 따라서 리스트에서와 같이 len() 함수를 이용해 항목의 수를 먼저 구하고, 이 값이 0인지를 검사하면 된다. 이 함수는 True나 False를 반환한다.

``` Python
def isEmpty():
    return len(top) == 0    # len(top) == 0의 계산결과가 True/False
```


### push(item) : 삽입 연산

스택에서 삽입 연산은 **스택 상단에 항목을 추가**하는 것이다. 그렇다면 리스트 top의 어느 곳이 스택의 상단일까? 물론 내 마음대로 사용하면 된다. 그러나 **리스트의 맨 뒤를 스택의 상단으로 사용하는 것이 좋다**. 리스트의 후단을 스택 상단이라고 생각하면 삽입 연산은 리스트의 맨 뒤에 항목 item을 추가하는 작업이 되고, 리스트의 append() 연산을 사용하여 다음과 같이 간단히 구현할 수 있다.

``` Python
def push(item):
    top.append(item)    # 리스트의 맨 뒤에 item을 추가함.
```

**대부분의 경우** append()는 상수 시간에 항목을 추가할 수 있다. 따라서 이 연산의 시간복잡도는 $O(1)$이다. 만약 리스트의 맨 앞을 스택 상단으로 사용하면 어떻게 될까? 리스트의 insert() 메소드를 사용하면 되고, 삽입연산 코드를 top.insert(0, item)로 바꾸기만 하면 된다. 그런데 효율성에서 문제가 발생한다. 리스트의 0번 위치에 항목을 넣기 위해서는 리스트의 모든 항목들을 한 칸씩 뒤로 밀어야 하기 때문이다. 이 경우 삽입연산의 시간복잡도가 $O(n)$이 된다.


[그림 4.2] 스택 상단(top)으로 파이썬 리스트의 후단과 전단을 사용하는 경우의 삽입연산 비교. 후단을 사용하는 것이 훨씬 효율적임.


이 문제는 삭제연산에서도 동일하게 발생한다. 따라서 반드시 리스트의 맨 뒤를 스택의 상단으로 사용해야 효율적인 알고리즘이 가능하다.

``` Python
"대부분의 경우"의 의미가 잘 이해되지 않는다면 3.2절의 내용을 복습하라. 리스트가 동적배열 구조로 구현되었기 때문에 "항상"이 아니라 "대부분의 경우"란 표현을 사용하였다.
```


### pop() : 삭제연산

삭제 연산은 스택 상단에서 항목을 하나 꺼내고 이를 반환하는 것이다. 우리는 리스트의 후단을 스택의 상단으로 사용하기 때문에, 리스트의 맨 뒤의 항목을 꺼내 반환하면 된다. 파이썬의 리스트는 항목을 꺼낼 수 있는 pop(pos) 연산을 제공하는데, 매개변수로 꺼낼 항목의 위치를 전달해야 한다. 리스트 top의 마지막 항목의 위치는 len(top) - 1이 될 것이다. 물론 파이썬은 음수 인덱스를 지원하므로 -1을 사용하는 것도 좋은 방법이다. 따라서 top.pop(-1)은 top의 맨 마지막 항목을 리스트에서 꺼낸다.

만약 스택이 공백이면 항목을 꺼낼 수 있을까? 물론 불가능하다. 따라서 스택이 공백이 아닌 경우에만 pop 연산을 처리해야 한다. 코드는 다음과 같다.

``` Python
def pop():
    if not isEmpty():       # 공백상태가 아니면
        return top.pop(-1)  # 리스트의 맨 뒤에서 항목을 하나 꺼내고 반환
```

삭제 연산은 **항상** $O(1)$에 처리된다. 물론 이것은 리스트의 맨 뒤를 스택 상단으로 사용했을 경우이다. 코드에서 스택이 공백인 경우를 처리하지 않았음에 유의하라. 공백상태이면 에러 메시지를 출력하거나, 프로그램을 종료하거나, 특별한 오류 코드를 반환하는 등 다양하게 처리할 수 있는데, 이들은 모두 응용에 따라 다르다. 따라서 이 책에서는 **오류 상태에 대한 처리코드는 생략**하였다.


### 기타 연산들

나머지 연산들도 다음과 같이 간단히 구현된다. peek는 리스트의 마지막 항목을 반환하면 된다. 스택 내용에는 변화가 없다. 물론 이 경우에도 스택이 공백상태가 아니어야 한다.

``` Python
def peek():                 # 맨 위의 항목을 삭제하지 않고 반환
    if not isEmpty():       # 공백상태가 아니면
        return top[-1]      # 맨 뒷 항목을 반환(삭제하지 않음)
```

size와 clear 연산은 리스트에서와 동일하다.

``` Python
def size():
    return len(top)     # 스택의 크기

def clear():
    global top          # top은 전역함수임을 지정함
    top = []            # 스택의 초기화
```

구현한 모든 연산의 시간복잡도는 $O(1)$이다. 만약 리스트의 맨 앞을 상단으로 사용하면 삽입과 삭제연산이 $O(n)$, 즉 현재 스택에 저장된 항목의 수에 비례하는 시간이 걸리는 비효율적인 스택이 된다.


### 스택의 활용

이제 스택을 사용해보자. 먼저 1부터 5까지 5개의 숫자를 push하고, 스택을 출력한다. 다음으로 두 번의 pop 연산을 하고 스택을 출력한다.

``` Python
for i in range(1, 6):        # i = 1, 2, 3, 4, 5
    push(i)                  # push 연산 5회
print(' push 5회:', top)     # 스택 내용 출력
print(' pop() -->', pop())   # pop 연산 및 반환 항목 출력
print(' pop() -->', pop())   # pop 연산 및 반환 항목 출력
print(' pop 2회:', top)      # 스택 내용 출력 (str(top)도 동일함)
```

스택의 출력을 위해 print() 함수를 사용하였는데, 이 함수에 파이썬 리스트 top을 인수로 전달하면 리스트의 내용을 자동으로 문자열로 바꾸어 화면으로 출력한다. 그렇다면 항목의 출력 순서는 어떻게 될까? 우리는 리스트의 맨 뒤를 상단으로 사용했던 것을 기억하라. 가장 먼저 들어온 항목이 다음과 같이 화면으로는 가장 먼저 출력된다.






지금까지 스택에 정수를 삽입했고, 현재 3개의 정수가 스택에 남아있다. 이 상태에서 스택에 문자열을 넣으면 어떻게 동작이 될까? 파이썬에서는 리스트에 객체가 직접 저장되는 것이 아니라 객체를 가리키는 변수가 저장된다. 따라서 변수가 가리키는 객체가 어떤 것이든 문제없다. 정수가 3개 들어있는 현재 스택에 문자열을 2개 삽입하고, 한번 삭제하는 코드는 다음과 같다.

``` Python
push('홍길동')
push('이순신')
print(' push + 2회:', top)      # 스택 내용 출력
print(' pop() -->', pop())      # pop 연산 및 반환 항목 출력
print(' pop 1회: ', top)       # 스택 내용 출력
```

이 코드에서는 하나의 리스트가 여러 자료형의 객체들을 참조하였다. 그러나 이 책에서는 하나의 자료구조에는 동일한 자료형의 객체들만을 참조할 것이다.


### 배열구조를 이용한 스택의 클래스 구현

만약 하나의 프로그램에서 여러개의 스택이 필요하면 앞에서 구현한 방법은 문제가 있다. 왜냐하면 항목을 저장하는 리스트가 하나뿐이기 때문이다. 여러개의 스택을 사용하려면 역시 클래스로 구현하는 것이 가장 좋다. 3장의 리스트와 집합 클래스를 복습하라.

이제 스택을 클래스로 구현해보자. 이미 모든 기능을 구현했으므로 클래스로 바꾸는 것은 어렵지 않다. 클래스 이름은 Stack으로 하고, 다음을 주의하면 된다.

* 생성자에 클래스의 데이터 멤버를 선언하고 초기화한다. 스택의 유일한 데이터인 top을 리스트로 선언하면 된다.
* 모든 메소드의 첫번째 파라미터로 self를 추가한다.
* 모든 메소드에서 클래스의 멤버를 사용할 때 self.을 추가하여 클래스 내의 변수(데이터 멤버) 및 함수(메소드)임을 표시한다.

구현한 스택 클래스는 다음과 같다. 클래스임을 표시하기 위해 코드의 바탕색을 바꾼 것에 유의하라.

``` Python
class Stack():

    def __init__(self):                 # 생성자
        self.top = []                   # top이 이제 클래스의 멤버 변수가 됨

    def isEmpty(self):
        return len(self.top) == 0

    def size(self):
        return len(self.top)

    def clear(self):
        self.top = []                   # 주의 : 이제 전역변수 선언이 필요없다.

    def push(self, item):
        self.top.append(item)

    def pop(self):
        if not self.isEmpty():
            return self.top.pop(-1)
    
    def peek(self):
        if not self.isEmpty():
            return self.top[-1]
```

스택은 3장의 ArrayList나 Set 클래스에 비해 훨씬 간단하다. 연산이 단순하기 때문이다. 이제 구현한 클래스를 사용해보자.

* 먼저 s = Stack()와 같은 코드로 스택 객체를 만든다. 여러개의 스택을 만들어 사용해도 문제없다.
* 스택의 메소드나 멤버 변수는 스택 객체를 통해서 호출된다. 예를 들어 스택 s에 item을 삽입하려면 s.push(item)와 같이 작성한다.
* 2개의 스택 even과 odd를 만들고, 0~9의 숫자 중에서 짝수는 even에 홀수는 odd에 저장해보자. 다음 코드의 결과를 미리 예상해보라.

``` Python
odd = Stack()                           # 홀수 저장을 위한 스택
even = Stack()                          # 짝수 저장을 위한 스택
for i in range(10):                     # i = 0, 1, 2, ..., 9
    if i % 2 == 0:                      
        even.push(i)                    # 짝수는 even에 push
    else:
        odd.push(i)                     # 홀수는 odd에 push

print(' 스택 even push 5회:', even)     # even 스택 출력
print(' 스택 odd  push 5회:', odd)      # odd  스택 출력
print(' 스택 even peek:', even.peek())  # even 스택 peek()
print(' 스택 odd  peak:', odd.peek())   # odd  스택 peek()

for _ in range(2):
    even.pop()                          # even 스택에서 2번 pop()
for _ in range(3):          
    odd.pop()                           # odd  스택에서 3번 pop()

print(' 스택 even pop 2회:', even)      # even 스택 출력
print(' 스택 odd  pop 3회:', odd)       # odd  스택 출력
```





그런데 스택의 출력 결과가 이상하다. **스택 내용**이 출력되는 것이 아니라 **스택 객체**의 정보가 출력된다. 어떻게 해야 스택 내용이 출력될까? 하나의 방법은 print() 함수에 even을 넣는 것이 아니라 even.top을 넣는 것이다. **even은 스택 객체이지만 even.top은 리스트 객체**이다! 코드를 다음과 같이 수정한다.

``` Python
print(' 스택 even push 5회:', even.top)     # even 스택 출력
print(' 스택 odd  push 5회:', odd.top)      # odd  스택 출력
```

이제 결과는 다음과 같이 원하는대로 나온다.





더 좋은 방법이 있다. print() 함수에 우리가 만든 클래스의 객체를 넣더라도 알아서 문자열로 바꾸어 출력할 수 있도록 하는 방법이다. 즉, 코드를 위와 같이 수정하지 않더라도 제대로 출력되도록 하는 것이다. 어떻게 할 수 있을까?

**연산자 중복**(2.11장 참조)을 사용하는 것이다. 스택의 생성자 `__init__()`과 비슷하게 특수한 메소드 `__str__()`를 Stack 클래스에서 구현해주는 것이다. 클래스에 이 메소드가 있으면 이 클래스의 객체를 문자열로 바꾸어야 하는 경우 자동으로 이 함수를 통해 변환해준다. 즉, 문자열로의 형 변환 연산자를 중복하는 것이다. 코드는 다음과 같다.

``` Python
def __str__(self):
    return str(self.top)    # Stack 객체를 문자열로 변환
```

이 함수에서 출력 순서도 바꿀 수 있다. 가장 나중에 들어온 항목이 가장 먼저 출력되도록 해보자. 리스트 항목을 뒤집을 때에는 슬라이싱 기능을 사용할 수 있다. 즉, 전체를 역순([::-1])으로 변환하는 것이다. 예를 들어, [1, 2, 3][::-1]은 [3, 2, 1]이다. 이를 이용해 코드를 다음과 같이 수정하면 스택 내용이 역순으로 출력된다.

``` Python
def __str__(self):
    return str(self.top[::-1])  # 역순으로 출력. 최근의 항목을 먼저.
```





``` Python
파이썬의 **슬라이싱 기능**은 매우 강력하고 편리한 기능이기 때문에 많이 사용된다. 인터넷에서 자료와 예제들을 찾아보라.
```


### 4.3 스택의 응용 : 괄호 검사

수식 표기나 프로그래밍 언어, HTML 문서 등 다양한 분야에서 괄호와 같은 **구분 문자(Delimiter)**들을 사용한다. 이들은 주로 간단한 데이터나 문자열들을 묶어 하나의 그룹으로 만들 때 그룹의 시작과 끝을 나타낸다. 예를 들어, C언어의 소스코드에는 대괄호 [], 중괄호 {}, 소괄호 ()와 같은 다양한 기호들이 사용되는데, 다음 코드는 배열에서 최대값을 찾아 반환하는 C언어 함수이다.



``` C
int find_array_max(int score[], int n)
{
    int i, tmp = score[0];
    for (i=1; i<n; i++){
        if (score[i] > tmp){
            tmp = score[i];
        }
    }
    return tmp;
}
```

프로그램이 정상적으로 빌드되고 실행되려면 이들 괄호들이 같은 유형들끼리 쌍을 이루어 잘 사용되어야 하는데, 반드시 다음 조건을 맞추어 구성되어야 한다.

* **조건 1** : 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
* **조건 2** : 같은 타입의 괄호에서 왼쪽 괄호가 오른쪽 괄호보다 먼저 나와야 한다.
* **조건 3** : 서로 다른 타입의 괄호 쌍이 서로를 교차하면 안 된다.





괄호가 일치하지 않으면 잘못된 코드이기 때문에 C언어의 컴파일러는 이것을 먼저 검사해야 한다. 이와 같이 괄호 사용의 오류를 검사하기 위해 스택이 사용된다.




### 괄호 검사 알고리즘

위의 코드들을 자세히 살펴보면 **가장 가까운 거리에 있는 괄호들끼리 서로 쌍**을 이루어야 됨을 알 수 있다. 따라서 입력 문자열에서 왼쪽 괄호가 나오면 스택에 삽입하고, 오른쪽 괄호가 나오면 스택에서 가장 최근에 삽입된 괄호를 꺼내 짝을 맞추어보면 오류를 검사할 수 있다.

* 문자를 저장하는 스택을 준비한다. 처음에는 공백상태가 되어야 한다.
* 입력 문자열의 문자를 하나씩 읽어 왼쪽 괄호를 만나면 스택에 삽입한다.
* 오른쪽 괄호를 만나면 pop() 연산으로 가장 최근에 삽입된 괄호를 꺼낸다. 이때 스택이 비었으면 조건 2에 위배된다.
* 꺼낸 괄호가 오른쪽 괄호와 짝이 맞지 않으면 조건 3에 위배된다.
* 끝까지 처리했는데 스택에 괄호가 남아있으면 조건 1에 위배된다.


하나의 조건이라도 위배하면 오류이므로 False를 반환하고 그렇지 않으면 성공이므로 True를 반환한다. 다음 그림은 몇 가지 경우에 대한 처리과정을 보여준다.


[그림 4.3] 스택을 이용한 괄호 검사의 몇 가지 예시




### 괄호 검사 구현

괄호 검사를 구현해보자. 함수 이름은 checkBrackets()이라 하고, 검사할 문자열을 매개변수로 전달한다. 함수에서는 하나의 스택 객체를 만들어 검사에 사용한다. 알고리즘을 구현한 코드는 다음과 같다.

``` Python
def checkBracket(statement):
    stack = Stack()
    for ch in statement:                # 문자열의 각 문자에 대해
        if ch in ('{', '[', '('):       # in '{[('도 동일하게 동작함
            stack.push(ch)
        elif ch in ('}', ']', ')'):     # in '}])'도 동일하게 동작함
            if stack.isEmpty():
                return False            # 조건 2 위반
            else:
                left = stack.pop()
                if (ch == '}' and left != '{') or \
                   (ch == ']' and left != '[') or \
                   (ch == ')' and left != '('):
                   return False         # 조건 3 위반

    return stack.isEmpty()              # False이면 조건 1 위반
```

이 함수의 테스트 프로그램은 다음과 같다. 3개의 테스트 문자열을 사용하는데, 이들을 이번에는 리스트가 아니라 튜플(())로 만들어 함수에 전달했다. 물론 리스트([])를 사용해도 결과는 동일하지만 테스트 문자열을 변경하지 않을 것이므로 메모리 측면에서 더 효율적인 튜플을 사용하였다.

``` Python
str = ()
for s in str:
    m = checkBrackets(s)
    print(s, '--->', m)
```

``` Python
파이썬에서 튜플은 리스트와 비슷하게 사용되지만 항목의 개수를 변경할 수 없기 때문에 동적배열로 구현된 리스트보다 메모리 측면에서 훨씬 효율적이다.
```


### 소스파일에서 괄호 검사

만약 여러 줄의 코드가 들어간 파일을 검사하려면 어떻게 할까? 먼저 파일을 읽어들여야 할 것이다. 이를 위해 파일을 열고, 한꺼번에 파일의 모든 줄을 읽어 문자열 리스트에 저장하고, 검사하는 코드는 다음과 같다. 파일 입출력과 관련해서는 3.4절의 라인 편집기 코드를 복습하라.

``` Python
filename = 'ArrayStack.h'           # 괄호를 검사할 소스파일
infile = open(filename, 'r')        # 파일 열기
lines = infile.readlines()          # 파일 전체를 라인별로 읽은 리스트
infile.close()                      # 파일 닫기

result = checkBracketsV2(lines)     # 검사 함수 호출 (약간 수정 필요)
print(filename, '--->', result)     # 결과 출력
```

이 코드에서 ArrayStack.h는 괄호가 잘 짝지어진 소스코드라고 생각하자. 검사 함수 checkBracketV2()는 이제 입력이 문자열이 아니라 문자열의 리스트이므로 약간 수정해야 한다. 즉, 리스트의 모든 항목(문자열)에 대해 그 다음 문장들을 다음과 같이 실행하면 된다.

``` Python
def checkBracketV2(lines):
    stack = Stack()
    for line in lines:      # 리스트의 모든 문자열에 대해
        for ch in line:     # 문자열의 각 문자에 대해
            ...
```


## 4.4 스택의 응용 : 수식의 계산


### 계산기 프로그램은 어떻게 만들까?

수식을 적은 문자열을 입력으로 받아 이를 계산하고 결과를 출력하는 프로그램을 구현해보자. 즉, 계산기를 만드는 것이다. 간단할 것 같지만 생각외로 복잡하다. 숫자와 함께 다양한 연산자도 나타나고, 괄호도 처리해야 하며, 특히 연산자들의 우선순위도 고려해야 정확한 결과가 나오기 때문이다. 기본적으로 수식은 연산자와 피연산자를 이용해 표현하는데, 이들의 상대적인 위치에 따라 다음과 같은 3가지 표기법으로 구분된다.




당연히 우리는 중위표기법에 익숙하지만 컴퓨터는 후위표기법을 좋아한다. 왜 그럴까? 후위표기는 컴퓨터 입장에서 여러가지 장점이 있다. 중위표기 수식 (A + B) * C를 생각해보자. 괄호는 더하기 연산이 곱하기 연산보다 먼저 수행되어야 함을 나타낸다. 이에 대한 후위표기식 A B + C *은 다음과 같은 장점을 가진다.

* **괄호를 사용하지 않아도 계산 순서**를 알 수 있다.
* 연산자의 **우선순위를 생각할 필요가 없다**. 식 자체에 우선순위가 이미 포함되어 있기 때문이다.
* 수식을 **읽으면서 바로 계산**할 수 있다. 중위표현식은 괄호와 연산자의 우선순위 때문에 수식을 끝까지 읽은 다음에야 계산이 가능하다.




컴퓨터는 이러한 장점 때문에 후위표기 계산방법을 사용한다. 물론 사용자는 편리한 중위표기를 고집할 것이다. 따라서 편리하고 정확한 계산기가 되기 위해서는 사용자는 익숙한 중위표기(괄호 포함)로 수식을 입력할 수 있어야 하고, 컴퓨터가 이를 후위표기로 변환한 다음 그 식을 계산해야 한다. 즉, 계산기 프로그램을 위해서는 **중위표기의 후위표기 변환과, 후위표기 수식의 계산과정**이 필요하다. 그리고 놀랍게도 이들은 모두 스택을 이용한다! 후위표기 수식의 계산이 조금 더 간단하므로 먼저 살펴보고, 괄호를 포함한 중위표기 수식을 후위표기로 변환하는 방법을 공부하자.


### 스택을 이용한 후위표기 수식의 계산

```8 2 / 3 - 3 2 * +```를 계산해보자. 후위표기이므로 **괄호는 수식에 포함되어 있지 않다**. 계산의 순서를 괄호를 이용해 나타내면 다음과 같은 순서가 될 것임을 쉽게 예상할 수 있을 것이다.

* **1단계** : (8 2 /) 3 - 3 2 * +        --> 4 3 - 3 2 * +
* **2단계** : ( (8 2 /) 3 - ) 3 2 * +    --> 1 3 2 * +
* **3단계** : ((8 2 /) 3 -) (3 2 *) +    --> 1 6 +
* **4단계** : (((8 2 /) 3 -) (3 2 *) +)  --> 7

이 식의 계산에 스택이 사용된다. 알고리즘을 정리해보자. 수식을 왼쪽에서 오른쪽으로 스캔하다가 **피연산자가 나오면 무조건 스택에 저장**한다. **연산자가 나오면 스택에서 피연산자 2개를 꺼내 연산을 실행**하고 **그 결과를 다시 스택에 저장**한다. 이 과정은 수식이 모두 처리될 때까지 반복되고, 마지막으로 스택에는 최종 계산결과만 하나 남는다.

다음은 ```8 2 / 3 - 3 2 * +```를 계산하는 과정을 보여준다. 수식은 왼쪽부터 오른쪽으로 스캔하고 다음과 같이 처리된다.



[그림 4.4] 스택을 이용한 후위표기 수식계산 예시



계산이 끝나면 스택에는 최종 계산결과가 남아있다. 즉, 스택에는 하나의 항목만이 남아야 하고, 그 값을 꺼내 반환하면 된다.


### 후위표기 수식 계산 구현

알고리즘을 이제 프로그램으로 구현해보자. 사용되는 연산자는 사칙연산 +, -, *, /로 제한한다. 후위표기이므로 물론 괄호는 없다. 입력수식은 리스트에 저장되어 있고, 연산자나 피연산자는 모두 리스트에 문자열로 저장된다고 가정하자. 즉, 후위표기식 ```8 2 / 3 - 3 2 * +```는 리스트에 다음과 같이 저장될 것이다.

``` Python
expr1 = ['8', '2', '/', '3', '-', '3', '2', '*', '+']
```

구현은 간단하다. 스택을 하나 만들고, 각 리스트 항목들에 대해 그 항목이 피연산자이면 스택에 저장하면 된다. 이때 저장되는 피연산자의 자료형은 **실수형(Floating-point)**이 좋을 것이다. 실수를 계산할수도 있고, 정수를 계산하더라도 1/2와 같이 나눗셈을 하면 실수가 되기 때문이다.

만약 항목이 연산자이면 스택에서 2개의 항목(실수)을 꺼내 그 연산자를 이용해 계산한다. 이때 피연산자의 순서에 유의해야 한다. 스택에서 먼저 나오는 피연산자가 연산의 두번째 피연산자가 되어야 한다. 연산자로 계산한 결과는 다시 스택에 저장하면 되고, 이 과정을 입력식의 끝까지 처리하면 계산이 끝난다. 계산이 끝나면 스택에는 계산결과 하나만이 남아있고, 이를 꺼내 반환하면 된다. 이를 구현한 코드는 다음과 같다.

``` Python
def evalPostfix(expr):
    s = Stack()                         # 스택 객체 생성
    for token in expr:                  # 리스트의 모든 항목에 대해
        if token in '+-*/':             # 항목이 연산자이면
            val2 = s.pop()              # 피연산자2
            val1 = s.pop()              # 피연산자1
            if (token == '+'):          # 각 연산 수행
                s.push(val1 + val2)     # 결과는 스택에 다시 저장
            elif (token == '-'):
                s.push(val1 - val2)
            elif (token == '*'):
                s.push(val1 * val2)
            elif (token == '/'):
                s.push(val1 / val2)
        else:                           # 항목이 피연산자이면
            s.push(float(token))        # 실수로 변경해서 스택에 저장
    
    return s.pop()                      # 최종결과를 반환
```

**float(str)**, **int(str)** 등은 문자열 str을 실수나 정수로 변환하는 형변환 함수이다.

테스트 프로그램의 실행결과는 다음과 같다. 리스트로 주어지는 중위표기 수식을 계산하여 결과를 출력한다.

``` Python
expr1 = ['8', '2', '/', '3', '-', '3', '2', '*', '+']
expr2 = ['1', '2', '/', '4', '*', '1', '4', '/', '*']
print(expr1, '-->', evalPostfix(expr1))
print(expr2, '-->', evalPostfix(expr2))
```




### 스택을 이용한 중위표기 수식의 후위표기 변환

이제 중위표기 수식을 후위표기로 변환해보자. 중위표기 수식에는 괄호가 포함되는데, **괄호를 이용해 어느 연산을 먼저 해야 할 지를 표시**한다. **괄호가 없으면 연산자 우선순위**에 따라 먼저 처리해야 할 수식을 결정해야 한다. 두 표기식의 공통점은 피연산자의 순서는 동일하다는 것이다. 물론 연산자들의 순서는 달라진다. 연산자의 출력 순서는 연산자들의 우선순위 관계와 괄호에 의해 결정된다.

* 입력된 중위표기 수식을 순서대로 하나씩 스캔한다.
* 피연산자를 만나면 바로 (후위표기 수식으로) 출력한다.
* 연산자를 만나면 어딘가에 잠시 저장해야 한다. 후위표기에서는 연산자가 피연산자들 뒤에 나오기 때문이다. 따라서 적절한 위치를 찾을 때까지 출력을 보류하여야 한다. 연산자의 저장에는 스택이 사용된다.


예를 들어보자. a + b에서 a는 바로 출력되고 +는 저장되며 b도 출력되고, 최종적으로 저장되었던 +를 출력하면 후위표기식 ab+가 된다.  a+b*c의 경우, a, b, c는 그대로 출력되고 +와 *는 어딘가에 저장된다. 문제는 + 연산자와 * 연산자 중에서 어떤 것이 먼저 출력되어야 하는가이다. 이때 연산자 우선순위와 괄호를 고려해야 한다. 다음 3가지 경우를 생각해보자.


#### 예제 1) 중위표기식 A + B * C의 후위변환

이 식의 처리과정과 스택의 내용은 다음과 같다.







먼저 1, 3, 5 단계는 문제가 없다. 피연산자이므로 바로 출력하면 된다. 2단계에서는 스택이 비어있으므로 '+'를 스택에 바로 넣으면 된다.

4단계가 문제이다. 연산자 우선순위를 생각해야 한다. +를 꺼내 먼저 출력하고 *을 넣으면 어떻게 될까? +가 먼저 계산되므로 잘못된 계산결과가 나온다. 따라서 *를 + 위에 넣어야 한다. 규칙은 다음과 같다.

* 현재 연산자보다 **우선순위가 높은 연산자는 모두 먼저 출력한 후** 현재 연산자를 스택에 넣는다. 앞에서 스택에 있는 +가 *보다 우선순위가 낮기 때문에 +위에 *을 삽입한다.
* **우선순위가 같은 경우도 먼저 출력**해야 한다. a - b + c같은 경우에 만약 abc+-로 출력한다면 계산결과가 달라진다. 따라서 우선순위가 같은 연산자는 먼저 나온 연산자가 먼저 처리되어야 하므로 꺼내서 출력하여야 한다.
* 입력수식이 끝나면 스택의 남은 연산자들을 모두 pop() 해서 후위표기 수식으로 출력한다.


#### 예제 2) 중위표기식 A * B + C의 후위변환

이 식에서도 1~3 단계인 A, *, B 까지는 문제가 없다.

4단계에서 +가 들어오면 *가 스택에 들어있는 상태이므로 +를 스택에 넣어도 될까? 안 된다. *가 +보다 우선순위가 높고 따라서 먼저 출력되어야 하기 때문이다. 따라서 *을 꺼내 출력하고 난 다음에 +를 스택에 삽입한다.







#### 예제 3) 괄호를 포함한 수식 (A + B) * C의 후위수식 변환

수식에 괄호가 포함되면 괄호들은 어떻게 처리해야 할까?

* 왼쪽 괄호는 무조건 스택에 삽입한다. 왼쪽 괄호가 일단 스택에 삽입되면 우리는 **왼쪽 괄호를 제일 우선순위가 낮은 연산자로 취급**한다. 즉, 다음에 만나는 어떤 연산자도 스택에 바로 삽입된다.
* **오른쪽 괄호를 만나면 왼쪽 괄호가 삭제될 때까지 왼쪽 괄호 위에 쌓여있는 모든 연산자들을 출력**한다.

이러한 규칙에 따라 (A + B) * C 를 후위식으로 바꿔보자.









* 1단계에서 왼쪽 괄호는 스택에 넣는다.
* 2, 4, 7단계는 모두 피연산자이므로 바로 출력하면 된다.
* 3단계에서 왼쪽 괄호는 가장 우선순위가 낮으므로 '(' 위에 '+'를 쌓는다.
* 5단계에서 오른쪽 괄호가 나왔으므로 스택에서 왼쪽 괄호가 나올 때까지 모든 연산자를 꺼내 출력한다. '+'가 출력되고, 스택은 다시 공백상태가 된다.
* 6단계에서 연산자를 공백상태인 스택에 넣는다.
* 8단계에서 마지막으로 스택의 모든 연산자를 꺼내 출력한다.



### 중위표기식의 후위변환 구현

먼저 연산자들의 우선순위를 정하는 함수를 구현해야 한다. 알고리즘에서 열리는 괄호는 우선순위가 가장 낮아야 하므로 0을 반환하고, 덧셈과 뺄셈은 우선순위가 1, 곱셈과 나눗셈은 가장 높은 2를 반환하도록 한다.

``` Python
def precedence(op):                 # 연산자의 우선순위 반환
    if op == '(' or op == ')':      # 괄호를 가장 낮게 처리
        return 0
    elif op == '+' or op == '-':    # +, -의 우선순위
        return 1
    elif op == '*' or op == '/':    # *, /가 가장 높음
        return 2
    else:
        return -1
```

이제 본격적으로 후위표기 변환 함수를 구현하자. 입력은 역시 리스트인데, 문자열로 나타나 있는 연산자와 피연산자를 순서적으로 모은 것이다. 예를 들어, 중위표기식 ```8 / 2 - 3 + (3 * 2)```는 리스트에 다음과 같이 저장될 것이다.

``` Python
expr = ['8', '/', '2', '-', '3', '+', '(', '3', '*', '2', ')']
```

이 함수의 출력은 새로운 리스트가 된다. 위의 식이 정상적으로 변환되면 이 함수는 다음과 같은 리스트를 반환할 것이다.

``` Python
output = ['8', '2', '/', '3', '-', '3', '2', '/', '*']
```

중위표기 수식의 후위식 변환 함수는 다음과 같다.

``` Python
def Infix2Postfix(expr):                # expr : 입력 리스트(중위표기식)
    s = Stack()
    output = []                         # output : 출력 리스트(후위표기식)
    for term in expr:
        if term in '(':                 # 왼쪽 괄호이면
            s.push('(')                 # 스택에 삽입
        elif term in ')':               # 오른쪽 괄호이면
            while not s.isEmpty():
                op = s.pop()
                if op == '(':           # 왼쪽 괄호가 나올 때까지
                    break       
                else:                   # 스택에서 연산자를 꺼내 출력
                    output.append(op)
        elif term in '+-*/':            # 연산자이면
            while not s.isEmpty():      # 우선순위가 높거나 같은 연산자를
                op = s.peek()           # 스택에서 모두 꺼내 출력
                if (precedence(term) <= precedence(op)):
                    output.append(op)
                    s.pop()
                else:
                    break
            s.push(term)                # 마지막으로 현재 연산자 삽입
        else:                           # 피연산자이면
            output.append(term)         # 바로 출력

    while not s.isEmpty():              # 처리가 끝났으면 스택에 남은 항목을
        output.append(s.pop())          # 모두 출력

    return output                       # 결과(후위표기식 리스트)를 반환
```

이제 완전한 계산기 동작을 테스트해보자. 중위표기식을 입력하면 후위표기로 변환한 후 계산하여 결과를 출력하는 프로그램은 다음과 같다.

``` Python
infix1 = ['8', '/', '2', '-', '3', '+', '(', '3', '*', '2', ')']
infix2 = ['1', '/', '2', '*', '4', '*', '(', '1', '/', '4', ')']
postfix1 = Infix2Postfix(infix1)
postfix2 = Infix2Postfix(infix2)
result1 = evalPostfix(postfix1)
result2 = evalPostfix(postfix2)
print(' 중위표기:', infix1)
print(' 후위표기:', postfix1)
print(' 계산결과:', result1, end = '\n\n')
print(' 중위표기:', infix2)
print(' 후위표기:', postfix2)
print(' 계산결과:', result2)
```

실행결과는 다음과 같다. 후위표기에서 괄호가 사라진 것에 유의하라.



## 4.5 스택의 응용 : 미로 탐색

### 미로에 빠진 생쥐를 구출하자.

미로탐색 문제란 그림과 같이 미로에 갇힌 생쥐가 출구를 찾는 문제이다. 이것은 그래프 탐색 문제(10장)와 유사한데, 출구를 찾기 위해 생쥐는 다양한 탐색 방법을 사용할 수 있다.




가장 간단한 탐색 방법은 시행착오를 이용하는 것으로 하나의 경로를 선택하여 시도해보고 막히면 다시 다른 경로를 시도하는 것이다. 이때 현재의 경로가 막혔을 때 다시 선택할 수 있는 다른 경로들을 **어딘가**에 저장해야 한다. 그렇다면 어디에 경로를 저장하면 좋을까? 보통은 **가던 길이 막히면 가장 최근에 있었던 갈림길로 되돌아가서** 다른 곳을 찾아보고 싶을 것이다. 자연스럽게 스택이 떠오른다. 사실은 저장된 경로를 모두 선택할 수 있는 방법이라면 경로를 어떤 자료구조에 저장하든지 출구를 찾을 수 있다. 그렇지만 이 장에서는 스택에 지나온 경로를 저장하자. 이러한 방법을 **깊이우선탐색(DFS, Depth First Search)**이라고 한다.

일단 미로는 다음과 같이 서로 연결된 여러개의 작은 방으로 구성되어 있다고 가정하자. 이것은 2차원 배열구조로 나타낼 수 있는데, 파이썬으로는 다음과 같이 **리스트의 리스트**로 표현할 수 있다.



``` Python
map = [['1', '1', '1', '1', '1', '1'],
       ['e', '0', '0', '0', '0', '1'],
       ['1', '0', '1', '0', '1', '1'],
       ['1', '1', '1', '0', '0', 'x'],
       ['1', '1', '1', '0', '1', '1'],
       ['1', '1', '1', '1', '1', '1']]
MAZE_SIZE = 6
```


### 탐색 알고리즘

모든 칸의 위치는 (**열**, **행**)으로 표시하자. ((x, y) 순서) 생쥐의 현재위치(시작위치)를 스택에 넣으면서 탐색이 시작된다. 알고리즘을 생각해보자.

* Step 1 : 시작위치를 스택에 넣는다. 현재 스택에는 시작위치만 들어있다.
* Step 2 : 스택이 공백이 아니면 하나의 위치를 꺼낸다. 이것이 현재위치이다. 현재 위치에 '**방문했음**' 표시를 한다. 만약 스택이 공백이라면 이 미로에는 출구가 없는 것이므로 종료한다.
* Step 3 : 만약 현재위치가 출구이면 탐색은 성공으로 끝난다.
* Step 4 : 그렇지 않으면 이웃(상하좌우) 방들을 살펴본다. 만약 이웃 방들이 아직 방문되지 않았고 갈 수 있는 방이라면 그 방의 위치를 모두 스택에 삽입한다. 다시 Step 2로 돌아간다.


만약 이웃 방들을 탐색하는 순서가 '**상하좌우**'가 아니라 '**좌우상하**'라면 탐색 순서는 달라진다. 이웃 위치가 스택에 들어가는 순서가 달라지기 때문이다. 그러나 길이 있다면 반드시 결과를 찾는다.







### 스택을 이용한 깊이우선탐색의 구현

미로는 앞에서 살펴본 2차원 배열구조 map으로 표현되어 있다고 가정하자. 미로의 크기 MAZE_SIZE는 6이다. map의 각 항목들은 2차원 배열처럼 map[y][x]로 접근할 수 있다. 생쥐는 벽이나 미로 밖으로 움직일수는 없으므로, 어떤 위치 (x, y)가 갈 수 있는 위치인지를 검사하는 함수가 있으면 편리할 것이다. 다음 코드의 마지막 문장인 return 문에서는 해당 위치의 값에 따라 True나 False를 반환한다.

``` Python
def isValidPos(x, y):       # (x, y)가 갈 수 있는 방인지 검사하는 함수
    if x < 0 or y < 0 or x >= MAZE_SIZE or y >= MAZE_SIZE:
        return False        # (x, y)가 미로 밖이면 --> 갈 수 없음
    else:                   # 출구('x')이거나 방('0')이면 갈 수 있음
        return map[y][x] == '0' or map[y][x] == 'x'
```


이제 알고리즘을 구현할 모든 준비가 다 되었다. 스택에는 어떤 정보를 저장해야 할까? 생쥐의 "위치"가 저장되어야 한다. "위치"는 어떻게 표현할까? 가장 효율적이고 간편한 방법이 파이썬의 튜플(tuple)일 것이다. 파이썬 코드에서 (x, y)는 항목이 2개인 튜플을 의미한다. 이것을 사용하자. 스택을 이용한 DFS 코드는 다음과 같다.

``` Python
def DFS():                          # 깊이우선탐색 함수
    stack = Stack()                 # 사용할 스택 객체를 준비
    stack.push( (0, 1))             # 시작위치 삽입. (0, 1)은 튜플
    print('DFS:')

    while not stack.isEmpty():      # 공백이 아닐 동안
        here = stack.pop()          # 항목을 꺼냄(pop)
        print(here, end = '->')
        (x, y) = here               # 스택에 저장된 튜플은 (x, y) 순서임
        if map[y][x] == 'x':        # 출구이면 탐색 성공. True 반환
            return True
        else:
            map[y][x] = '.'         # 현재위치를 지나왔다고 '.' 표시
            # 4방향의 이웃을 검사해 갈 수 있으면 스택에 삽입
            if isValidPos(x, y - 1):    
                stack.push((x, y - 1))  # 상
            if isValidPos(x, y + 1):
                stack.push((x, y + 1))  # 하
            if isValidPos(x - 1, y):
                stack.push((x - 1, y))  # 좌
            if isValidPos(x + 1, y):
                stack.push((x + 1, y))  # 우
        print('현재 스택:', stack)       # 현재 스택 내용 출력
    return False                        # 탐색 실패. False 반환

result = DFS()
if result:
    print('--> 미로탐색 성공')
else:
    print('--> 미로탐색 실패')
```


현재 스택의 내용은 4.2절의 마지막에 설명된 것과 같이 `__str__` 함수를 추가하여 리스트의 역순, 즉 가장 최근에 삽입된 항목부터 출력되도록 하였다. 스택에 현재 위치를 (x, y)의 순으로 저장했으므로, pop에 의해 추출된 튜플 here에서 다음과 같이 x와 y 값을 읽어올 수 있다.


파이썬에서 튜플을 이용해 여러개의 값을 동시에 바꿀 수 있다. 이것은 C나 Java 등과 비교해서 매우 편리한 기능이다. 예를 들어, C언어에서 int 변수 x와 y를 서로 교환하기 위해서는 다음과 같이 임시변수(tmp)를 사용해 다음과 같이 구현해야 한다.

``` C
tmp = x;
x = y;
y = tmp;
```




파이썬에서는 다음과 같이 훨씬 단순한 방법을 제공한다.

``` Python
x, y = y, x
```
물론 2개 이상의 변수에 대해서도 동일하게 적용된다. 너무 편리하다!
같은 방법으로 함수에서 여러개의 값을 반환할 수도 있다. 어떤 함수 func()가 2개의 값을 반환한다면 다음과 같이 처리할 수 있다.

``` Python
x, y = func()
```

사실 함수는 반환할 값들을 튜플로 만들어 반환한다. 따라서 다음과 동일하다.

``` Python
(x, y) = func()
```


---

** Reference

* <파이썬으로 쉽게 풀어쓴 자료구조와 알고리즘>

