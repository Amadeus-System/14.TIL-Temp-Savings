


# Chapter 4. Stack

## 4.1 스택이란?

### 스택은 후입선출(Last-In First Out : LIFO)의 자료구조이다.

스택은 주방의 접시더미를 생각하면 쉽게 이해할 수 있다. 접시를 닦는 사람은 닦은 접시를 항상 접시더미의 맨 위에 올려놓는다. 요리사는 요리를 담을 새 접시가 필요하면 항상 맨 위에 있는 접시를 꺼내 음식을 담아 손님들에게 제공한다. 물론 더미의 중간에 있는 접시를 빼서 사용할 수도 있지만 이것은 매우 조심스럽고 번거로운 작업이 될 것이다.





**스택(Stack)**은 이와 같이 자료의 입출력이 **후입선출(LIFO : Last-In First-Out)**의 형태로 일어나는 자료구조를 말한다. 예를 들어, 스택에 A, B, C, D를 순서대로 입력했다면 꺼낼 때는 D, C, B, A로만 꺼낼 수 있다. 이것은 리스트에서 항목 접근을 위한 다른 통로들은 모두 막고 **후단**만을 열어둔 구조와 같다. 열린 곳을 보통 **스택 상단(Top)**이라 부른다. 그림과 같이 삽입과 삭제는 상단으로만 할 수 있고, 스택의 중간에는 항목을 삽입하거나 삭제할 수 없다. 따라서 연산도 매우 간단해진다.

[그림 4.1] 스택의 구조와 일련의 연산들



### 스택의 추상자료형

스택에는 어떤 것들을 저장할 수 있을까? 숫자나 문자열은 물론이고 복잡한 클래스의 객체나 심지어 여러개의 항목을 가진 리스트 등 어떤 자료든지 저장할 수 있다. 그러면 스택은 어떤 기능을 가져야 할까? 접시를 보관하는 접시함을 이용해 스택으로 무엇을 할 수 있는지 생각해보자. 다음은 접시함의 기본기능이다.

* 보관함이 비어있는지 살핀다(**isEmpty**) --> 스택이 비어있는지 살핀다.
* 접시를 보관함에 넣는다(**push**) --> 새로운 항목을 스택에 삽입한다.
* 접시 하나를 꺼낸다(**pop**) --> 스택에서 하나의 항목을 꺼내온다.

만약 접시함이 최신 고급모델이라면 다양한 고급기능들도 제공할 것이다.

* 보관함의 현재 접시 개수를 알려준다(**size**)
* 접시를 꺼내지 않고 맨 위의 접시가 무엇인지 알려준다(**peek**)
* 보관함을 깨끗이 비운다(**clear**)

고급기능들은 스택의 필수기능이라고 보기는 어려운데, 기본 연산들을 조합해서 구현할 수 있기 때문이다. clear 기능은 모든 접시를 꺼내면(pop) 되고, peek 기능은 pop으로 접시 하나를 꺼내서 확인한 후 다시 스택에 push하면 된다.

입출력에 제한을 가함에 따라 리스트에 비해 연산들이 매우 간단해지는 것에 유의하라. 이제, 스택을 추상자료형으로 정의하자. 앞에서 생각한 연산들에 이름을 붙이고 동작을 조금 더 구체적으로 설명하면 된다.


정의 4.1 Stack ADT

* 데이터 : 후입선출(LIFO)의 접근방법을 유지하는 항목들의 모음
* 연산
    - Stack() : 비어있는 새로운 스택을 만든다.
    - isEmpty() : 스택이 비어있으면 True를 아니면 False를 반환한다.
    - push(e) : 항목 e를 스택의 맨 위에 추가한다.
    - pop() : 스택의 맨 위에 있는 항목을 꺼내 반환한다.
    - peek() : 스택의 맨 위에 있는 항목을 삭제하지 않고 반환한다.
    - size() : 스택 내의 모든 항목들의 개수를 반환한다.
    - clear() : 스택을 공백상태로 만든다.


### 스택은 어디에 사용할까?

스택은 특히 자료의 출력순서가 입력의 역순으로 이루어져야 할 경우에 매우 긴요하게 사용된다.

* 문서나 그림, 수식 등의 편집기에서 **되돌리기(Undo)** 기능을 구현할 때 스택이 사용된다. 되돌리기는 지금까지 실행된 명령어 중에서 가장 최근 것부터 순서대로 취소해야 하기 때문이다. 웹 브라우저의 "**이전 페이지로 이동**" 기능도 마찬가지이다. 가장 최근에 본 페이지로 이동해야 한다. 지금까지 본 페이지 정보를 스택에 저장해야 한다.




* **함수 호출에서 복귀주소**를 기억하는데 스택을 사용한다. C언어로 구현된 다음 코드를 보자. main()에서 함수 a()를 호출하고 a()에서 다시 b()와 c()를 연속적으로 호출하였다. c()가 종료되면 이를 호출한 함수인 b()로 돌아가야 한다. 이러한 복잡한 함수의 호출과 반환을 위해 운영체제는 시스템 스택을 사용한다. **시스템 스택**에는 현재 실행되고 있는 함수가 종료되면 돌아갈 문장의 주소(Program Counter)와 함수 호출시 매개변수나 함수 안에서 선언된 지역변수와 같은 정보들이 저장되어 다시 되돌아갔을 때 이전 상태를 유지할 수 있도록 한다.




* 문서나 소스코드에서 **괄호 닫기**가 정상적으로 되었는지를 검사하는 프로그램에서도 스택을 사용한다. 또한 **계산기 프로그램**에서 입력된 수식을 계산하는 과정에도 스택이 사용된다. 미로에서 출구를 찾기 위해서도 스택을 사용할 수 있다. 이들은 응용 예제를 통해 더 자세히 공부한다.



이 외에도 스택을 사용하는 응용은 매우 다양하므로 잘 이해해야 한다.

스택을 구현하는 방법을 살펴보자. 3장의 리스트에서와 같이 기본적으로 **배열구조와 연결된 구조**로 구현할 수 있다. 물론 각 방법은 장단점을 갖는다. 이 장에서는 파이썬의 리스트를 이용한 배열구조로 구현하는 방법을 공부하고, 연결된 구조는 6장에서 공부한다.





## 4.2 스택의 구현

### 배열구조를 이용한 스택의 함수 구현

스택 항목들을 저장하는 가장 간단한 방법은 배열구조를 사용하는 것이다. 물론 파이썬에서는 리스트를 사용한다. 이 리스트(배열)의 이름을 top이라 하자. 맨 처음에 이 리스트는 공백이 되어야 한다.

``` Python
top = []    # 스택의 데이터 : 항목을 위한 공백 리스트
```

``` Python
C언어에서 배열을 이용해 스택을 구현하는 경우 보통 top을 가장 최근에 들어온 항목의 인덱스(정수)를 저장하는 변수로 사용한다. 파이썬의 리스트는 항목들의 개수를 len() 함수를 이용해 알 수 있기 때문에 이러한 변수를 추가로 사용할 필요가 없다. 리스트만 하나 있으면 되고, 이를 top이라고 하자.
```

데이터가 결정되면 이제 연산들을 구현한다. 일단 가장 간단하게 연산들을 모두 함수로 구현한다.


### isEmpty() : 공백상태 검사

스택이 공백상태이면 top은 빈 리스트이다. 따라서 리스트에서와 같이 len() 함수를 이용해 항목의 수를 먼저 구하고, 이 값이 0인지를 검사하면 된다. 이 함수는 True나 False를 반환한다.

``` Python
def isEmpty():
    return len(top) == 0    # len(top) == 0의 계산결과가 True/False
```


### push(item) : 삽입 연산

스택에서 삽입 연산은 **스택 상단에 항목을 추가**하는 것이다. 그렇다면 리스트 top의 어느 곳이 스택의 상단일까? 물론 내 마음대로 사용하면 된다. 그러나 **리스트의 맨 뒤를 스택의 상단으로 사용하는 것이 좋다**. 리스트의 후단을 스택 상단이라고 생각하면 삽입 연산은 리스트의 맨 뒤에 항목 item을 추가하는 작업이 되고, 리스트의 append() 연산을 사용하여 다음과 같이 간단히 구현할 수 있다.

``` Python
def push(item):
    top.append(item)    # 리스트의 맨 뒤에 item을 추가함.
```

**대부분의 경우** append()는 상수 시간에 항목을 추가할 수 있다. 따라서 이 연산의 시간복잡도는 $O(1)$이다. 만약 리스트의 맨 앞을 스택 상단으로 사용하면 어떻게 될까? 리스트의 insert() 메소드를 사용하면 되고, 삽입연산 코드를 top.insert(0, item)로 바꾸기만 하면 된다. 그런데 효율성에서 문제가 발생한다. 리스트의 0번 위치에 항목을 넣기 위해서는 리스트의 모든 항목들을 한 칸씩 뒤로 밀어야 하기 때문이다. 이 경우 삽입연산의 시간복잡도가 $O(n)$이 된다.


[그림 4.2] 스택 상단(top)으로 파이썬 리스트의 후단과 전단을 사용하는 경우의 삽입연산 비교. 후단을 사용하는 것이 훨씬 효율적임.


이 문제는 삭제연산에서도 동일하게 발생한다. 따라서 반드시 리스트의 맨 뒤를 스택의 상단으로 사용해야 효율적인 알고리즘이 가능하다.

``` Python
"대부분의 경우"의 의미가 잘 이해되지 않는다면 3.2절의 내용을 복습하라. 리스트가 동적배열 구조로 구현되었기 때문에 "항상"이 아니라 "대부분의 경우"란 표현을 사용하였다.
```


### pop() : 삭제연산

삭제 연산은 스택 상단에서 항목을 하나 꺼내고 이를 반환하는 것이다. 우리는 리스트의 후단을 스택의 상단으로 사용하기 때문에, 리스트의 맨 뒤의 항목을 꺼내 반환하면 된다. 파이썬의 리스트는 항목을 꺼낼 수 있는 pop(pos) 연산을 제공하는데, 매개변수로 꺼낼 항목의 위치를 전달해야 한다. 리스트 top의 마지막 항목의 위치는 len(top) - 1이 될 것이다. 물론 파이썬은 음수 인덱스를 지원하므로 -1을 사용하는 것도 좋은 방법이다. 따라서 top.pop(-1)은 top의 맨 마지막 항목을 리스트에서 꺼낸다.

만약 스택이 공백이면 항목을 꺼낼 수 있을까? 물론 불가능하다. 따라서 스택이 공백이 아닌 경우에만 pop 연산을 처리해야 한다. 코드는 다음과 같다.

``` Python
def pop():
    if not isEmpty():       # 공백상태가 아니면
        return top.pop(-1)  # 리스트의 맨 뒤에서 항목을 하나 꺼내고 반환
```

삭제 연산은 **항상** $O(1)$에 처리된다. 물론 이것은 리스트의 맨 뒤를 스택 상단으로 사용했을 경우이다. 코드에서 스택이 공백인 경우를 처리하지 않았음에 유의하라. 공백상태이면 에러 메시지를 출력하거나, 프로그램을 종료하거나, 특별한 오류 코드를 반환하는 등 다양하게 처리할 수 있는데, 이들은 모두 응용에 따라 다르다. 따라서 이 책에서는 **오류 상태에 대한 처리코드는 생략**하였다.


### 기타 연산들

나머지 연산들도 다음과 같이 간단히 구현된다. peek는 리스트의 마지막 항목을 반환하면 된다. 스택 내용에는 변화가 없다. 물론 이 경우에도 스택이 공백상태가 아니어야 한다.

``` Python
def peek():                 # 맨 위의 항목을 삭제하지 않고 반환
    if not isEmpty():       # 공백상태가 아니면
        return top[-1]      # 맨 뒷 항목을 반환(삭제하지 않음)
```

size와 clear 연산은 리스트에서와 동일하다.

``` Python
def size():
    return len(top)     # 스택의 크기

def clear():
    global top          # top은 전역함수임을 지정함
    top = []            # 스택의 초기화
```

구현한 모든 연산의 시간복잡도는 $O(1)$이다. 만약 리스트의 맨 앞을 상단으로 사용하면 삽입과 삭제연산이 $O(n)$, 즉 현재 스택에 저장된 항목의 수에 비례하는 시간이 걸리는 비효율적인 스택이 된다.


### 스택의 활용

이제 스택을 사용해보자. 먼저 1부터 5까지 5개의 숫자를 push하고, 스택을 출력한다. 다음으로 두 번의 pop 연산을 하고 스택을 출력한다.

``` Python
for i in range(1, 6):        # i = 1, 2, 3, 4, 5
    push(i)                  # push 연산 5회
print(' push 5회:', top)     # 스택 내용 출력
print(' pop() -->', pop())   # pop 연산 및 반환 항목 출력
print(' pop() -->', pop())   # pop 연산 및 반환 항목 출력
print(' pop 2회:', top)      # 스택 내용 출력 (str(top)도 동일함)
```

스택의 출력을 위해 print() 함수를 사용하였는데, 이 함수에 파이썬 리스트 top을 인수로 전달하면 리스트의 내용을 자동으로 문자열로 바꾸어 화면으로 출력한다. 그렇다면 항목의 출력 순서는 어떻게 될까? 우리는 리스트의 맨 뒤를 상단으로 사용했던 것을 기억하라. 가장 먼저 들어온 항목이 다음과 같이 화면으로는 가장 먼저 출력된다.






지금까지 스택에 정수를 삽입했고, 현재 3개의 정수가 스택에 남아있다. 이 상태에서 스택에 문자열을 넣으면 어떻게 동작이 될까? 파이썬에서는 리스트에 객체가 직접 저장되는 것이 아니라 객체를 가리키는 변수가 저장된다. 따라서 변수가 가리키는 객체가 어떤 것이든 문제없다. 정수가 3개 들어있는 현재 스택에 문자열을 2개 삽입하고, 한번 삭제하는 코드는 다음과 같다.

``` Python
push('홍길동')
push('이순신')
print(' push + 2회:', top)      # 스택 내용 출력
print(' pop() -->', pop())      # pop 연산 및 반환 항목 출력
print(' pop 1회: ', top)       # 스택 내용 출력
```

이 코드에서는 하나의 리스트가 여러 자료형의 객체들을 참조하였다. 그러나 이 책에서는 하나의 자료구조에는 동일한 자료형의 객체들만을 참조할 것이다.


### 배열구조를 이용한 스택의 클래스 구현

만약 하나의 프로그램에서 여러개의 스택이 필요하면 앞에서 구현한 방법은 문제가 있다. 왜냐하면 항목을 저장하는 리스트가 하나뿐이기 때문이다. 여러개의 스택을 사용하려면 역시 클래스로 구현하는 것이 가장 좋다. 3장의 리스트와 집합 클래스를 복습하라.

이제 스택을 클래스로 구현해보자. 이미 모든 기능을 구현했으므로 클래스로 바꾸는 것은 어렵지 않다. 클래스 이름은 Stack으로 하고, 다음을 주의하면 된다.

* 생성자에 클래스의 데이터 멤버를 선언하고 초기화한다. 스택의 유일한 데이터인 top을 리스트로 선언하면 된다.
* 모든 메소드의 첫번째 파라미터로 self를 추가한다.
* 모든 메소드에서 클래스의 멤버를 사용할 때 self.을 추가하여 클래스 내의 변수(데이터 멤버) 및 함수(메소드)임을 표시한다.

구현한 스택 클래스는 다음과 같다. 클래스임을 표시하기 위해 코드의 바탕색을 바꾼 것에 유의하라.

``` Python
class Stack():

    def __init__(self):                 # 생성자
        self.top = []                   # top이 이제 클래스의 멤버 변수가 됨

    def isEmpty(self):
        return len(self.top) == 0

    def size(self):
        return len(self.top)

    def clear(self):
        self.top = []                   # 주의 : 이제 전역변수 선언이 필요없다.

    def push(self, item):
        self.top.append(item)

    def pop(self):
        if not self.isEmpty():
            return self.top.pop(-1)
    
    def peek(self):
        if not self.isEmpty():
            return self.top[-1]
```

스택은 3장의 ArrayList나 Set 클래스에 비해 훨씬 간단하다. 연산이 단순하기 때문이다. 이제 구현한 클래스를 사용해보자.

* 먼저 s = Stack()와 같은 코드로 스택 객체를 만든다. 여러개의 스택을 만들어 사용해도 문제없다.
* 스택의 메소드나 멤버 변수는 스택 객체를 통해서 호출된다. 예를 들어 스택 s에 item을 삽입하려면 s.push(item)와 같이 작성한다.
* 2개의 스택 even과 odd를 만들고, 0~9의 숫자 중에서 짝수는 even에 홀수는 odd에 저장해보자. 다음 코드의 결과를 미리 예상해보라.

``` Python
odd = Stack()                           # 홀수 저장을 위한 스택
even = Stack()                          # 짝수 저장을 위한 스택
for i in range(10):                     # i = 0, 1, 2, ..., 9
    if i % 2 == 0:                      
        even.push(i)                    # 짝수는 even에 push
    else:
        odd.push(i)                     # 홀수는 odd에 push

print(' 스택 even push 5회:', even)     # even 스택 출력
print(' 스택 odd  push 5회:', odd)      # odd  스택 출력
print(' 스택 even peek:', even.peek())  # even 스택 peek()
print(' 스택 odd  peak:', odd.peek())   # odd  스택 peek()

for _ in range(2):
    even.pop()                          # even 스택에서 2번 pop()
for _ in range(3):          
    odd.pop()                           # odd  스택에서 3번 pop()

print(' 스택 even pop 2회:', even)      # even 스택 출력
print(' 스택 odd  pop 3회:', odd)       # odd  스택 출력
```





그런데 스택의 출력 결과가 이상하다. **스택 내용**이 출력되는 것이 아니라 **스택 객체**의 정보가 출력된다. 어떻게 해야 스택 내용이 출력될까? 하나의 방법은 print() 함수에 even을 넣는 것이 아니라 even.top을 넣는 것이다. **even은 스택 객체이지만 even.top은 리스트 객체**이다! 코드를 다음과 같이 수정한다.

``` Python
print(' 스택 even push 5회:', even.top)     # even 스택 출력
print(' 스택 odd  push 5회:', odd.top)      # odd  스택 출력
```

이제 결과는 다음과 같이 원하는대로 나온다.





더 좋은 방법이 있다. print() 함수에 우리가 만든 클래스의 객체를 넣더라도 알아서 문자열로 바꾸어 출력할 수 있도록 하는 방법이다. 즉, 코드를 위와 같이 수정하지 않더라도 제대로 출력되도록 하는 것이다. 어떻게 할 수 있을까?

**연산자 중복**(2.11장 참조)을 사용하는 것이다. 스택의 생성자 `__init__()`과 비슷하게 특수한 메소드 `__str__()`를 Stack 클래스에서 구현해주는 것이다. 클래스에 이 메소드가 있으면 이 클래스의 객체를 문자열로 바꾸어야 하는 경우 자동으로 이 함수를 통해 변환해준다. 즉, 문자열로의 형 변환 연산자를 중복하는 것이다. 코드는 다음과 같다.

``` Python
def __str__(self):
    return str(self.top)    # Stack 객체를 문자열로 변환
```

이 함수에서 출력 순서도 바꿀 수 있다. 가장 나중에 들어온 항목이 가장 먼저 출력되도록 해보자. 리스트 항목을 뒤집을 때에는 슬라이싱 기능을 사용할 수 있다. 즉, 전체를 역순([::-1])으로 변환하는 것이다. 예를 들어, [1, 2, 3][::-1]은 [3, 2, 1]이다. 이를 이용해 코드를 다음과 같이 수정하면 스택 내용이 역순으로 출력된다.

``` Python
def __str__(self):
    return str(self.top[::-1])  # 역순으로 출력. 최근의 항목을 먼저.
```





``` Python
파이썬의 **슬라이싱 기능**은 매우 강력하고 편리한 기능이기 때문에 많이 사용된다. 인터넷에서 자료와 예제들을 찾아보라.
```


### 4.3 스택의 응용 : 괄호 검사

수식 표기나 프로그래밍 언어, HTML 문서 등 다양한 분야에서 괄호와 같은 **구분 문자(Delimiter)**들을 사용한다. 이들은 주로 간단한 데이터나 문자열들을 묶어 하나의 그룹으로 만들 때 그룹의 시작과 끝을 나타낸다. 예를 들어, C언어의 소스코드에는 대괄호 [], 중괄호 {}, 소괄호 ()와 같은 다양한 기호들이 사용되는데, 다음 코드는 배열에서 최대값을 찾아 반환하는 C언어 함수이다.



``` C
int find_array_max(int score[], int n)
{
    int i, tmp = score[0];
    for (i=1; i<n; i++){
        if (score[i] > tmp){
            tmp = score[i];
        }
    }
    return tmp;
}
```

프로그램이 정상적으로 빌드되고 실행되려면 이들 괄호들이 같은 유형들끼리 쌍을 이루어 잘 사용되어야 하는데, 반드시 다음 조건을 맞추어 구성되어야 한다.

* **조건 1** : 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
* **조건 2** : 같은 타입의 괄호에서 왼쪽 괄호가 오른쪽 괄호보다 먼저 나와야 한다.
* **조건 3** : 서로 다른 타입의 괄호 쌍이 서로를 교차하면 안 된다.





괄호가 일치하지 않으면 잘못된 코드이기 때문에 C언어의 컴파일러는 이것을 먼저 검사해야 한다. 이와 같이 괄호 사용의 오류를 검사하기 위해 스택이 사용된다.




### 괄호 검사 알고리즘

위의 코드들을 자세히 살펴보면 **가장 가까운 거리에 있는 괄호들끼리 서로 쌍**을 이루어야 됨을 알 수 있다. 따라서 입력 문자열에서 왼쪽 괄호가 나오면 스택에 삽입하고, 오른쪽 괄호가 나오면 스택에서 가장 최근에 삽입된 괄호를 꺼내 짝을 맞추어보면 오류를 검사할 수 있다.

* 문자를 저장하는 스택을 준비한다. 처음에는 공백상태가 되어야 한다.
* 입력 문자열의 문자를 하나씩 읽어 왼쪽 괄호를 만나면 스택에 삽입한다.
* 오른쪽 괄호를 만나면 pop() 연산으로 가장 최근에 삽입된 괄호를 꺼낸다. 이때 스택이 비었으면 조건 2에 위배된다.
* 꺼낸 괄호가 오른쪽 괄호와 짝이 맞지 않으면 조건 3에 위배된다.
* 끝까지 처리했는데 스택에 괄호가 남아있으면 조건 1에 위배된다.


하나의 조건이라도 위배하면 오류이므로 False를 반환하고 그렇지 않으면 성공이므로 True를 반환한다. 다음 그림은 몇 가지 경우에 대한 처리과정을 보여준다.


[그림 4.3] 스택을 이용한 괄호 검사의 몇 가지 예시




### 괄호 검사 구현

괄호 검사를 구현해보자. 함수 이름은 checkBrackets()이라 하고, 검사할 문자열을 매개변수로 전달한다. 함수에서는 하나의 스택 객체를 만들어 검사에 사용한다. 알고리즘을 구현한 코드는 다음과 같다.

``` Python
def checkBracket(statement):
    stack = Stack()
    for ch in statement:                # 문자열의 각 문자에 대해
        if ch in ('{', '[', '('):       # in '{[('도 동일하게 동작함
            stack.push(ch)
        elif ch in ('}', ']', ')'):     # in '}])'도 동일하게 동작함
            if stack.isEmpty():
                return False            # 조건 2 위반
            else:
                left = stack.pop()
                if (ch == '}' and left != '{') or \
                   (ch == ']' and left != '[') or \
                   (ch == ')' and left != '('):
                   return False         # 조건 3 위반

    return stack.isEmpty()              # False이면 조건 1 위반
```

이 함수의 테스트 프로그램은 다음과 같다. 3개의 테스트 문자열을 사용하는데, 이들을 이번에는 리스트가 아니라 튜플(())로 만들어 함수에 전달했다. 물론 리스트([])를 사용해도 결과는 동일하지만 테스트 문자열을 변경하지 않을 것이므로 메모리 측면에서 더 효율적인 튜플을 사용하였다.

``` Python
str = ()
for s in str:
    m = checkBrackets(s)
    print(s, '--->', m)
```

``` Python
파이썬에서 튜플은 리스트와 비슷하게 사용되지만 항목의 개수를 변경할 수 없기 때문에 동적배열로 구현된 리스트보다 메모리 측면에서 훨씬 효율적이다.
```


### 소스파일에서 괄호 검사

만약 여러 줄의 코드가 들어간 파일을 검사하려면 어떻게 할까? 먼저 파일을 읽어들여야 할 것이다. 이를 위해 파일을 열고, 한꺼번에 파일의 모든 줄을 읽어 문자열 리스트에 저장하고, 검사하는 코드는 다음과 같다. 파일 입출력과 관련해서는 3.4절의 라인 편집기 코드를 복습하라.

``` Python
filename = 'ArrayStack.h'           # 괄호를 검사할 소스파일
infile = open(filename, 'r')        # 파일 열기
lines = infile.readlines()          # 파일 전체를 라인별로 읽은 리스트
infile.close()                      # 파일 닫기

result = checkBracketsV2(lines)     # 검사 함수 호출 (약간 수정 필요)
print(filename, '--->', result)     # 결과 출력
```

이 코드에서 ArrayStack.h는 괄호가 잘 짝지어진 소스코드라고 생각하자. 검사 함수 checkBracketV2()는 이제 입력이 문자열이 아니라 문자열의 리스트이므로 약간 수정해야 한다. 즉, 리스트의 모든 항목(문자열)에 대해 그 다음 문장들을 다음과 같이 실행하면 된다.

``` Python
def checkBracketV2(lines):
    stack = Stack()
    for line in lines:      # 리스트의 모든 문자열에 대해
        for ch in line:     # 문자열의 각 문자에 대해
            ...
```


## 4.4 스택의 응용 : 수식의 계산

(오늘은 여기까지!! 내일부터 다시 시작!!)
































