

* Date : 2022-05-27
* Last Devised : 2022-05-28

# Chapter 5. Queue and Deck

## 5.1 큐란?

### 큐는 선입선출(First-In First-Out : FIFO)의 자료구조이다.

여행을 가기 위해 공항 카운터에 줄을 서서 기다리는 대기열을 생각하면 큐를 쉽게 이해할 수 있다. 큐(Queue)는 먼저 들어온 데이터가 먼저 나가는 선입선출(FIFO : First-In First-Out)의 특성을 갖는 자료구조이다. 가장 앞에 있는 사람, 즉 가장 먼저 온 사람이 가장 먼저 서비스를 받아야 하고, 방금 도착한 사람은 줄의 맨 뒤에 서서 기다려야 한다.




큐는 뒤에서 새로운 데이터가 추가되고 앞에서 데이터가 하나씩 삭제되는 구조를 가지고 있다. 구조상으로 큐가 스택과 다른 점은 삽입과 삭제 연산의 위치가 같은 쪽이 아니라 서로 다른 쪽에서 일어난다는 것이다. 큐에서 삽입이 일어나는 곳을 **후단(Rear)**이라 하고 삭제가 일어나는 곳을 **전단(Front)**이라 한다. 다음은 큐의 구조를 보여준다.



[그림 5.1] 큐의 구조



### 큐의 추상자료형

큐에 저장하는 자료에도 특별한 제한이 없다. 연산들은 스택과 매우 유사한데, 삽입과 삭제 연산의 이름이 각각 enqueue와 dequeue인 것만 다르다. 큐의 추상자료형을 정의하면 다음과 같다.


정의 5.1 Queue ADT

* 데이터 : 선입선출(FIFO)의 접근 방법을 유지하는 항목들의 모음
* 연산
    - Queue() : 비어있는 새로운 큐를 만든다.
    - **isEmpty()** : 큐가 비어있으면 True를 아니면 False를 반환한다.
    - **enqueue(x)** : 항목 x를 큐의 맨 뒤에 추가한다.
    - **dequeue()** : 큐의 맨 앞에 있는 항목을 꺼내 반환한다.
    - peek() : 큐의 맨 앞에 있는 항목을 삭제하지 않고 반환한다.
    - size() : 큐의 모든 항목들의 개수를 반환한다.
    - clear() : 큐를 공백상태로 만든다.

isEmpty()는 큐의 공백상태를 검사하고 peek(), size(), clear() 연산도 스택에서와 동일한 의미를 갖는다. 큐에서도 가장 중요한 연산은 삽입 연산인 enqueue()와 삭제 연산인 dequeue()이다. 물론 삽입은 후단을 통해서만, 삭제는 전단을 통해서만 가능하다. 다음은 큐에서 일련의 삽입과 삭제가 이루어지는 과정을 보여주는데, 자료가 큐에 들어온 순서대로 나가는 것을 알 수 있다.


[그림 5.2] 큐의 삽입과 삭제 연산 예시



### 큐는 어디에 사용할까?

일상생활에서 대부분의 일들이 먼저 들어온 순서대로 처리되는 것과 같이 컴퓨터에서도 큐는 매우 광범위하게 사용된다. 특히 컴퓨터에서 데이터를 주고받을 때 각 주변장치들 사이에 존재하는 속도의 차이나 시간차이를 극복하기 위한 임시 기억장치로 큐가 사용되는데, 이것을 **버퍼(Buffer)**라고 한다. 그림과 같이 서비스 콜 센터에서도 **콜 큐(Call Queue)**를 사용한다. 큐에 많은 요청이 들어있으면 고객은 기다려야 한다. 그러나 먼저 신청한 사람은 반드시 먼저 서비스를 받는다. 큐의 활용 분야를 알아보자.





* 컴퓨터와 프린터 사이에 **인쇄작업 큐**가 존재한다. 프린터는 CPU에 비해 상대적으로 속도가 느리다. 따라서 CPU는 빠른 속도로 인쇄 데이터를 만들어 프린터의 인쇄작업 큐에 보낸 다음 다른 작업으로 넘어간다. 프린터는 일정한 속도로 인쇄작업 큐에서 순서대로 데이터를 가져와 인쇄한다.
* 실시간 비디오 스트리밍에서 다운로드된 데이터가 비디오를 재생하기에 충분하지 않으면 큐에 순서대로 모아두었다가 충분한 양이 되었을 때 비디오를 복원하여 재생한다. 이것을 **버퍼링(Buffering)**이라고 한다.
* 컴퓨터로 현실세계를 **시뮬레이션**하는 분야에서도 큐가 폭넓게 사용된다. 예를 들어 은행에서 대기표를 뽑고 기다리는 고객들, 공항에서 활주로를 이용해 이륙하는 비행기들, 인터넷에서 전송되는 데이터 패킷들을 모델링하는데 큐가 이용된다. 이러한 시뮬레이션을 잘 활용하면 은행이나 공항 시스템을 최적화할 수 있고, 따라서 최소의 비용으로 최고의 수익을 올릴 수 있다.

큐도 프로그래머의 중요한 도구로서 폭넓게 이용되고 있다.



## 5.2 큐의 구현

### 선형 큐에는 어떤 문제가 있을까?

큐 항목들을 저장하는 가장 쉬운 방법은 배열구조인 파이썬의 리스트를 사용하는 것이다. 이 리스트의 이름을 items라 하자. 맨 처음에 이 리스트는 공백이 되어야 한다.

``` Python
items = []      # 큐 항목을 위한 리스트
```

이제 front와 rear를 결정해야 한다. 일단 리스트의 맨 앞을 front라 하고, 맨 뒤를 rear라 하자. 이렇게 되면 **front와 rear를 위한 변수를 따로 관리할 필요가 없다**. front의 인덱스는 항상 0이고, rear는 항상 len(items) - 1, 또는 -1이기 때문이다.

이제 연산들을 구현하자. 리스트를 사용하면 연산들은 매우 간단해진다. 연산은 먼저 함수로 구현하자.



#### isEmpty() : 공백상태 검사

큐가 공백상태이면 items는 빈 리스트가 된다. 스택에서와 같이 len() 함수를 이용해 구현하면 된다.

``` Python
def isEmpty():
    return len(items) == 0      # 리스트 항목수가 0이면 공백상태
```



#### enqueue(item) : 삽입 연산

삽입 연산은 rear에 항목을 추가하는 것이다. 따라서 리스트의 맨 뒤에 item을 삽입하면 된다. 리스트의 append() 메소드를 사용하면 간단히 구현된다.


``` Python
def enqueue(item):
    items.append(item)      # 리스트의 맨 뒤에 item 추가
```

대부분의 경우 append()는 상수 시간에 항목을 추가할 수 있다. 따라서 이 연산의 시간복잡도는 $O(1)$이다.


#### dequeue() : 삭제 연산

삭제 연산은 front에서 항목을 하나 꺼내고 이를 반환하면 된다. 리스트에서 맨 앞의 항목을 꺼내는 것은 리스트의 pop() 메소드를 사용하면 된다. 즉, items.pop(0)으로 리스트 items의 맨 앞의 항목을 추출할 수 있다. 물론 큐가 공백상태이면 삭제할 수 없으므로 공백상태를 먼저 검사해야 한다.

``` Python
def dequeue():
    if not isEmpty():           # 공백상태가 아니면
        return items.pop(0)     # 맨 앞 항목을 꺼내서 반환
```


이 연산의 시간복잡도는 어떻게 될까? 3.2절에서 공부한 바와 같이 리스트의 pop(0) 연산은 모든 항목들을 앞으로 1칸씩 당겨야 하므로 항목수에 비례하는 시간이 걸린다. 따라서 삭제연산의 복잡도는 $O(n)$이다.


[그림 5.3] 선형큐의 문제점 : 삭제연산(pop(0))의 시간복잡도가 $O(n)$이다.


스택에서도 비슷한 문제가 있었음을 기억하라. 스택에서는 스택 상단의 위치를 바꾸어 해결했다. 그러나 큐에서는 전단과 후단을 바꾼다고 해결되지 않는다. 둘 중 하나에서는 같은 문제가 발생하기 때문이다.



### 기타 연산들

peek는 front 항목을 반환하기만 하고, 큐는 건드리지 않는다.

``` Python
def peek():                 # 전단 항목을 삭제하지 않고 반환
    if not is Empty():
        return items[-1]
```


나머지 연산(size와 clear 등)들은 스택과 비슷하게 간단히 구현된다. 이러한 큐를 선형 큐라고 한다. **선형 큐**에서는 삽입과 삭제 연산의 시간복잡도를 모두 $O(1)$으로 만들 수 없다. 구현된 코드에서는 삭제연산의 시간복잡도가 $O(n)$이다. 삭제연산도 $O(1)$으로 동작하도록 구현할 수는 없을까?


### 원형 큐가 훨씬 효율적이다.

배열을 선형으로 생각하지 않고 원형으로 생각하면 선형 큐의 문제를 해결할 수 있다. 이것은 리스트의 맨 끝과 맨 앞을 연결하는 개념이다. 물론 실제로 리스트가 원형인 것은 아니고, 원형으로 생각하고 사용하는 것일 뿐이다.

원형 큐에서는 기본적으로 리스트의 크기가 고정되어야 한다. C언어의 배열과 같이 리스트에 항상 그림과 같이 고정된 크기(MAX_QSIZE)의 칸이 있다고 생각하자. 원형 큐에서는 front와 rear를 위한 변수가 필요하다. rear는 **큐에 가장 최근에 삽입된 항목의 위치**를 front는 **가장 최근에 삭제된 항목의 위치**를 저장한다. 맨 처음에는 front = rear = 0 이다. 삽입연산은 rear를 하나 증가시킨 후 그 위치에 항목을 넣는 것이다. 삭제연산도 front를 하나 증가시키고 그 위치의 항목을 반환하면 된다. 크기가 8인 원형 큐에서 삽입과 삭제 연산의 예는 다음과 같다.



[그림 5.4] 원형 큐의 삽입과 삭제 과정


중요한 것은 인덱스가 원형으로 움직인다는 것이다. 0부터 계속 증가하다가 MAX_QSIZE - 1이 되면 다음은 MAX_QSIZE가 아니라 다시 0이 되는 것이다. 그렇다면 front와 rear를 어떻게 원형으로 회전시킬까? 다음과 같이 나머지 연산자를 사용하면 간단하게 해결된다.

``` Python
front <- (front + 1) % MAX_QSIZE
rear  <- (rear  + 1) % MAX_QSIZE
```

삭제를 하더라도 선형 큐와 같이 항목들을 앞으로 하나씩 당길 필요가 없다. 삽입도 마찬가지이다. 인덱스만 변경된다. 따라서 **삽입과 삭제 연산이 모두 $O(1)$**이다.

마지막으로 큐의 상태를 살펴보자. **공백상태**는 **front == rear**인 경우이다. 이들이 반드시 0일 필요는 없다. **같은 곳을 가리키기만 하면** 공백상태이다.



[그림 5.5] 원형 큐의 3가지 상태



**포화상태**는 어떨까? 선형 큐에서는 포화상태를 정의하지 않았다. 필요한 만큼 리스트를 확장해 저장할 수 있었기 때문이다. 원형큐에서는 크기는 `MAX_QSIZE`로 고정하였으므로 리스트가 꽉 차서 더 이상 항목을 추가할 수 없는 포화상태가 발생할 수 있다. 그렇다면 어떤 경우가 포화상태일까? 그림 5.5의 (c)와 같은 상태를 생각하기 쉽지만 문제가 있다. (c)는 공백상태인 (a)와 구분이 안 된다. 즉, 모두 front == rear 이다. 따라서 원형 큐에서는 하나의 자리를 비워두는 전략을 사용한다. (b)와 같이 **front**가 **rear보다 하나 앞**에 있으면 포화상태라고 정의한다. 이것은 **front == (rear + 1) % MAX_QSIZE**인 상태를 의미한다.





### 원형 큐의 구현

원형 큐를 클래스로 정의하자. 이름은 CircularQueue로 한다. 항목들은 파이썬의 리스트에 저장하고, 크기는 MAX_QSIZE라 하자. 생성자에서 리스트인 items와 정수형 변수 front와 rear를 선언한다. 이때, items가 ```MAX_QSIZE```개의 항목을 이미 가지고 있어야 하는 것에 유의하라. 코드는 다음과 같다.


``` Python
MAX_QSIZE = 10                              # 원형 큐의 크기
class CircularQueue():                      
    def __init__(self):                     # CircularQueue 생성자
        self.front = 0                      # 큐의 전단 위치
        self.rear = 0                       # 큐의 후단 위치
        self.items = [None] * MAX_QSIZE     # 항목 저장용 리스트 [None, None, ...]
    
    # 공백상태와 포화상태 검사 및 초기화 연산은 다음과 같다.
    # 포화상태 검사를 위해 나머지 연산자를 사용해야 한다.
    def isEmpty(self):
        return self.front == self.rear

    def isFull(self):
        return self.front == (self.rear + 1) % MAX_QSIZE

    def clear(self):
        self.front = self.rear

    # 삽입, 삭제 및 peek 연산은 다음과 같다.
    # front와 rear를 원형으로 회전시키는 코드에 유의하라.
    def enqueue(self, item):
        if not self.isFull():
            self.rear = (self.rear + 1) % MAX_QSIZE
            self.items[self.rear] = item
        
    def dequeue(self):
        if not self.isEmpty():
            self.front = (self.front + 1) % MAX_QSIZE
            return self.items[self.front]
        
    def peek(self):
        is not self.isEmpty():
            return self.items[(self.front + 1) % MAX_QSIZE]
```

이 코드에서도 예외적인 경우에 대한 처리코드를 생략하였다. 예를 들어, 포화상태에서 enqueue()가 호출되거나(Overflow), 공백상태에서 dequeue()가 호출된(Underflow) 상황 등이 예외적인 상황이다.

현재 큐에 저장된 항목의 개수는 어떻게 구할까? rear-front로는 충분하지 않다. 왜냐하면 rear가 회전되어 front보다 작아질 수 있기 때문이다. 다음과 같이 큐의 크기 ```MAX_QSIZE```와 모듈러 연산을 이용해야 한다.

``` Python
    def size(self):
        return (self.rear - self.front + MAX_QSIZE) % MAX_QSIZE
```



아직 모두 끝난 것이 아니다. 큐의 내용을 출력하려면 어떻게 할까? 선형 큐는 front가 항상 0이므로 그냥 리스트를 출력하면 된다. 그러나 원형 큐는 다르다. front 다음 항목부터 rear 항목까지를 순서대로 출력해야 한다. 이를 위해 클래스에 display() 연산을 추가하자. 파이썬 리스트의 **슬라이싱** 기능을 이용하면 좀 더 쉽게 큐의 내용을 순서대로 출력할 수 있다. front와 rear가 뒤집히면 front 이후 MAX_QSIZE 전까지와 0부터 rear까지의 항목을 모아 출력하면 된다. 구현된 코드는 다음과 같다.




[그림 5.6] 원형 큐 출력의 2가지 경우




``` Python
def display(self):
    out = []
    if self.front < self.rear:                              # 슬라이싱
        out = self.items[self.front + 1 : self.rear + 1]    
    else:                                                   # 슬라이싱
        out = self.items[self.front + 1 : MAX_QSIZE] + self.items[0 : self.rear + 1] 
    print('[f = %s, r = %d] ==>' % (self.front, self.rear), out)
```

이 코드에서는 파이썬의 슬라이싱 기능과 리스트를 합하는 + 연산을 사용하였다. 예를 들어, 그림 5.6의 Case1에서 리스트 items는 다음과 같다.

``` Python
items = [None, None, 'B', 'C', 'D', None, None, None]
```

이때 슬라이싱을 이용한 items[front + 1 : rear + 1]은 items[2:5]와 같고, 이것은 리스트 ['B', 'C', 'D']가 된다. 또한 두 리스트의 + 연산도 가능하다. 그림의 Case2와 같은 상황에서 ['F'] + ['G', 'A', 'B']는 리스트 ['F', 'G', 'A', 'B']가 된다.

이제 원형 큐를 테스트해보자. 큐의 크기는 10으로 설정하였다. 인덱스의 회전이 잘 되는지를 보이기 위해 8번의 삽입, 5번의 삭제, 그리고 6번의 삽입연산을 실행하였다. 테스트 코드와 실행 결과는 다음과 같다.

``` Python
q = CircularQueue()         # 원형 큐 만들기 (MAX_QSIZE = 10)
for i in range(8):          # 0, 1, ..., 7 삽입 (f = 0, r = 8)
    q.enqueue(i)            
q.display()                 # 원형 큐에서 구현한 print() 호출
for i in range(5):
    q.dequeue()             # 5번 삭제 (f = 5, r = 8)
q.display()
for i in range(8, 14):      # 8, 9, ..., 13 삽입 (f = 5, r = 4)
    q.enqueue(i)
q.display()
```


이 코드에서 마지막 상태는 포화상태이다. 더 이상 항목을 추가할 수 없다. 이와 같이 구현된 원형 큐는 크기가 제한된다. 그렇지만 항목의 이동이 필요없으므로 삽입이나 삭제연산이 모두 $O(1)$으로 매우 효율적이다. 따라서 원형 큐를 사용할 때는 문제의 특성을 고려해서 큐의 크기를 충분히 크게 만들어 사용하는 것이 좋을 것이다.



## 5.3 큐의 응용 : 너비우선탐색

실생활에서와 마찬가지로 컴퓨터에서도 큐는 매우 광범위하게 사용된다. 이 책에서도 큐를 사용하는 응용들은 다음과 같이 다양하다.

* 이진트리의 레벨 순회를 위해 큐가 사용된다. (8장)
* 기수정렬에서 레코드의 정렬을 위해 큐가 사용된다. (12장)
* 그래프의 탐색에서 너비우선탐색을 위해 큐가 사용된다. (10장)


### 큐를 이용한 너비우선탐색

우리는 4장에서 스택을 이용한 깊이우선탐색에 의해 미로를 탈출하는 방법을 공부했다. 미로 탐색을 위해 너비우선탐색(BFS, Breadth First Search)을 사용할 수도 있다. 너비우선탐색은 출발점에서부터 인접한 위치들을 먼저 방문한 다음, 방문한 위치들에 인접한 위치들을 순서대로 찾아가는 방법이다. 이 과정은 출구를 찾거나 모든 위치를 방문할 때까지 계속된다. 깊이우선탐색이 하나의 경로를 선택해 끝까지 가보고 막히면 다시 다른 경로를 시도하는 것과 달리, 너비우선탐색은 가까운 위치부터 차근차근 찾아가는 전략을 사용한다. 이러한 전략은 미로탐색 뿐만 아니라 일반적인 그래프 탐색에서도 사용되는 매우 중요한 기법이다. 이러한 너비우선탐색을 위해서는 큐를 사용해야 한다. 다음은 너비우선탐색으로 미로를 탈출하는 과정과 큐의 변화를 보여준다.


[그림 5.7] 너비우선탐색에 의한 미로탐색 및 큐의 상태변화



너비우선탐색에 의한 미로탐색을 구현해보자. 깊이우선탐색과의 차이는 스택을 사용하느냐 큐를 사용하느냐 밖에 없다. 따라서 4.5절의 코드에서 스택을 큐로 바꾸고 관련 멤버함수의 이름만 수정하면 된다. isValidPos()는 4장의 함수를 그대로 사용한다. CircularQueue를 이용한 깊이우선탐색 코드는 다음과 같다.

``` Python
def BFS():                          # 너비우선탐색 함수
    que = CircularQueue()
    que.enqueue((0, 1))
    print('BFS:')                   # 출력을 'BFS'로 변경

    while not que.isEmpty():
        here = que.dequeue()
        print(here, end = '->')
        x, y = here
        if map[y][x] == 'x':
            return True
        else:
            map[y][x] = '.'
            if isValidPos(x, y - 1):        
                que.enqueue((x, y - 1))    # 상
            if isValidPos(x, y + 1):
                que.enqueue((x, y + 1))    # 하
            if isValidPos(x - 1, y):
                que.enqueue((x - 1, y))    # 좌
            if isValidPos(x + 1, y):
                que.enqueue((x + 1, y))    # 우
    return False
```

미로탐색 테스트 코드와 실행되는 결과는 다음과 같다.

``` Python
map = [['1', '1', '1', '1', '1', '1'],
       ['e', '0', '1', '0', '0', '1'],
       ['1', '0', '0', '0', '1', '1'],
       ['1', '0', '1', '0', '1', '1'],
       ['1', '0', '1', '0', '0', 'x'],
       ['1', '1', '1', '1', '1', '1']]

MAZE_SIZE = 6
result = BFS()
if result:
    print('--> 미로탐색 성공')
else:
    print('--> 미로탐색 실패')
```


### 파이썬의 queue 모듈은 큐와 스택 클래스를 제공한다.

파이썬에서는 큐 클래스를 모듈로 제공해준다. 큐를 사용하기 위해서는 다음과 같이 **queue 모듈**을 포함해야 한다.

``` Python
import queue    # 파이썬의 큐 모듈 포함
```

queue 모듈의 큐 클래스 이름은 **Queue**이다. 따라서 다음과 같이 새로운 큐 Q를 만들 수 있다. 이때, 생성될 큐의 최대크기를 키워드 인수 maxsize를 통해 지정할 수 있다. maxsize가 0인 것은 큐의 크기가 무한대라는 것이다.

``` Python
Q = queue.Queue(maxsize = 20)   # 큐 객체 생성(최대크기 20)
```

삽입과 삭제연산의 이름이 변경되었다. 삽입은 enqueue()가 아니라 put()이고, 삭제는 dequeue()가 아니라 get()을 사용해야 한다.

``` Python
for v in range(1, 10):
    Q.put(v)
print('큐의 내용 :', end = '')
for _ in range(1, 10):
    print(Q.get(), end = ' ')
print()
```

공백상태의 큐에 get() 연산을 수행하면 **언더플로우(Underflow)**가 발생한다. 마찬가지로 maxsize 이상의 항목을 put()하는 경우 **오버플로우(Overflow)**가 발생한다. **get()과 put() 함수는 언더플로우나 오버플로우가 발생하더라도 에러를 반환하지 않고, 단순히 무한루프에 빠지게 되는 것**에 유의하라. 따라서 이 연산을 처리하기 전에 empty()와 full()를 이용해 큐의 상태를 먼저 확인하는 것이 안전하다.

스택 클래스도 큐 모듈에서 제공하는 것에 유의하라. 클래스의 이름이 **LifoQueue**인 것을 제외하고 객체생성 방법이나 연산들은 큐와 동일하다.

``` Python
S = queue.LifoQueue(maxsize = 20)   # 스택객체 생성 (최대크기 20)
```

이제 스택이나 큐를 직접 구현할 필요없이 파이썬의 큐 모듈을 이용해 깊이우선탐색과 너비우선탐색을 구현할 수 있다. 실습문제 5.1에 도전하라.



## 5.4 덱이란?

### 덱은 스택이나 큐보다는 입출력이 자유로운 구조이다.

덱(deque)는 double-ended queue의 줄임말로서 큐의 전단(front)과 후단(rear)에서 모두 삽입과 삭제가 가능한 큐를 의미한다. 그렇지만 여전히 중간에 삽입하거나 삭제하는 것은 허용하지 않는다.

[그림 5.8] 덱의 구조



덱을 추상자료형으로 정의하면 다음과 같다.

정의 5.2 Deque ADT

* 데이터 : 전단과 후단을 통한 접근을 허용하는 항목들의 모음
* 연산
    - Deque() : 비어있는 새로운 덱을 만든다.
    - isEmpty() : 덱이 비어있으면 True를 아니면 False를 반환한다.
    - addFront(x): 항목 x를 덱의 맨 앞에 추가한다.
    - deleteFront() : 맨 앞의 항목을 꺼내서 반환한다.
    - getFront() : 맨 앞의 항목을 꺼내지 않고 반환한다.
    - addRear(x) : 항목 x를 덱의 맨 뒤에 추가한다.
    - deleteRear() : 맨 뒤의 항목을 꺼내서 반환한다.
    - getRear() : 맨 뒤의 항목을 꺼내지 않고 반환한다.
    - isFull() : 덱이 가득 차 있으면 True를 아니면 False를 반환한다.
    - size() : 덱의 모든 항목들의 개수를 반환한다.
    - clear() : 덱을 공백상태로 만든다.

덱은 스택과 큐의 연산들을 모두 가지고 있다.

* 덱의 addRear, deleteFront, getFront 연산은 각각 큐의 enqueue, dequeue, peek 연산과 정확히 동일하다.
* 덱의 후단(rear)을 스택의 상단(top)으로 사용한다면, 덱의 addRear, deleteRear, getRear 연산은 스택의 push, pop, peek 연산과 정확히 동일하다.




덱은 구조상 큐와 더 비슷하다. 따라서 원형 덱으로 구현하는 것이 연산들의 시간복잡도를 $O(1)$으로 만들 수 있는 좋은 방법이다. 주의해야 할 연산은 front와 rear를 감소시켜야 하는 deleteRear와 addFront이다. 다음 그림과 같이 인덱스를 감소시키는 것은 반대방향, 즉 반시계방향의 회전을 의미한다. front와 rear를 반대방향으로 회전시키는 코드는 다음과 같다.

``` Python
front <- (front - 1 + MAX_QSIZE) % MAX_QSIZE
rear  <- (rear  - 1 + MAX_QSIZE) % MAX_QSIZE
```


[그림 5.9 원형 덱의 삽입/삭제 연산 예]



## 5.5 덱의 구현

### 원형 큐를 상속하여 원형 덱 클래스를 구현하자.

상속이 나온다고 겁먹을 필요는 없다. 상속은 대표적인 객체지향 프로그래밍 기법으로 코드 재사용을 극대화할 수 있다. 이것은 매우 짧은 코드만으로도 기존의 복잡한 클래스에 기능을 추가한 새 클래스를 만드는 멋진 방법이다.

앞에서 구현한 원형 큐 클래스 CircularQueue를 상속하여 새로운 원형 덱 클래스 CircularDeque를 만들어보자. 많은 기능들이 이미 CircularQueue에서 구현되었기 때문에 CircularDeque 클래스에서 작성해야 할 코드는 많지 않을 것이다. 2.12절의 상속을 참조하라. CircularQueue를 상속하여 CircularDeque 클래스를 만드는 문법은 다음과 같다.

``` Python
class CircularDeque(CircularQueue):     # CircularQueue에서 상속

    def __init__(self):                 # CircularDeque 생성자
        super().__init__()              # 부모 클래스의 생성자를 호출함.

    
    def addRear(self, item):            # enqueue 호출
        self.enqueue(item)

    def deleteFront(self):              # 반환에 주의
        return self.dequeue()

    def getFront(self):                 # 반환에 주의
        return self.peek()


    def addFront(self, item):               # 새로운 기능 : 전단 삽입
        if not self.isFull():
            self.items[self.front] = item   # 항목 저장
            self.front = self.front - 1     # 반시계 방향으로 회전
            if self.front < 0:
                self.front = MAX_QSIZE - 1

    def deleteRear(self):                   # 새로운 기능 : 후단 삭제
        if not self.isEmpty():
            item = self.items[self.rear]    # 항목 복사
            self.rear = self.rear - 1       # 반시계 방향으로 회전
            if self.rear < 0:
                self.rear = MAX_QSIZE - 1
        return item                         # 항목 반환

    def getRear(self):                      # 새로운 기능 : 후단 peek
        return self.items[self.rear]

```

상속을 하면 **자식 안에 부모가 들어있는** 것과 같다. 따라서 이 클래스는 이미 많은 기능(부모 클래스에서 정의된 멤버변수와 메소드)을 갖고 있다. 그러나 **생성자는 상속되지 않는다**. 따라서 자식 클래스에서 다시 정의해야 한다.

* 자식클래스에서 부모를 부르는 함수가 **super()**이다.
* **생성자에서 front, rear, items와 같은 변수를 선언하지 않은 것**에 유의하라. 이들은 부모 클래스의 데이터 멤버로 이미 자식 클래스에 들어있다. 따라서 self.front와 같이 바로 사용하면 된다.
* 부모 클래스의 멤버들은 super() 함수를 통해서도 사용할 수 있다. 예를 들어, super().front는 self.front와 동일하다.
* 생성자는 예외이다. 자식에도 생성자가 있고 부모도 생성자가 있으므로 부모의 생성자를 구분하여 호출하기 위해서는 반드시 ```super().__init__()``` 과 같이 기술해야 한다.
* isEmpty, isFull, size, clear와 같이 부모에서 구현된 연산들도 클래스에 구현되어 있다고 생각하고 그냥 사용하기만 하면 된다. 예를 들어, 공백상태의 검사가 필요하면 self.isEmpty()를 호출하면 된다. **코드를 재사용**하는 것이다.


그렇다면 자식 클래스에는 어떤 코드를 넣어야 할까? 자식에서만 필요한 연산들을 구현하면 된다. 먼저 이미 큐에 있는 기능이지만 이름이 바뀌는 연산들(addRear, deleteFront, getFront)을 생각해보자. 이들은 이미 "구현"이 되어 있으므로 **인터페이스**만 잘 만들어주면 된다. 즉, 위와 같이 부모의 해당 메소드를 적절히 호출해주면 끝이다.

이제 덱에만 있는 기능들을 구현해보자. addFront와 deleteRear는 반대 방향의 회전에만 신경을 써주면 된다. getRear는 현재 rear가 가리키는 항목을 반환하면 된다.

생성자와 6개의 메소드만을 구현했지만 이 클래스는 이미 덱 ADT에서 정의한 모든 기능을 갖고 있다. 즉 클래스의 구현이 끝난 것이다.

이제 만들어진 덱을 활용해보자. 다음 코드는 덱 객체를 생성하고, 0~8의 숫자들 중에서 홀수는 전단에, 짝수는 후단에 삽입한다. 전단에서 2번, 후단에서 3번의 삭제를 하고, 마지막으로 전단에 5번의 삽입을 하였다.

``` Python
dq = CircularDeque()        # 덱 객체 생성, f = r = 0
for i in range(9):          # i : 0, 1, 2, ..., 8
    if i % 2 == 0:          
        dq.addRear(i)       # 짝수는 후단에 삽입
    else:                   
        dq.addFront(i)      # 홀수는 전단에 삽입
dq.display()                # front = 6, rear = 5
for i in range(2):
    dq.deleteFront()        # 전단에서 2번의 삭제 : f = 8
for i in range(3):
    dq.deleteRear()         # 후단에서 3번의 삭제 : r = 2
dq.display()
for i in range(9, 14):      # i : 9, 10, ..., 13 : f = 3
    dq.addFront(i)
dq.display()
```

화면 출력도 큐 클래스의 display()를 그대로 사용했다. 결과는 다음과 같다.



구현된 덱의 시간복잡도를 생각해보자.

* 이름만 바뀌는 연산들(addRear, deleteFront, getFront)은 이미 큐에서 모두 $O(1)$임을 확인하였다.
* getRear는 명백히 $O(1)$이다.
* 새로 추가한 삽입연산 addFront와 삭제연산 deleteRear에서도 항목의 이동을 발생시키지 않고, 인덱스만 변경하면 된다. 따라서 시간복잡도는 $O(1)$이다.

이 책에서는 상속을 많이 사용하지 않는다. (9.4절에서만 한번 더 사용함) 따라서 어려우면 넘어가도 좋다. 그렇지만 상속은 매우 효과적이고 강력한 방법이므로 관심을 갖고 활용해보는 것을 권장한다.




## 5.6 우선순위 큐

소방차나 구급차와 같은 긴급 차량들은 도로교통법에 의해 높은 우선순위를 갖기 때문에 일반 차량들은 도로에 먼저 진입했더라도 이들이 나타나면 길을 양보해야 한다. 컴퓨터에서도 우선순위의 개념이 필요할 때가 종종 있는데, 예를 들어, 운영체제에서 시스템 프로세스는 응용 프로세스보다 더 높은 우선순위를 갖는다. 우선순위 큐는 이러한 **우선순위의 개념을 큐에 도입한 자료구조**이다. 보통의 큐는 먼저 들어온 데이터가 먼저 나가는 구조(FIFO)인데 비해, **우선순위 큐(Priority Queue)**는 모든 데이터가 우선순위를 가지고 있고, 들어온 순서와 상관없이 **우선순위가 높은 데이터가 먼저 출력**되는 구조이다.

우선순위 큐는 사실 가장 일반적인 큐로 볼 수 있는데, 이것은 "우선순위"를 어떻게 정하느냐에 따라 스택이나 큐로도 얼마든지 사용할 수 있기 때문이다. 이러한 우선순위 큐는 시뮬레이션이나 네트워크 트래픽 제어, 운영체제에서의 작업 스케줄링, 수치해석적인 계산 등 다양한 분야에서 활용되고 있다.


### 우선순위 큐 추상자료형

우선순위 큐는 우선순위를 갖는 요소들의 모임이다. 연산은 큐와 동일하다. 우선순위 큐에서도 가장 중요한 연산은 삽입과 삭제이다. 삭제 연산에서 어떤 요소가 먼저 삭제되는가에 따라 **최대 우선순위 큐**와 **최소 우선순위 큐**로 나누어지지만, 특별한 언급이 없으면 우선순위 큐는 가장 높은 우선순위의 요소가 먼저 삭제되는 최대 우선순위 큐를 의미한다. 다음은 우선순위 큐의 추상자료형이다.


정의 5.3 Priority Queue ADT

* 데이터 : 우선순위를 가진 요소들의 모음
* 연산
    - PriorityQueue() : 비어있는 우선순위 큐를 만든다.
    - isEmpty() : 우선순위 큐가 공백상태인지를 검사한다.
    - **enqueue(e)** : **우선순위를 가진 항목 e를 추가**한다.
    - **dequeue()** : **가장 우선순위가 높은 항목을 꺼내서 반환**한다.
    - peek() : 가장 우선순위가 높은 요소를 삭제하지 않고 반환한다.
    - size() : 우선순위 큐의 모든 항목들의 개수를 반환한다.
    - clear() : 우선순위 큐를 공백상태로 만든다.


다음은 공백상태의 우선순위 큐에 우선순위가 34, 18, 27, 45, 15인 항목을 삽입한 후 몇 번의 삭제 연산을 하는 과정을 보여주고 있다. 항목의 삽입 순서와는 상관없이 삭제 순서는 45, 34, 27, 18이다. 즉, 현재 남은 항목들 중에서 가장 우선순위가 높은 항목 순이다.


[그림 5.10] 우선순위 큐의 삽입과 삭제 연산


그림에서 항목들이 일렬로 나열되어 있지 않음에 유의하라. 우선순위 큐는 한 순간에 가장 우선순위가 높은 항목만 알 수 있으면 된다. 나머지 자료를 순서대로 정렬하고 있을 필요는 없다. 따라서 선형자료구조로 보기는 어렵다. 실제로 가장 효율적인 우선순위 큐의 구현 방법은 트리 구조를 사용하는 힙(Heap)이다. 힙 트리를 이용한 우선순위 큐는 8장에서 다룬다.


### 정렬되지 않은 배열을 이용한 우선순위 큐의 구현

우선순위 큐를 구현하는 가장 좋은 방법은 힙 트리를 이용하는 것이지만, 이 장에서는 보다 간단한 방법으로 우선순위 큐를 구현해보자. 리스트를 이용하는 것이다. 리스트를 사용하더라도 정렬의 개념을 이용해 항목들을 우선순위 순으로 저장할 수도 있고, 정렬하지 않고 저장할 수도 있다. 여기서는 정렬하지 않은 리스트를 이용한다.

우선순위 큐를 클래스로 구현해보자. 클래스의 이름은 PriorityQueue라 한다. 큐 항목들은 배열구조에 저장한다. 공백상태 검사와 크기 반환, 초기화 등의 연산은 스택이나 큐를 구현할 때와 거의 비슷하다. 코드는 다음과 같다.

``` Python
# Python list를 이용한 Priority Queue ADT 구현
class PriorityQueue():
    def __init__(self):                 # 생성자
        self.items = []                 # 항목 저장을 위한 리스트 초기화

    def isEmpty(self):
        return len(self.items) == 0     # 공백상태 검사
    
    def size(self):                 
        return len(self.items)          # 전체 항목의 개수
    
    def clear(self):
        self.items = []                 # 초기화

    def enqueue(self, item):            # 삽입 연산
        self.items.append(item)         # 리스트의 맨 뒤에 삽입(O(1))

```

단순화를 위해 데이터 자체가 우선순위를 나타낸다고 가정한다. 일반적으로는 (**데이터**, **우선순위**) 형식의 튜플 구조가 바람직한데, 이것은 다음 절에서 다룬다.

이제 삽입 연산을 생각해보자. 리스트를 정렬하지 않으므로 새로운 항목은 리스트의 맨 뒤에 추가하면 된다.

여기까지는 오히려 큐보다 더 쉽다. 큐에서는 효율성을 위해 원형 큐라는 약간 복잡한 방법을 사용하였지만, 우선순위 큐에서는 이렇게 할 필요가 없다. 문제는 삭제 연산이다. 우선순위 큐에서 삭제는 항상 **우선순위가 가장 높은 항목**이라는 것을 명심하라. 이 항목을 찾는 과정이 먼저 필요하다. 이 과정은 findMaxIndex()란 메소드로 구현하자. 우선순위 큐의 모든 항목을 검사해서 가장 우선순위가 높은 항목의 인덱스를 반환하는 함수는 다음과 같다.

``` Python
def findMaxIndex(self):                     # 최대 우선순위 항목의 인덱스 반환
    if self.isEmpty():
        return None
    else:
        highest = 0                         # 0번을 최대라고 하고 시작
        for i in range(1, self.size()):     # 모든 항목에 대해
            if self.items[i] > self.items[highest]:
                highest = i                 # 최고 우선순위 인덱스 갱신
        return highest                      # 최고 우선순위 인덱스 반환
```


이 함수를 이용해 삭제 연산과 peek() 연산을 다음과 같이 구현할 수 있다.

``` Python
    def dequeue(self):                      # 삭제 연산
        highest = self.findMaxIndex()       # 우선순위가 가장 높은 항목
        if highest is not None:
            return self.items.pop(highest)  # 리스트에서 꺼내서 반환

    def peek(self):                         # peek 연산
        highest = self.findMaxIndex()       # 우선순위가 가장 높은 항목
        if highest is not None:
            return self.items[highest]      # 꺼내지 않고 반환
```

dequeue()와 peek()의 차이는 최고 우선순위 항목을 리스트에서 꺼내느냐 그렇지 않느냐이고, 나머지는 동일하다. 테스트 프로그램은 다음과 같다. 일련의 숫자를 enqueue한 다음 일련의 dequeue 연산을 통해 가장 큰 값이 순서대로 나오는지 확인한다.

``` Python
q = PriorityQueue()
q.enqueue(34)
q.enqueue(18)
q.enqueue(27)
q.enqueue(45)
q.enqueue(15)

print('PQueue :', q.items)
while not q.isEmpty():
    print('Max Priority =', q.dequeue())
```


### 시간복잡도

시간복잡도는 어떻게 될까?

* 삽입 연산은 리스트의 append() 메소드를 이용하는데, 이 연산의 시간복잡도가 **대부분의 경우** $O(1)$이므로 enqueue()도 $O(1)$이라 볼 수 있다.
* 삭제와 peek 연산에서는 리스트에서 최대 우선순위 항목의 인덱스를 찾기 위해 findMaxIndex()를 호출하였다. 이 연산은 당연히 우선순위 큐의 모든 항목의 우선순위를 비교해야 한다. 따라서 시간복잡도는 $O(n)$이다. 따라서 이 함수를 호출하는 dequeue()와 peek()의 시간복잡도도 $O(n)$이다. dequeue()에서는 삭제하는 위치 이후의 모든 항목들을 앞으로 이동하는 작업이 추가로 필요하고, 이 연산도 $O(n)$이다. 결국 삭제 연산의 시간복잡도는 $O(n)$이다.

만약 리스트를 정렬해서 관리한다면 어떻게 될까?

* 삭제 연산이 매우 쉬워진다. 가장 우선순위가 높은 항목의 위치가 항상 정해져 있기 때문이다. 시간복잡도는 $O(1)$이다.
* 반대로 삽입 연산은 복잡해진다. 무조건 맨 뒤에 추가하는 것이 아니라 항목들의 우선순위를 비교해 자신의 들어가야 할 자리를 찾아야 하기 때문이다. 따라서 삽입 연산의 시간복잡도는 $O(n)$이다.

일반적으로 우선순위 큐는 힙이라는 트리 구조를 이용해 구현한다. 삽입과 삭제 연산이 모두 $O(log_2 n)$으로 매우 뛰어나기 때문이다. 이 구조는 8장에서 공부한다.


## 5.7 우선순위 큐의 응용 : 전략적인 미로 탐색

약간은 더 지능적인 전략을 사용해보자. 출구의 위치를 미리 알고 있다고 생각하면 중간에 저장되는 위치들 중에서 출구와의 거리가 가장 가까운 곳부터 다시 시도해보면 어떨까? 물론 이 방법이 최선이라는 보장은 없다. 그렇지만 무턱대고 허둥대는 것이 아니라 뭔가 "개념"있게 움직인다는 것이 좋아보인다.






경로의 저장을 위해 우선순위 큐를 사용한다. 현재 좌표 $(x, y)$에서 출구까지의 거리를 $d$라고 하면, $d$가 우선순위를 결정하도록 한다.

* 우선순위 큐에는 $(x, y, -d)$ 형태의 튜플을 저장하도록 한다.
* $(x, y)$는 현재 좌표이고, $-d$는 우선순위 값이다. 거리를 음수로 저장한 것은 거리가 가까울수록 더 우선순위가 높아야하기 (더 큰 값이 되어야 하기) 때문이다.

현재 위치에서 갈 수 있는 모든 위치를 $(x, y, -d)$의 형태로 우선순위 큐에 저장하고, 큐에 저장된 여러 가능한 위치 중에서 우선순위가 가장 높은 위치, 즉 출구와 가장 가까운 위치에서 다시 시작하면 된다. 이것을 구현해보자.

먼저 $(x, y)$에서 출구까지의 거리를 계산하는 함수 dist()를 구현한다. 다음 코드와 같이 math 모듈에 있는 sqrt() 함수를 이용하면 두 지점 사이의 거리(Euclidean Distance)를 계산할 수 있다. 

``` Python
import math                                 # math 패키지를 사용함.
(ox, oy) = (5, 4)                           # 출구의 위치

def dist(x, y):                             # 출구 (ox, oy)로부터 거리계산 함수
    (dx, dy) = (ox - x, oy - y)
    return math.sqrt(dx * dx + dy * dy)     # (x, y)와 (ox, oy)의 유클리디안 거리
```

우선순위 큐 클래스는 4.5절에서 구현한 것을 사용할 수 있다. 그렇지만 최대 우선순위 항목의 인덱스를 구하는 함수는 다음과 같이 수정되어야 한다. 항목이 $(x, y, -d)$의 형태이므로 튜플의 마지막 요소를 이용해 최고 우선순위 항목을 찾아야 한다.

``` Python
def findMaxIndex(self):                     # 최대 우선순위 항목의 인덱스 반환
    if self.isEmpty():
        return None
    else:
        highest = 0                         # 0번을 최대라고 하고
        for i in range(1, self.size()):     # 모든 항목에 대해
            if self.item[i][2] > self.items[highest][2]:
                highest = i                 # 최고 우선순위 인덱스 갱신
        return highest                      # 최고 우선순위 인덱스 반환
```

전체적인 탐색 알고리즘은 4.7절의 코드와 크게 차이가 없다. 차이가 있는 부분은 큐 대신에 우선순위 큐 객체를 사용하는 것과, 큐에 삽입하는 항목의 형태가 $(x, y)$가 아니라 $(x, y, -d)$가 되도록 하는 것이다. $d$를 계산하기 위해 앞에서 구현한 dist() 함수를 이용한다.

``` Python
def MySmartSearch():
    q = PriorityQueue()
    q.enqueue((0, 1, -dist(0, 1)))
    print('PQueue: ')

    while not q.isEmpty():
        here = q.dequeue()
        print(here[0:2], end = '->')
        x, y, _ = here
        if map[y][x] == 'x':
            return True
        else:
            map[y][x] = '.'
            if isValidPos(x, y - 1):
                q.enqueue((x, y - 1, -dist(x, y - 1)))
            if isValidPos(x, y + 1):
                q.enqueue((x, y + 1, -dist(x, y + 1)))
            if isValidPos(x - 1, y):
                q.enqueue((x - 1, y, -dist(x - 1, y)))
            if isValidPos(x + 1, y):
                q.enqueue((x + 1, y, -dist(x + 1, y)))
        print('우선순위 큐 :', q.items)
    return False
```

실행결과는 다음과 같다. 현재 탐색하는 위치와 우선순위 큐의 내용을 모두 출력하고 있다. 현재 우선순위 큐에서 가장 가까운 거리의 위치가 바로 다음에 탐색되는 것을 확인하라.



결과를 보면 이 방법이 DFS나 BFS보다 더 빨리 출구를 찾았다. 물론 이것도 미로의 형태에 따라 항상 그렇지는 않다. 그러나 나름대로 괜찮은 "전략"을 세우고 그 전략대로 출구를 찾았다는데서 의미가 있다.


### 우선순위 큐의 주요 응용

우선순위 큐의 응용은 매우 다양하다. 특히 미로탐색에서와 같이 여러 후보들 중에서 가장 우선순위가 높은 몇 개를 선택하는데 탁월하다. 우선순위 큐의 주요 응용들은 다음과 같다.

* 압축을 위한 **허프만 코딩 트리**를 만드는 과정에 우선순위 큐를 사용한다. 빈도가 가장 작은 두 노드를 선택하기 위해서이다. (8.6절)
* **Kruskal의 최소비용 신장트리 알고리즘**에서 우선순위 큐를 사용할 수 있다. 최소비용 신장트리에 포함되지 않은 간선들 중에서 가중치가 가장 작은 간선을 반복적으로 선택하기 위해서이다. (11.3절)
* **Dijkstra의 최단거리 알고리즘**에서 우선순위 큐를 사용할 수 있다. 최단거리가 찾아지지 않은 정점들 중에서 가장 거리가 가까운 정점을 선택하기 위해서이다. (11.4절)
* 인공지능의 **$A^{\ast}$ 알고리즘**에서 우선순위 큐를 사용할 수 있다. $A^{\ast}$ 알고리즘은 **상태공간트리(State Space Tree)**를 이용해서 해를 찾는 과정에서 가장 가능성이 높은 (Promising) 경로를 먼저 선택하여 시도해보기 위해서이다.

---
