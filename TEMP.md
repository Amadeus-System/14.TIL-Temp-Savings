

* Date : 2022-07-03
* Last Modified At : 2022-07-03


# Chapter 10. Graph


## 10.1 그래프란?

### 그래프는 가장 일반화된 자료구조이다.

그래프(Graph)는 연결된 객체들 사이의 관계를 표현할 수 있는 자료구조이다. 지하철 노선도는 대표적인 그래프의 예로 많은 지하철역들이 서로 어떻게 연결되어 있는지를 알려주는데, 이것을 이용해 약속한 지하철 역으로 가는 최단경로를 찾을 수도 있다. 항공 노선도는 도시들이 항공편으로 어떻게 연결되어 있는지를 확인할 수 있으며, 전기회로도 그래프로 표현되는데, 각 소자들의 연결 관계를 확인할 수 있다. 최근 딥러닝 분야에서도 학습과 인식을 위한 데이터의 흐름을 그래프로 나타내는 방법이 흔히 사용된다.

이러한 문제들은 공통적으로 다양한 **객체들이 서로 복잡하게 연결되어 있는 구조**를 갖는다. 그래프는 이런 구조를 표현할 수 있는 훌륭한 논리적 도구이다. 사실 지금까지 공부했던 선형자료구조들이나 트리도 그래프로 표현될 수 있기 때문에 그래프의 한 종류로 볼 수 있다. 따라서 그래프는 가장 일반화된 자료구조이다.

[그림 10.1] 그래프의 다양한 활용 분야


#### 그래프 이론

그래프와 관련된 다양한 문제를 연구하는 학문 분야를 **그래프 이론(Graph Theory)**이라 부르는데, 컴퓨터 분야의 활발한 연구주제 중 하나이다. 그래프는 수학자 오일러(Euler)에 의해 처음 창안되었다. 그는 다음 그림과 같은 지형에서 "**모든 다리를 한번만 건너서 출발했던 장소로 돌아올 수 있는가?**"라는 문제가 답이 없다는 것을 그래프 이론을 통해 증명하였다. 오일러는 이 문제에서 핵심적이고 중요한 것은 "A, B, C, D의 **위치**가 어떤 **관계**로 연결되었는가?" 라고 생각하고, "위치"라는 객체는 **정점(Vertex)**으로, 위치간의 관계인 "다리"는 **간선(Edge)**으로 표현하여 그림의 오른쪽과 같은 그래프 문제로 변환하였다.

[그림 10.2] 모든 다리를 한번만 건너 돌아오는 오일러 문제에 대한 그래프 표현

오일러는 그래프에 존재하는 모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로를 **오일러 경로(Eulerian Tour)**라 정의하고, 그래프의 **모든 정점에 연결된 간선의 개수가 짝수일 때만 오일러 경로가 존재**한다는 **오일러의 정리**를 증명하였다. 따라서 그림의 그래프는 오일러의 정리에 의해 오일러 경로가 존재하지 않는다는 것을 복잡한 시행착오를 거치지 않고도 손쉽게 알 수 있다.

그래프는 **정점**과 **간선**의 집합으로 구성되는데, 정점은 **노드(Node)**, 간선은 **링크(Link)**라고도 불린다. 수학적으로 그래프는 $G = (V, E)$와 같이 표시하는데, $V(G)$는 그래프 $G$의 정점들의 집합을, $E(G)$는 그래프 $G$의 간선들의 집합을 의미한다. 정점은 객체(Object)를 의미하고, 간선은 이러한 객체들 간의 관계를 의미하는데, 정점 $A$와 정점 $B$를 연결하는 간선은 $(A, B)$와 같이 정점의 쌍으로 표현한다.

[제목없는 그림1]


그래프는 그림으로 표현하기도 하지만 시각적인 형태가 그래프의 정의는 아니다. 예를 들어, 다음 그림의 두 그래프는 시각적으로는 서로 다르게 보이지만 실제로는 동일한 그래프를 나타낸다. 같은 객체들을 가지고, 객체들 간의 관계도 정확히 일치하기 때문이다. 즉, 그래프는 오직 정점과 간선의 집합이며, 그래프의 시각적 표현은 이해를 돕는 역할만을 하는 것을 명심하라.

[그림 10.3] 시각적으로는 다르게 보이지만 동일한 두 그래프



### 그래프의 종류

* 무방향 그래프(Undirected Graph)
    **간선에 방향이 표시되지 않은 그래프**를 말한다. 하나의 간선은 양방향으로 갈 수 있는 길을 의미하는데, 따라서 $(A, B)$와 $(B, A)$는 동일한 간선이다. 그림의 $G1$과 $G2$는 무방향 그래프의 예인데, 다음과 같이 정점과 간선의 집합으로 표현된다.
    
    - $V(G1) = \{A, B, C, D\}$
    - $E(G1) = \{(A, B), (A, C), (A, D), (B, C), (C, D)\}$
    - $V(G2) = \{A, B, C, D\}$
    - $E(G2) = \{(A, B), (A, C)\}$
* 방향 그래프(Directed Graph)
    **간선에 방향성이 존재**하는 그래프를 말한다. 간선은 화살표로 표시되는데, 일방통행 도로와 같이 **한쪽 방향으로만 갈 수 있다**. $<A, B>$는 정점 $A$에서 정점 $B$로만 갈 수 있는 간선을 의미하는데, 따라서 **$<A, B>$와 $<B, A>$는 서로 다른 간선**이다. 그림의 방향 그래프는 다음과 같이 표현된다.
    
    - $V(G3) = \{A, B, C\}$
    - $E(G3) = \{<A, B>, <B, A>, <B, C>\}$
* 가중치 그래프(Weighted Graph)
    **간선에 비용이나 가중치가 할당된 그래프**를 말하는데, 네트워크(Network)라고도 한다. 간선이 두 정점간의 연결 유무뿐만 아니라 연결강도까지 나타낼 수 있어 보다 복잡한 관계를 표현할 수 있다. 다음 그림은 가중치 그래프의 예를 보여주는데, 도시와 도시를 연결하는 도로의 길이나 이동시간, 통신망의 사용료 등을 추가로 표현할 수 있어 응용분야가 광범위하다. 다음 장에서 가중치 그래프와 응용들을 다룬다.

    [그림 10.4] 가중치 그래프의 예 : 정점은 도시를, 간선은 이동비용을 나타냄
* 부분 그래프(Subgraph)
    그래프 $G$를 구성하는 정점의 집합인 $V(G)$와 간선의 집합인 $E(G)$의 부분집합으로 이루어진 그래프를 $G$의 **부분 그래프**라 한다. 다음은 그래프 $G1$에 대한 몇가지 부분 그래프를 보여주고 있다.

    [제목없는 그림 2]



### 그래프 용어

* 인접 정점(Adjacent Vertex)
    **간선에 의해 직접 연결된 정점**을 말한다. 그래프 $G1$에서 정점 $B$의 인접 정점은 $A$와 $C$이다.
* 정점의 차수(Degree)
    그 **정점에 연결된 간선의 수**를 말한다. 무방향 그래프에서는 정점에 인접한 정점의 수를 말하는데, $G1$의 정점 $A$는 차수가 3이다. 모든 정점의 차수를 합하면 간선 수의 2배가 되는데, 하나의 간선이 2개의 정점에 인접하기 때문이다. 방향 그래프에서는 정점의 차수가 2가지로 나누어진다. 외부에서 오는 간선의 수를 **진입 차수(In-Degree)**라 하고, 그 정점에서 외부로 향하는 간선의 수를 **진출 차수(Out-Degree)**라 한다. 예를 들어, 방향 그래프 $G3$에서 정점 $B$는 진입 차수가 1, 진출 차수가 2이다. 방향 그래프에서 정점의 진입 차수 또는 진출 차수의 합은 간선의 수와 같다. 예를 들어, $G3$의 간선의 수는 진입차수의 합이나 진출차수의 합과 같은 3이다.
* 경로(Path)
    **간선을 따라 갈 수 있는 길**을 말하며, 정점의 나열로 표시된다. 무방향 그래프에서 정점 s로부터 정점 e까지의 경로는 $s, v_1, v_2, ..., v_k, e$로서, 나열된 정점들 간에는 반드시 간선 $(s, v_1), (v_1, v_2), ..., (v_k, e)$가 존재해야 한다. 만약 방향 그래프라면 $<s, v_1>, <v_1, v_2>, ..., <v_k, e>$가 있어야 한다. 예를 들어, 그래프 $G1$에서 $A, B, C, D$는 경로지만 $A, B, D, C$는 경로가 아니다. 왜냐하면 간선 $(B, D)$가 존재하지 않기 때문이다.
* 경로의 길이
    경로를 구성하는데 사용된 간선의 수를 말한다.
* 단순경로(Simple Path)와 사이클(Cycle)
    **경로 중에서 반복되는 간선이 없는 경로**를 **단순경로**라 한다. 그리고 단순경로의 시작 정점과 종료 정점이 같다면 이러한 경로를 **사이클**이라 한다. 그래프 $G1$에서 경로 $B, A, C, D$는 단순경로이고, 경로 $B, A, C, A$는 단순경로가 아니다. 또한, 경로 $B, A, C, B$는 사이클이 된다. 또 방향 그래프 $G3$에서 경로 $A, B, A$도 사이클이 된다.

    [제목없는 그림 3]
* 연결 그래프(Connected Graph)
    **모든 정점들 사이에 경로가 존재**하는 그래프를 **연결 그래프**라 부른다. 이 그래프에는 따로 떨어진 정점이 없이 모든 정점들이 연결되어 있다. 그렇지 않은 그래프는 **비연결 그래프**라고 한다.
* 트리(Tree)
    **사이클을 가지지 않는 연결 그래프**를 말한다. 연결 그래프에서 사이클이 없으면 그래프의 임의의 두 정점을 연결하는 경로는 오직 하나뿐이다. 만약 2개의 경로가 존재한다면 이들에 의해 사이클이 형성되기 때문이다.
* 완전 그래프(Complete Graph)
    **모든 정점 간에 간선이 존재하는 그래프**를 말한다. 무방향 완전 그래프의 정점 수를 $n$이라고 하면, 하나의 정점은 $n-1$개의 다른 정점으로 연결되므로 간선의 수는 $nx(n-1)/2$가 된다. 만약 완전 그래프에서 $n=4$라면 간선의 수는 $(4\times3)/2 = 6$이다.

    [제목없는 그림 4]



### 그래프의 추상자료형

그래프는 정점과 간선의 집합이다. 추상자료형을 정의해보자.

정의 10.1 Graph ADT

* 데이터 : 정점과 간선의 집합
* 연산
    - isEmpty() : 그래프가 공백상태인지 확인한다.
    - countVertex() : 정점의 수를 반환한다.
    - countEdge() : 간선의 수를 반환한다.
    - getEdge(u, v) : 정점 u에서 정점 v로 연결된 간선을 반환한다.
    - degree(v) : 정점 v의 차수를 반환한다.
    - adjacent(v) : 정점 v에 인접한 모든 정점의 집합을 반환한다.
    - insertVertex(v) : 그래프에 정점 v를 삽입한다.
    - insertEdge(u, v) : 그래프에 간선 (u, v)를 삽입한다.
    - deleteVertex(v) : 그래프의 정점 v를 삭제한다.
    - deleteEdge(u, v) : 그래프의 간선 (u, v)를 삭제한다.

만약 방향 그래프라면 차수를 반환하는 degree 연산에 degree(v, **out**)과 같이 진입차수와 진출차수를 구분하는 매개변수가 추가되어야 할 것이다.

그래프에 정점을 추가하려면 insertVertex 연산을 사용하고 삭제하려면 deleteVertex를 사용할 수 있다. 그러나 하나의 정점이 삭제되면 그와 연결된 모든 간선들도 함께 삭제되어야 하는 것에 유의하라.

간선의 삽입과 삭제에는 insertEdge와 deleteEdge 연산을 사용하는데, 간선이 삭제되더라도 정점에는 변화가 없다. 간선은 2개의 정점을 이용해 표현되기 때문에 삽입을 위해서는 그래프에 반드시 두 정점이 정의되어 있어야 한다.

그래프는 다양한 방법으로 표현될 수 있다. 그리고 그래프를 어떻게 표현하는가에 따라 이들 연산을 위한 시간복잡도가 달라질 수 있다. 그래프의 다양한 표현 방법을 살펴보자.



## 10.2 그래프의 표현

### 인접행렬을 이용한 표현

그래프에서 정점들의 연결 관계를 표현하는 가장 간단한 방법은 행렬(Matrix)을 사용하는 것이다. 이러한 행렬을 **인접행렬(Adjacency Matrix)**이라 한다. 그래프 $G$를 인접행렬로 표현해보자. 정점의 개수가 $n$이라면 $n \times n$의 행렬(2차원 배열구조) $M$이 필요하다. $M$의 각 원소들은 다음과 같이 행과 열에 해당하는 정점간의 간선 정보를 나타낸다.

[그림 10.5] 인접행렬을 이용한 그래프 표현 예(무방향 그래프)

두 정점 사이에 **간선이 없으면 0 또는 None**을 갖도록 하고, **간선이 있으면 1**을 갖는다. 만약 간선이 가중치를 갖는 **가중치 그래프**의 경우라면 위와 같이 간선이 있는 성분을 그 가중치 값으로 표시한다. 우리가 다루는 그래프에서는 **자체 간선**(자신에서 출발해서 자신으로 들어오는 간선)을 허용하지 않으므로 인접행렬의 대각선 성분은 모두 0으로 표시한다.

* 무방향 그래프
    무방향 그래프에서 인접행렬은 대칭행렬이 된다. 이것은 간선 (u, v)가 정점 u에서 정점 v로의 연결뿐만 아니라 정점 v에서 정점 u로의 연결을 동시에 의미하기 때문이다. 따라서 무방향 그래프는 배열의 상위삼각이나 하위삼각만 저장하여 메모리를 절약할 수도 있다.
* 방향 그래프
    방향 그래프의 인접행렬은 일반적으로 대칭이 아니다.

    [그림 10.6] 인접행렬을 이용한 방향그래프 표현 예



### 인접리스트를 이용한 표현

그래프의 각 정점과 연결된 인접 정점들을 각각의 리스트로 표현할 수도 있는데, 이러한 리스트를 **인접 리스트(Adjacency List)**라 부른다. 각 정점은 인접 리스트를 이용해 자신과 간선으로 직접 연결된 인접 정점들을 관리한다. 이때 리스트로는 **연결된 구조**를 사용할 수도 있고 **배열구조**인 파이썬의 리스트를 사용할 수도 있다.

예를 들어, 연결된 구조를 사용한다면 그래프는 다음 그림과 같이 각각의 인접 리스트를 가리키는 헤더 포인터의 배열을 갖는다. 이제 정점의 번호만 알면 그 정점의 연결 리스트를 이용해 인접 정점들에 쉽게 접근할 수 있다.

[그림 10.7] 인접 리스트를 이용한 무방향 그래프 표현 예

무방향 그래프에 간선 (u, v)를 추가해보자. 정점 u의 연결 리스트에 v 노드를 추가해야 한다. 물론 정점 v의 연결 리스트에도 u 노드를 추가하는 것도 잊지 말아야 한다. 따라서 연결 리스트에 실제로 만들어지는 노드의 수는 간선의 수의 2배이다. 물론 인접 리스트에 노드를 추가하는 방법에 따라 인접 정점들의 순서가 달라질 수 있지만 이러한 순서는 중요하지 않다.

그림과 같은 방향 그래프에서는 인접 리스트의 노드의 수는 그래프의 간선의 수와 같다.

[그림 10.8] 인접 리스트를 이용한 방향 그래프 표현 예



### 인접행렬과 인접리스트의 복잡도 비교

정점의 수가 $n$개이고 간선의 수가 $e$개인 무방향 그래프에서 주요 연산에 대한 인접행렬과 인접리스트의 복잡도를 비교해보자.

* 인접행렬
    - 간선의 수에 무관하게 항상 **$n^2$개의 메모리 공간**이 필요하다. 따라서 정점에 비해 간선의 수가 매우 많은 **조밀그래프(Dense Graph)**에서 효과적이다.
    - $u$와 $v$를 연결하는 간선의 유무는 M[u][v]를 조사하면 바로 알 수 있다. 따라서 getEdge(u, v)의 시간복잡도는 $O(1)$이다.
    - 정점의 차수를 구하는 degree(v)는 정점 $v$에 해당하는 행을 조사하면 되므로 $O(n)$이다. 즉, 정점 $v$에 대한 차수는 다음과 같이 계산된다. 
    $$degree(v) = \sum_{k=0}^{n-1} M[u][v]$$
    - 정점 $v$의 인접정점을 구하는 adjacent(v) 연산은 해당 행의 모든 요소를 검사하면 되므로 $O(n)$의 시간이 요구된다.
    - 그래프에 존재하는 모든 간선의 수를 알아내려면 인접행렬 전체를 조사해야 하므로 $n^2$번의 조사가 필요하다. 따라서 $O(n^2)$의 시간이 요구된다.
* 인접리스트
    - $n$개의 연결리스트가 필요하고, $2e$개의 노드가 필요하다. 즉, **$n+2e$개의 메모리 공간**이 필요하다. 따라서 정점에 비해 간선의 개수가 매우 적은 **희소그래프(Sparse Graph)**에서 효과적이다.
    - getEdge(u, v) 연산은 정점 $u$의 연결 리스트 전체를 조사해야 한다. 정점 $u$의 차수를 $d_u$라고 한다면 이 연산의 시간복잡도는 $O(d_n)$이다.
    - 정점 $v$의 차수 degree(v)는 $v$의 연결리스트의 길이를 반환하면 된다. 따라서 시간복잡도는 $O(d_v)$이다.
    - 정점 $v$에 간선으로 직접 연결된 모든 정점을 구하는 adjacent(v) 연산도 해당 연결리스트의 모든 요소를 방문해야 되므로 $O(d_v)$이다.
    - 전체 간선의 수를 알아내려면 헤더 노드를 포함하여 모든 인접리스트를 조사해야 하므로 $O(n+e)$의 연산이 요구된다.


완전 그래프에 가까운 매우 조밀한 그래프($e \approx n(n-1)/2$)에서는 인접행렬이 유리하고 보다 간단하다. 반대로 정점의 수에 비해 간선이 매우 적은 희소그래프에서는 인접리스트가 더 효율적이라 볼 수 있다.


### 파이썬을 이용한 그래프의 인접행렬 표현

그래프의 정점 데이터는 파이썬의 리스트를 사용하면 간단히 표현된다. 정점간의 관계를 나타내는 인접행렬은 어떻게 나타낼 수 있을까? **리스트의 리스트**를 사용하면 **2차원 배열구조**를 표현할 수 있다. 인접행렬의 각 요소들은 정점간의 간선이 존재하는 경우 1을, 그렇지 않은 경우 0을 갖는다. 다음은 무방향 그래프를 인접행렬로 표현한 예이다.







이때, 인접행렬의 행과 열의 순서는 정점의 순서와 정확히 일치해야 한다.

만약 간선이 가중치를 갖는 **가중치 그래프**라면 행렬 요소에 가중치를 표시하면 된다. 이 경우 구분을 위해 간선이 없는 경우를 다음과 같이 None으로 처리하는 것이 좋다. 다음은 무방향 가중치 그래프의 인접행렬 표현 예이다.






### 파이썬을 이용한 그래프의 인접리스트 표현

파이썬은 리스트와 튜플, 딕셔너리, 집합 등 다양한 내장자료형을 제공한다. 따라서 인접리스트를 표현할 수 있는 방법이 매우 다양하다.


#### 인접정점 리스트

인접리스트는 연결리스트로 표현할 수도 있지만, 파이썬의 리스트를 사용하는 것이 가장 간단할 것이다. 다음은 인접리스트에 인접정점의 인덱스를 저장한 예를 보여준다.








리스트를 인덱스로 나타내면 연결관계를 한눈에 파악하기가 쉽지 않다. C언어와 달리 파이썬은 보다 가독성 있는 코드를 손쉽게 만들 수 있는 장점이 있다. 예를 들어, 다음과 같이 정점정보(정점의 키값 등)를 리스트에 직접 표시한다면 코드를 통해 그래프의 구조를 보다 쉽게 예상할 수 있다.







``` Python
인접리스트를 파이썬의 리스트 대신에 튜플을 사용할 수도 있다. 그러나 이 경우 그래프의 정점이나 간선을 추가하거나 삭제할 수 없다는 제약이 생긴다.
```



#### 하나의 객체로 표현

정점과 인접리스트를 한꺼번에 표시할 수도 있다. 여러 방법이 있지만, 가장 간단한 방법은 정점과 그 정점의 인접리스트를 튜플(또는 리스트)로 묶어 다음과 같이 하나로 처리하는 것이다. 이제 하나의 변수 graph를 통해 그래프의 모든 정보를 알 수 있다.










``` Python
위의 표현에서도 튜플을 사용하는 (정점정보, 인접리스트)가 아니라 리스트를 사용해 [정점정보, 인접리스트]로 표현할 수도 있다. 변경이 필요없는 경우에는 리스트보다 튜플을 사용하는 것이 더 효율적이다.
```

예를 들어, 이 방법으로 정점 C의 데이터와 객체에 접근하려면 어떻게 할까? graph[2][0]은 정점 C 객체이고, graph[2][1]은 정점 C의 인접리스트이다. 정점 C의 첫번째 인접정점은 graph[2][1][0]을 통해 알 수 있다. 여러개의 인덱스 연산자를 사용해야 함에 유의하라. 실제 코드에서는 복잡함을 피하기 위해서는 다음과 같이 추가적인 변수를 사용하는 것이 좋을 것이다.

``` Python
    edge = graph[2][1]  # edge는 정점 C의 인접리스트
    print(edge[0])      # C의 첫번째 인접정점 출력
```


#### 딕셔너리를 이용한 표현

사실 그래프에서 정점들은 순서의 의미는 없다. 그래프는 선형자료구조가 아니기 때문이다. 따라서 리스트가 아니라 집합이나 딕셔너리와 같은 다른 방법들을 이용해 표현할 수도 있다. 딕셔너리를 이용해보자. 각 정점에 각각의 인접리스트를 대응(Mapping)시키는 것이다. 다음은 **정점의 이름을 키(Key)**로, 그 **정점의 인접리스트를 값(Value)**으로 하는 엔트리로 구성된 딕셔너리로 그래프를 표현한 예시이다.







이 표현에서 정점 C의 인접리스트는 다음과 같이 구할 수 있다.

``` Python
    edge = graph['C']   # edge는 노드 C의 인접리스트
```



#### 딕셔너리와 집합을 이용한 표현

사실 **인접리스트**도 반드시 "리스트"로 이루어질 필요는 없다. **의미적으로는 인접정점 리스트보다는 인접정점 집합이 더 정확**하다. 왜냐하면 인접정점들 사이에는 순서가 필요하지 않고, 단지 어떤 정점들이 인접해 있는지만이 중요하기 때문이다. 따라서 인접리스트를 **집합(Set)**으로 표현할 수 있다. 동일한 그래프를 딕셔너리와 인접정점 집합으로 표현한 예는 다음과 같다.







``` Python
set([a, b, c, ...])은 리스트의 항목들을 이용해 초기화한 집합 객체를 생성한다. 즉 파이썬의 **리스트 객체를 이용해 파이썬의 집합 객체를 생성**하는 문장이다.
```

코드에서 graph['C']는 정점 'C'의 인접정점 집합을 나타낸다. 따라서 집합 graph['C']의 원소는 'A', 'D', 'E'가 될 것이다. 집합에서도 `in` 연산자를 사용할 수 있다. 예를 들어, graph['C']의 각 원소를 화면에 출력하기 위해서는 다음 코드를 사용할 수 있다. 

``` Python
for v in graph['C']:    # 정점 C의 인접정점 집합의 모든 원소에 대해 
    print(v)            # 그 원소를 화면에 출력
```

파이썬에서는 내장 자료형으로 제공하는 것들이 많아 그래프를 표현하는 방법도 매우 다양함에 유의하라. 파이썬은 복잡한 클래스를 만들지 않더라도 내장 자료형을 이용해 그래프와 같은 복잡한 구조도 손쉽게 표현할 수 있는 것이 큰 특징이다. 따라서 이러한 다양한 내장자료형에 익숙해지는 것이 좋다. 이 장에서는 딕셔너리와 정점 집합을 이용한 그래프 표현 방법을 이용해 다양한 그래프 문제를 해결한다.



## 10.3 그래프의 탐색

그래프 탐색은 가장 기본적인 연산으로 하나의 정점에서 시작하여 모든 정점들을 한번씩 방문하는 작업이다. 실제로 많은 그래프 문제들이 단순히 정점의 탐색만으로 해결된다. 예를 들어, 전자회로에서도 어떤 두 단자가 서로 연결되어 있는지를 판단하는 것은 그래프 탐색만으로 가능하다. 미로에서 출구를 찾는 일도 그래프 탐색으로 해결할 수 있다. 기본적인 그래프 탐색 방법에는 **깊이우선탐색**과 **너비우선탐색**의 2가지가 있다.

[그림 10.9] 그래프 탐색의 응용분야


알고리즘을 살펴보기 전에 먼저 그래프 표현방법을 결정하자. 이 장에서는 가급적 **인접리스트** 방식을 사용하고, 다음 장에서 인접행렬 방식을 사용한다. 다양한 인접리스트 표현 방법 중에서도 **딕셔너리와 집합**을 사용해 그래프를 표현한다. 
















































