

* **Date : 2022-07-19**
* **Last Modified At : 2022-07-19**


# Chapter 9. 탐색트리

## 9.1 탐색트리란?

### 탐색트리는 탐색을 위한 트리 기반의 자료구조이다.

일상생활이나 컴퓨터에서 탐색은 매우 중요한 작업이고 지금까지 많이 연구가 진행된 분야로, 우리는 7장에서 다양한 탐색 방법을 공부하였다. 가장 단순한 순차탐색은 비효율적이기 때문에 이진탐색으로 성능을 개선할 수 있지만, 이 방법은 정렬된 데이터에 대해서만 적용할 수 있었다. 이진탐색은 레코드를 한번 정렬하고 탐색이 빈번하게 필요한 응용에는 효율적이지만, 레코드의 삽입과 삭제 자체가 빈번하게 발생한다면 그때마다 정렬에 대한 부담이 있으므로 효율적이지 않을 수도 있다. 탐색을 위한 가장 빠른 방법은 해싱을 사용하는 것이지만 메모리를 많이 사용하고, 해시 충돌과 이에 따른 오버플로우 문제를 처리해야 하는 것도 7장에서 공부했다.

[무제1]


탐색에 트리구조를 이용할 수도 있다. **이진탐색트리(BST, Binary Search Tree)**는 효율적인 **탐색을 위한 이진트리 기반의 자료구조**이다. 이진탐색트리는 다음과 같이 순환적으로 정의된다.

정의 9.1 이진탐색트리

* 모든 노드는 유일한 키를 갖는다.
* 왼쪽 서브트리의 키들은 루트의 키보다 작다.
* 오른쪽 서브트리의 키들은 루트의 키보다 작다.
* 왼쪽과 오른쪽 서브트리도 이진탐색트리이다.

트리의 연산들을 보다 단순하게 설계하기 위해 이진탐색트리에서는 보통 중복을 허용하지 않는다. 그렇지만, 필요하다면 중복된 키를 허용할 수도 있다. 다음 트리가 이진탐색트리 조건을 만족하는지 살펴보자.

[그림 9.1] 이진탐색트리의 조건


* 루트노드의 왼쪽 서브트리에 있는 값들(3, 7, 12)은 루트노드인 18보다 작다. 또 오른쪽 서브트리의 값들(26, 31, 27)은 루트보다 크다.
* 이러한 성질은 트리의 모든 노드에서 만족되어야 한다. 왼쪽 서브트리의 7은 이를 만족한다.
* 단말 노드인 3, 12, 27은 자식이 없으므로 비교할 필요도 없이 만족한다.
* 오른쪽 서브트리의 비 단말 노드 26, 31도 크기 조건을 만족한다.
* 모든 노드가 크기 조건을 만족하므로 이 트리는 이진탐색트리이다.

이 트리의 모든 노드들을 중위 순회로 방문해보자. 3, 7, 12, 18, 26, 27, 31과 같이 오름차순으로 노드를 방문하게 될 것이다. 모든 이진탐색트리는 이러한 성질을 갖는데, 따라서 **어느 정도 정렬된 상태를 유지**하고 있다고 볼 수 있다.

이진탐색트리는 이진트리의 한 종류이다. 따라서 공백검사나 순회, 노드의 수 등 기본적인 이진트리 연산은 이진탐색트리에서도 동일하게 적용된다. 추가적으로 이진탐색트리는 탐색이 목적이므로 **탐색연산**이 정의되어야 한다.

리스트나 스택, 큐 등에서와 달리 8.3절의 이진트리에서는 삽입이나 삭제연산을 전혀 고려하지 않았던 것을 기억하라. 이것은 트리의 경우 노드를 삽입하거나 삭제하는 위치를 명시하는 것이 간단하지 않기 때문이다. 그러나 이진탐색트리에서는 이들 연산을 구체화할 수 있다. 예를 들어, 이진탐색트리에서는 insert(n) 연산을 통해 새로운 **노드 n이 저장되어야 하는 트리상의 위치는 단 하나**뿐이다. 삭제도 마찬가지로, 어떤 노드가 삭제되면 이진탐색트리의 조건을 반드시 유지하는 형태로 트리가 재구성되어야 한다. 따라서 이진탐색트리에서는 **삽입연산**, **삭제연산** 및 **탐색연산**에 집중한다. 중요한 것은 모든 연산이 이진탐색트리의 조건을 유지하면서 처리되어야 한다는 것이다.



## 9.2 이진탐색트리의 연산

이진탐색트리를 위한 노드의 구조는 기본적으로 이진트리와 동일하다. 하나의 차이는 이진탐색트리는 탐색을 위한 자료구조이므로 노드의 데이터는 하나의 엔트리, 즉 (**탐색키**, **키에 대한 값**)의 형태가 되어야 한다. 단순화를 위해 데이터 영역을 키와 값으로 다음과 같이 분리하자. 이진탐색트리를 위한 노드 클래스를 BSTNode는 다음과 같이 정의할 수 있다.

``` Python
class BSTNode():                        # 이진탐색트리를 위한 노드 클래스
    def __init__(self, key, value):     # 생성자 : 키와 값을 받음
        self.key = key                  # 키(Key)
        self.value = value              # 값 (Value)
        self.left = None                # 왼쪽 자식에 대한 링크
        self.right = None               # 오른쪽 자식에 대한 링크
```


### 탐색 연산

#### 키를 이용한 탐색

이진탐색트리에서 키 값으로 Key를 가진 노드를 탐색해보자. 탐색은 항상 루트노드에서 시작한다. 루트노드와의 비교 결과는 다음 세가지 중의 하나이다.

1. **Key == 루트의 키 값** : 루트가 찾는 노드이다. 탐색 성공
2. **Key < 루트의 키 값** : 찾는 노드는 왼쪽 서브트리에 있음. 탐색을 루트의 왼쪽 자식을 기준으로 다시 시작.
3. **Key > 루트의 키 값** : 찾는 노드는 오른쪽 서브트리에 있음. 탐색을 루트의 오른쪽 자식을 기준으로 다시 시작.

[그림 9.2] 이진탐색트리의 탐색 과정


이 과정은 루트의 서브트리에서도 되풀이되어야 한다. 따라서 이 알고리즘도 순환으로 구현하는 것이 자연스럽다.

``` Python
# 이진탐색트리 탐색연산(순환 함수)
def search_bst(n, key):
    if n == None:
        return None
    elif key == n.key:                      # n의 키 값과 동일 : 탐색 성공
        return n
    elif key < n.key:                       # Key < n의 키
        return search_bst(n.left, key)      # 순환호출로 왼쪽 서브트리 탐색
    else:                                   # Key > n의 키
        return search_bst(n.right, key)     # 순환호출로 오른쪽 서브트리 탐색
```

다음 그림은 이진탐색트리에서 12와 32를 찾는 과정을 보여준다. 12는 탐색 성공이지만 탐색 과정에서 None을 만나는 32의 경우는 탐색 실패이다.

[그림 9.3] 이진탐색트리의 탐색 예 : 12는 성공, 32는 실패

12와 32의 탐색에서 각각 몇 개의 노드를 검사했는지 살펴보자. 12는 3개(18, 7, 12), 32도 3개(18, 26, 31)의 노드만을 비교하고 탐색을 종료했다. 















































































