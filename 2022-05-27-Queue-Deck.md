



# Chapter 5. Queue and Deck


## 5.1 큐란?

### 큐는 선입선출(First-In First-Out : FIFO)의 자료구조이다.

여행을 가기 위해 공항 카운터에 줄을 서서 기다리는 대기열을 생각하면 큐를 쉽게 이해할 수 있다. 큐(Queue)는 먼저 들어온 데이터가 먼저 나가는 선입선출(FIFO : First-In First-Out)의 특성을 갖는 자료구조이다. 가장 앞에 있는 사람, 즉 가장 먼저 온 사람이 가장 먼저 서비스를 받아야 하고, 방금 도착한 사람은 줄의 맨 뒤에 서서 기다려야 한다.




큐는 뒤에서 새로운 데이터가 추가되고 앞에서 데이터가 하나씩 삭제되는 구조를 가지고 있다. 구조상으로 큐가 스택과 다른 점은 삽입과 삭제 연산의 위치가 같은 쪽이 아니라 서로 다른 쪽에서 일어난다는 것이다. 큐에서 삽입이 일어나는 곳을 **후단(Rear)**이라 하고 삭제가 일어나는 곳을 **전단(Front)**이라 한다. 다음은 큐의 구조를 보여준다.



[그림 5.1] 큐의 구조



### 큐의 추상자료형

큐에 저장하는 자료에도 특별한 제한이 없다. 연산들은 스택과 매우 유사한데, 삽입과 삭제 연산의 이름이 각각 enqueue와 dequeue인 것만 다르다. 큐의 추상자료형을 정의하면 다음과 같다.


정의 5.1 Queue ADT

* 데이터 : 선입선출(FIFO)의 접근 방법을 유지하는 항목들의 모음
* 연산
    - Queue() : 비어있는 새로운 큐를 만든다.
    - **isEmpty()** : 큐가 비어있으면 True를 아니면 False를 반환한다.
    - **enqueue(x)** : 항목 x를 큐의 맨 뒤에 추가한다.
    - **dequeue()** : 큐의 맨 앞에 있는 항목을 꺼내 반환한다.
    - peek() : 큐의 맨 앞에 있는 항목을 삭제하지 않고 반환한다.
    - size() : 큐의 모든 항목들의 개수를 반환한다.
    - clear() : 큐를 공백상태로 만든다.

isEmpty()는 큐의 공백상태를 검사하고 peek(), size(), clear() 연산도 스택에서와 동일한 의미를 갖는다. 큐에서도 가장 중요한 연산은 삽입 연산인 enqueue()와 삭제 연산인 dequeue()이다. 물론 삽입은 후단을 통해서만, 삭제는 전단을 통해서만 가능하다. 다음은 큐에서 일련의 삽입과 삭제가 이루어지는 과정을 보여주는데, 자료가 큐에 들어온 순서대로 나가는 것을 알 수 있다.


[그림 5.2] 큐의 삽입과 삭제 연산 예시



### 큐는 어디에 사용할까?

일상생활에서 대부분의 일들이 먼저 들어온 순서대로 처리되는 것과 같이 컴퓨터에서도 큐는 매우 광범위하게 사용된다. 특히 컴퓨터에서 데이터를 주고받을 때 각 주변장치들 사이에 존재하는 속도의 차이나 시간차이를 극복하기 위한 임시 기억장치로 큐가 사용되는데, 이것을 **버퍼(Buffer)**라고 한다. 그림과 같이 서비스 콜 센터에서도 **콜 큐(Call Queue)**를 사용한다. 큐에 많은 요청이 들어있으면 고객은 기다려야 한다. 그러나 먼저 신청한 사람은 반드시 먼저 서비스를 받는다. 큐의 활용 분야를 알아보자.





* 컴퓨터와 프린터 사이에 **인쇄작업 큐**가 존재한다. 프린터는 CPU에 비해 상대적으로 속도가 느리다. 따라서 CPU는 빠른 속도로 인쇄 데이터를 만들어 프린터의 인쇄작업 큐에 보낸 다음 다른 작업으로 넘어간다. 프린터는 일정한 속도로 인쇄작업 큐에서 순서대로 데이터를 가져와 인쇄한다.
* 실시간 비디오 스트리밍에서 다운로드된 데이터가 비디오를 재생하기에 충분하지 않으면 큐에 순서대로 모아두었다가 충분한 양이 되었을 때 비디오를 복원하여 재생한다. 이것을 **버퍼링(Buffering)**이라고 한다.
* 컴퓨터로 현실세계를 **시뮬레이션**하는 분야에서도 큐가 폭넓게 사용된다. 예를 들어 은행에서 대기표를 뽑고 기다리는 고객들, 공항에서 활주로를 이용해 이륙하는 비행기들, 인터넷에서 전송되는 데이터 패킷들을 모델링하는데 큐가 이용된다. 이러한 시뮬레이션을 잘 활용하면 은행이나 공항 시스템을 최적화할 수 있고, 따라서 최소의 비용으로 최고의 수익을 올릴 수 있다.

큐도 프로그래머의 중요한 도구로서 폭넓게 이용되고 있다.



## 5.2 큐의 구현

### 선형 큐에는 어떤 문제가 있을까?

큐 항목들을 저장하는 가장 쉬운 방법은 배열구조인 파이썬의 리스트를 사용하는 것이다. 이 리스트의 이름을 items라 하자. 맨 처음에 이 리스트는 공백이 되어야 한다.

``` Python
items = []      # 큐 항목을 위한 리스트
```

이제 front와 rear를 결정해야 한다. 일단 리스트의 맨 앞을 front라 하고, 맨 뒤를 rear라 하자. 이렇게 되면 **front와 rear를 위한 변수를 따로 관리할 필요가 없다**. front의 인덱스는 항상 0이고, rear는 항상 len(items) - 1, 또는 -1이기 때문이다.

이제 연산들을 구현하자. 리스트를 사용하면 연산들은 매우 간단해진다. 연산은 먼저 함수로 구현하자.



#### isEmpty() : 공백상태 검사

큐가 공백상태이면 items는 빈 리스트가 된다. 스택에서와 같이 len() 함수를 이용해 구현하면 된다.

``` Python
def isEmpty():
    return len(items) == 0      # 리스트 항목수가 0이면 공백상태
```



#### enqueue(item) : 삽입 연산

삽입 연산은 rear에 항목을 추가하는 것이다. 따라서 리스트의 맨 뒤에 item을 삽입하면 된다. 리스트의 append() 메소드를 사용하면 간단히 구현된다.


``` Python
def enqueue(item):
    items.append(item)      # 리스트의 맨 뒤에 item 추가
```

대부분의 경우 append()는 상수 시간에 항목을 추가할 수 있다. 따라서 이 연산의 시간복잡도는 $O(1)$이다.


#### dequeue() : 삭제 연산

삭제 연산은 front에서 항목을 하나 꺼내고 이를 반환하면 된다. 리스트에서 맨 앞의 항목을 꺼내는 것은 리스트의 pop() 메소드를 사용하면 된다. 즉, items.pop(0)으로 리스트 items의 맨 앞의 항목을 추출할 수 있다. 물론 큐가 공백상태이면 삭제할 수 없으므로 공백상태를 먼저 검사해야 한다.

``` Python
def dequeue():
    if not isEmpty():           # 공백상태가 아니면
        return items.pop(0)     # 맨 앞 항목을 꺼내서 반환
```


이 연산의 시간복잡도는 어떻게 될까? 3.2절에서 공부한 바와 같이 리스트의 pop(0) 연산은 모든 항목들을 앞으로 1칸씩 당겨야 하므로 항목수에 비례하는 시간이 걸린다. 따라서 삭제연산의 복잡도는 $O(n)$이다.


[그림 5.3] 선형큐의 문제점 : 삭제연산(pop(0))의 시간복잡도가 $O(n)$이다.


스택에서도 비슷한 문제가 있었음을 기억하라. 스택에서는 스택 상단의 위치를 바꾸어 해결했다. 그러나 큐에서는 전단과 후단을 바꾼다고 해결되지 않는다. 둘 중 하나에서는 같은 문제가 발생하기 때문이다.



### 기타 연산들

peek는 front 항목을 반환하기만 하고, 큐는 건드리지 않는다.

``` Python
def peek():                 # 전단 항목을 삭제하지 않고 반환
    if not is Empty():
        return items[-1]
```


나머지 연산(size와 clear 등)들은 스택과 비슷하게 간단히 구현된다. 이러한 큐를 선형 큐라고 한다. **선형 큐**에서는 삽입과 삭제 연산의 시간복잡도를 모두 $O(1)$으로 만들 수 없다. 구현된 코드에서는 삭제연산의 시간복잡도가 $O(n)$이다. 삭제연산도 $O(1)$으로 동작하도록 구현할 수는 없을까?


### 원형 큐가 훨씬 효율적이다.

배열을 선형으로 생각하지 않고 원형으로 생각하면 선형 큐의 문제를 해결할 수 있다. 이것은 리스트의 맨 끝과 맨 앞을 연결하는 개념이다. 물론 실제로 리스트가 원형인 것은 아니고, 원형으로 생각하고 사용하는 것일 뿐이다.

원형 큐에서는 기본적으로 리스트의 크기가 고정되어야 한다. C언어의 배열과 같이 리스트에 항상 그림과 같이 고정된 크기(MAX_QSIZE)의 칸이 있다고 생각하자. 원형 큐에서는 front와 rear를 위한 변수가 필요하다. rear는 **큐에 가장 최근에 삽입된 항목의 위치**를 front는 **가장 최근에 삭제된 항목의 위치**를 저장한다. 맨 처음에는 front = rear = 0 이다. 삽입연산은 rear를 하나 증가시킨 후 그 위치에 항목을 넣는 것이다. 삭제연산도 front를 하나 증가시키고 그 위치의 항목을 반환하면 된다. 크기가 8인 원형 큐에서 삽입과 삭제 연산의 예는 다음과 같다.



[그림 5.4] 원형 큐의 삽입과 삭제 과정


중요한 것은 인덱스가 원형으로 움직인다는 것이다. 0부터 계속 증가하다가 MAX_QSIZE - 1이 되면 다음은 MAX_QSIZE가 아니라 다시 0이 되는 것이다. 그렇다면 front와 rear를 어떻게 원형으로 회전시킬까? 다음과 같이 나머지 연산자를 사용하면 간단하게 해결된다.

``` Python
front <- (front + 1) % MAX_QSIZE
rear  <- (rear  + 1) % MAX_QSIZE
```

삭제를 하더라도 선형 큐와 같이 항목들을 앞으로 하나씩 당길 필요가 없다. 삽입도 마찬가지이다. 인덱스만 변경된다. 따라서 **삽입과 삭제 연산이 모두 $O(1)$**이다.

마지막으로 큐의 상태를 살펴보자. **공백상태**는 **front == rear**인 경우이다. 이들이 반드시 0일 필요는 없다. **같은 곳을 가리키기만 하면** 공백상태이다.



[그림 5.5] 원형 큐의 3가지 상태



**포화상태**는 어떨까? 선형 큐에서는 포화상태를 정의하지 않았다. 필요한 만큼 리스트를 확장해 저장할 수 있었기 때문이다. 원형큐에서는 크기는 `MAX_QSIZE`로 고정하였으므로 리스트가 꽉 차서 더 이상 항목을 추가할 수 없는 포화상태가 발생할 수 있다. 그렇다면 어떤 경우가 포화상태일까? 그림 5.5의 (c)와 같은 상태를 생각하기 쉽지만 문제가 있다. (c)는 공백상태인 (a)와 구분이 안 된다. 즉, 모두 front == rear 이다. 따라서 원형 큐에서는 하나의 자리를 비워두는 전략을 사용한다. (b)와 같이 **front**가 **rear보다 하나 앞**에 있으면 포화상태라고 정의한다. 이것은 **front == (rear + 1) % MAX_QSIZE**인 상태를 의미한다.





### 원형 큐의 구현

원형 큐를 클래스로 정의하자. 이름은 CircularQueue로 한다. 항목들은 파이썬의 리스트에 저장하고, 크기는 MAX_QSIZE라 하자. 생성자에서 리스트인 items와 정수형 변수 front와 rear를 선언한다. 이때, items가 ```MAX_QSIZE```개의 항목을 이미 가지고 있어야 하는 것에 유의하라. 코드는 다음과 같다.


``` Python
MAX_QSIZE = 10                              # 원형 큐의 크기
class CircularQueue():                      
    def __init__(self):                     # CircularQueue 생성자
        self.front = 0                      # 큐의 전단 위치
        self.rear = 0                       # 큐의 후단 위치
        self.items = [None] * MAX_QSIZE     # 항목 저장용 리스트 [None, None, ...]
    
    # 공백상태와 포화상태 검사 및 초기화 연산은 다음과 같다.
    # 포화상태 검사를 위해 나머지 연산자를 사용해야 한다.
    def isEmpty(self):
        return self.front == self.rear

    def isFull(self):
        return self.front == (self.rear + 1) % MAX_QSIZE

    def clear(self):
        self.front = self.rear

    # 삽입, 삭제 및 peek 연산은 다음과 같다.
    # front와 rear를 원형으로 회전시키는 코드에 유의하라.
    def enqueue(self, item):
        if not self.isFull():
            self.rear = (self.rear + 1) % MAX_QSIZE
            self.items[self.rear] = item
        
    def dequeue(self):
        if not self.isEmpty():
            self.front = (self.front + 1) % MAX_QSIZE
            return self.items[self.front]
        
    def peek(self):
        is not self.isEmpty():
            return self.items[(self.front + 1) % MAX_QSIZE]
```

이 코드에서도 예외적인 경우에 대한 처리코드를 생략하였다. 예를 들어, 포화상태에서 enqueue()가 호출되거나(Overflow), 공백상태에서 dequeue()가 호출된(Underflow) 상황 등이 예외적인 상황이다.

현재 큐에 저장된 항목의 개수는 어떻게 구할까? rear-front로는 충분하지 않다. 왜냐하면 rear가 회전되어 front보다 작아질 수 있기 때문이다. 다음과 같이 큐의 크기 ```MAX_QSIZE```와 모듈러 연산을 이용해야 한다.

``` Python
    def size(self):
        return (self.rear - self.front + MAX_QSIZE) % MAX_QSIZE
```



아직 모두 끝난 것이 아니다. 큐의 내용을 출력하려면 어떻게 할까? 선형 큐는 front가 항상 0이므로 그냥 리스트를 출력하면 된다. 그러나 원형 큐는 다르다. front 다음 항목부터 rear 항목까지를 순서대로 출력해야 한다. 이를 위해 클래스에 display() 연산을 추가하자. 파이썬 리스트의 **슬라이싱** 기능을 이용하면 좀 더 쉽게 큐의 내용을 순서대로 출력할 수 있다. front와 rear가 뒤집히면 front 이후 MAX_QSIZE 전까지와 0부터 rear까지의 항목을 모아 출력하면 된다. 구현된 코드는 다음과 같다.




[그림 5.6] 원형 큐 출력의 2가지 경우




``` Python
def display(self):
    out = []
    if self.front < self.rear:                              # 슬라이싱
        out = self.items[self.front + 1 : self.rear + 1]    
    else:                                                   # 슬라이싱
        out = self.items[self.front + 1 : MAX_QSIZE] + self.items[0 : self.rear + 1] 
    print('[f = %s, r = %d] ==>' % (self.front, self.rear), out)
```

이 코드에서는 파이썬의 슬라이싱 기능과 리스트를 합하는 + 연산을 사용하였다. 예를 들어, 그림 5.6의 Case1에서 리스트 items는 다음과 같다.

``` Python
items = [None, None, 'B', 'C', 'D', None, None, None]
```

이때 슬라이싱을 이용한 items[front + 1 : rear + 1]은 items[2:5]와 같고, 이것은 리스트 ['B', 'C', 'D']가 된다. 또한 두 리스트의 + 연산도 가능하다. 그림의 Case2와 같은 상황에서 ['F'] + ['G', 'A', 'B']는 리스트 ['F', 'G', 'A', 'B']가 된다.

이제 원형 큐를 테스트해보자. 큐의 크기는 10으로 설정하였다. 인덱스의 회전이 잘 되는지를 보이기 위해 8번의 삽입, 5번의 삭제, 그리고 6번의 삽입연산을 실행하였다. 테스트 코드와 실행 결과는 다음과 같다.

``` Python
q = CircularQueue()         # 원형 큐 만들기 (MAX_QSIZE = 10)
for i in range(8):          # 0, 1, ..., 7 삽입 (f = 0, r = 8)
    q.enqueue(i)            
q.display()                 # 원형 큐에서 구현한 print() 호출
for i in range(5):
    q.dequeue()             # 5번 삭제 (f = 5, r = 8)
q.display()
for i in range(8, 14):      # 8, 9, ..., 13 삽입 (f = 5, r = 4)
    q.enqueue(i)
q.display()
```


이 코드에서 마지막 상태는 포화상태이다. 더 이상 항목을 추가할 수 없다. 이와 같이 구현된 원형 큐는 크기가 제한된다. 그렇지만 항목의 이동이 필요없으므로 삽입이나 삭제연산이 모두 $O(1)$으로 매우 효율적이다. 따라서 원형 큐를 사용할 때는 문제의 특성을 고려해서 큐의 크기를 충분히 크게 만들어 사용하는 것이 좋을 것이다.



## 5.3 큐의 응용 : 너비우선탐색

(오늘은 여기까지!! 내일부터 다시 시작!!)




























