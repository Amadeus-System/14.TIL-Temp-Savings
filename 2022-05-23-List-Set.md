* Date : 2022-05-23
* Last Devised : 2022-05-23

# Chapter 3. 리스트와 집합

## 3.1 리스트란?

### 리스트는 가장 자유로운 선형자료구조이다.

리스트는 우리가 생활에서 가장 많이 사용하는 자료정리방법이다. 우리는 해야 할 일이나 친구들의 연락처를 리스트로 관리하고, 죽기 전에 꼭 가보고 싶은 여행지나 크리스마스에 받고 싶은 선물을 정리해 리스트를 만든다.


(그림)


**리스트(List)** 또는 **선형리스트(Linear List)**는 항목들이 차례대로 나열되어 있는 선형자료구조이다. 리스트의 항목들은 순서 또는 **위치(Position)**를 가진다. 리스트는 기호로 다음과 같이 표현한다.

$$ L = \{ item_0, item_1, item_2, ..., item_{n-1} \}  $$

리스트는 "**항목들 사이에 순서가 있다**"는 점에서 **집합(Set)**과는 다르다. 집합에서는 원소들 사이에 순서의 개념이 없다. 집합은 원소의 중복도 허용하지 않지만 리스트에서는 이러한 제한도 없다.


(그림)



다음은 리스트의 구조를 보여주고 있는데, 항목들이 **순서대로 나열**되어 있고, 각 항목들은 **위치**를 갖는다. 특히 리스트에서는 어떤 위치에서도 항목의 삽입이나 삭제가 가능하다.


[그림 3.1] 리스트의 구조



4장과 5장에서 우리는 스택이나 큐, 덱 등을 공부한다. 이들도 모두 선형자료구조이지만 항목에 대한 접근이 전단이나 후단으로 제한된다. 그러나 리스트는 이러한 제한이 없다. 즉, 임의의 위치에 항목을 삽입하거나 삭제하는 것이 허용된다. 따라서 리스트는 선형자료구조들 중에서 가장 활용이 자유롭다. 자유로운만큼 고려해야 할 사항들도 많으며 따라서 선형자료구조들 중에서 코드가 가장 복잡하다.


### 리스트의 추상자료형

리스트는 어떤 **데이터**를 저장할 수 있을까? 사고 싶은 물건, 수신된 메시지, 가고 싶은 여행지 등 무엇이든 가능하다. 리스트는 보통 같은 유형의 자료들을 한꺼번에 보관하고, **항목들 사이에는 순서**가 있다. 리스트는 어떤 **연산**이 필요할까? 모든 자료구조에서 가장 기본적인 연산이 항목의 삽입과 삭제이다. 물론 다양한 추가기능을 부여할 수 있다. 리스트의 다양한 기능을 생각나는대로 적어보자.

* 어떤 위치에 항목을 **삽입(Insert)**하거나 **삭제(Delete)**한다.
* 리스트가 **공백상태(IsEmpty)**인지를 검사한다.
* 어떤 위치의 **항목을 꺼내지 않고 반환(GetEntry)**한다.
* **전체 항목의 개수(Size)**를 세어 반환한다.
* 리스트를 **초기화(Clear)**한다.
* 리스트에 어떤 항목이 있는지 **탐색(Find)**한다.
* 어떤 위치에 있는 항목을 새로운 항목으로 **대치(Replace)**한다.
* 리스트를 어떤 기준으로 다시 **정렬(Sort)**한다.
* 2개의 리스트를 **병합(Merge)**한다.
* 리스트를 화면에 보기 좋게 **출력(Display)**한다.
* 리스트의 맨 뒤에 새로운 항목을 **추가(Append)**한다.

이들을 바탕으로 리스트의 추상자료형(ADT)을 정의해보자. 앞에서 생각한 연산들을 모두 추가하는데, 약간 구체적으로 표시하면 된다.


정의 3.1 List ADT

* 데이터 : 같은 유형의 요소들의 순서있는 모임
* 연산
    - List() : 비어있는 새로운 리스트를 만든다.
    - **insert(pos, e)** : pos 위치에 새로운 요소 e를 삽입한다.
    - **delete(pos)** : pos 위치에 있는 요소를 꺼내고(삭제) 반환한다.
    - **isEmpty()** : 리스트가 비어있는지를 검사한다.
    - **getEntry(pos)** : pos 위치에 있는 요소를 반환한다.
    - size() : 리스트 안의 요소의 개수를 반환한다.
    - clear() : 리스트를 초기화한다.
    - find(item) : 리스트에서 item이 있는지 찾아 인덱스를 반환한다.
    - replace(pos, item) : pos에 있는 항목을 item으로 바꾼다.
    - sort() : 리스트의 항목들을 어떤 기준으로 정렬한다.
    - merge(lst) : 다른 리스트 lst를 리스트에 추가한다.
    - display() : 리스트를 화면에 출력한다.
    - append(e) : 리스트의 맨 뒤에 새로운 항목을 추가한다.

앞으로 공부할 대부분의 자료구조에서와 마찬가지로 리스트에서도 **삽입**과 **삭제**, **항목의 접근**, **공백상태 검사** 등이 가장 중요하고 핵심적인 연산이다. 왜냐하면, 이들 연산들을 이용해 다른 연산들을 대부분 구현할 수 있기 때문이다. 따라서 이러한 핵심적인 연산들에 집중해야 한다.


### 리스트는 배열구조와 연결된 구조로 구현할 수 있다.

리스트를 구현하는 방법을 살펴보자. 리스트와 같이 어떤 자료구조를 프로그램에서 표현하고 구현하기 위해 배열구조와 연결된 구조를 이용할 수 있다.


[그림 3.2] 자료구조 리스트의 2가지 구현 방법


* **배열(Array) 구조**는 같은 자료형의 데이터를 한꺼번에 만들 때 사용하는데, 대부분의 프로그래밍 언어에서 제공된다. 배열의 항목들에 접근하기 위해 **인덱스 연산자 []**를 사용하는데, 예를 들어, $A$가 배열이면 $A[2]$는 세번째 항목(인덱스는 보통 0부터 시작함)을 나타낸다. 특히 그림과 같이 모든 **항목들이 반드시 메모리에서 연속적인 공간**에 위치한다. 따라서 시작 항목의 주소와 한 항목의 크기만 알면 $k$번째 항목의 위치를 바로 계산할 수 있다. 즉, 배열이 아무리 크더라도 $k$번째 항목을 바로 찾아갈 수 있고, 따라서 **항목 접근의 시간복잡도가 $O(1)$**이다. 그러나 용량을 변경하기가 어렵고, 배열의 중간에 데이터를 넣고 빼는 등의 연산이 비효율적이라는 문제가 있다.
* **연결된 구조(Linked Structure)**는 오른쪽 그림과 같이 항목들을 줄로 연결하여 표현하는 방법이다. 인접한 항목이라고 메모리의 인접한 위치에 있다는 보장은 없다. 모든 항목들은 **링크를 이용해 다음 항목의 위치**만을 알고 있다. 배열과 달리 항목들이 인접해 있지 않기 때문에, 시작항목의 위치를 알더라도 $k$번째 항목의 위치를 바로 계산할 수 없다. 시작 항목부터 연결된 줄을 따라 $k - 1$번 움직여야 드디어 $k$번째 항목에 도착한다. 
따라서 **항목 접근의 시간복잡도가 $O(k)$**이다. 연결된 구조 중에서 위의 그림과 같이 자료들을 **일렬**로 나열할 수 있는 구조를 **연결 리스트(Linked List)**라 부른다. 연결된 구조는 장점은 많지만 연산들을 구현하기는 배열구조에 비해 훨씬 복잡하다.

이 책에서는 5장까지는 배열구조를, 6장에서 연결된 구조만으로 자료구조를 표현하고, 그 이후는 이들을 함께 사용한다.


### 리스트와 관련된 용어의 정리

파이썬에서는 리스트, 튜플, 딕셔너리, 집합과 같은 다양한 컬렉션 자료형을 기본으로 제공한다는 것을 2.6절에서 공부했다. 이 중에서 특히 리스트가 중요한데, 파이썬에서는 **배열**을 제공하지 않고, 리스트를 이용해 배열구조를 표현해야 하기 때문이다. 이러한 "파이썬의 리스트"는 **"자료구조 리스트"를 구현한 하나의 예**이다. 여러 의미로 사용되고 있는 "리스트"를 정확히 구분해보자.

* 파이썬 리스트 : C언어에서의 배열이 진화된 형태의 스마트한 배열이다. 이 책에서는 **배열 또는 배열구조의 의미**로 사용한다. 어떤 자료구조를 구현하기 위한 하나의 방법으로 사용한다.
* 연결 리스트 : 자료들이 일렬로 나열될 수 있는 **연결된 구조**를 말한다. **배열구조(파이썬의 리스트)에 대응되는 의미**로 사용한다.
* 자료구조 리스트 : **추상적인 의미**의 자료구조 리스트를 의미한다. 앞에서 우리는 이 **리스트의 ADT**를 정의하였다. 이를 구현하기 위해 배열구조(파이썬의 리스트)나 연결된 구조(연결 리스트)를 사용할 것이다.


대부분의 자료구조는 배열구조로도 구현할 수 있고 연결된 구조로도 구현할 수 있다. 물론 각각 장단점이 있다. 우리는 이 장에서 자료구조 리스트를 파이썬의 리스트(배열)를 이용해 구현할 것이고, 6장에서 다시 자료구조 리스트를 연결 리스트를 이용해 구현할 것이다. 약간은 혼란스러울 수 있지만, 용어의 의미를 정확히 이해해야 한다.


(그림)




## 3.2 파이썬의 리스트

### 파이썬 리스트는 스마트한 배열이다.

이 책 전반에서 파이썬의 리스트를 많이 사용한다. 따라서 파이썬의 리스트를 좀 더 정확히 이해하자. 리스트(List)는 파이썬에서 가장 많이 사용되는 컬렉션 자료형으로 배열과 같이 여러개의 데이터를 하나로 묶어서 저장하고 처리할 수 있다. 2.6절에서 우리는 파이썬 리스트를 사용하는 방법과 다양한 연산들을 살펴보았다. 파이썬의 리스트가 C언어의 배열과 어떻게 다른지를 살펴보자.

C언어에서 배열은 선언과 동시에 크기가 정해진다. 다음은 크기가 5인 정수(Int) 배열을 선언하고 초기화하는 C언어 코드이다. C언어에서는 자료형이 명시되어야 함에 유의하라.

``` C
int A[5] = {1, 2, 3, 4, 5};     // 정수 배열 A 선언 및 초기화
int B[5] = {0, 0, 0, 0, 0};     // 정수 배열 B 선언 및 초기화
```

다음은 이와 같은 의미의 파이썬 코드이다.

``` Python
A = [1, 2, 3, 4, 5]     # 파이썬 리스트 A
B = [0] * 5             # *로 같은 값을 반복하는 리스트를 만들 수 있음, B = [0, 0, 0, 0, 0]
```

배열의 크기는 어떻게 알 수 있을까? C언어는 배열의 길이를 어딘가에 저장해 두어야 하지만, 파이썬의 리스트는 그럴 필요가 없다. len() 함수를 이용하면 된다.

``` Python
print('파이썬 리스트 A의 크기는 ', len(A))      # A의 크기(항목 수) 출력
```

중요한 것은 지금부터이다. C언어의 배열은 크기를 늘릴 수 없다. 즉, 정수 5개를 위한 배열을 선언했으면 그 배열에 6개의 정수를 저장할 수 없는 것이다. 그러나 파이썬은 이것이 가능하다. 클래스로 구현되었고, 멤버 함수인 append, insert를 사용할 수 있다. 다음은 리스트에 항목을 추가하는 문장들이다.

``` Python
A.append(6)         # A = [1, 2, 3, 4, 5, 6]
A.append(7)         # A = [1, 2, 3, 4, 5, 6, 7]
A.insert(0, 0)      # A = [0, 1, 2, 3, 4, 5, 6, 7]
A.insert(9)         # B = [0, 0, 0, 0, 0, 9]
```

이 문장들은 리스트의 크기를 6, 7, 8로 증가시킨다. 이것은 C언어 배열에서는 도저히 상상할 수 없는 편리함이다. 파이썬은 어떤 방법으로 이러한 편리함을 지원할까?


### 파이썬 리스트는 동적배열로 구현되었다.

기본 아이디어는 **필요한 양보다 넉넉한 크기의 메모리를 사용**하는 것이다. 예를 들어, 실제로 **크기**가 3인 리스트가 필요하더라도 내부적으로 크기(**용량**)가 10인 배열을 할당하고, 맨 앞의 세 항목만 사용하는 것이다. C언어의 배열과 달리 **리스트의 크기**와 **리스트의 용량**을 정확히 구분해야 함에 유의하라.

현재 리스트의 **크기가 3**이고 **용량이 10**이라고 하자. 이 상태에서 **append(17) 연산**을 수행해보자. 여분의 공간이 있으므로 네번째 항목으로 추가하면 된다. 이제 리스트의 **크기는 4**이고 **용량은 10**이다.

[그림 3.3] 파이썬 리스트 삽입연산의 2가지 상황



만약 항목을 계속 추가해 리스트의 크기와 용량이 모두 10이 되고, 이제 남은 공간은 없다고 생각해보자. 이 상태에서 그림 3.3과 같이 **append(99) 연산**을 수행하려고 한다. 어떻게 할까? 무언가 다른 방법을 사용해야 한다. 파이썬 리스트는 **동적배열(Dynamic Array)**의 개념을 이용한다. 이것은 추가적인 공간이 필요하면 기존의 메모리를 모두 버리고 더 큰 새로운 메모리를 할당해 사용하는 것이다.


[그림 3.4] 동적배열구조에서의 용량 증가와 새 항목 삽입 과정



* Step 1 : 용량을 확장한 새로운 메모리를 할당한다. 예를 들어, 기존 용량의 2배인 크기가 20인 새로운 배열을 할당한다.
* Step 2 : 이전 메모리에 저장된 모든 항목들을 새로운 메모리로 복사한다. 항목 10개가 복사된다.
* Step 3 : 새로운 항목 99를 추가한다.
* Step 4 : 이제 리스트는 새로운 메모리를 가리키고, 이전 메모리는 해제한다. 리스트의 크기는 11이고 총 용량은 20으로 9개의 여유공간이 있다.

이와 같이 파이썬의 리스트는 용량을 늘릴 수 있어 편리하지만, **메모리의 낭비를 감수**해야 한다. 대부분의 경우 사용하고 있는 메모리 외에 추가로 삽입될 항목을 위한 메모리를 준비하고 있어야 하기 때문이다. 이에 비해, **튜플**은 용량을 변경할 수 없으므로 메모리 측면에서 더 효율적이라 볼 수 있다.


### 파이썬 리스트의 시간복잡도

파이썬의 리스트를 이용해 다양한 자료구조를 구현할 때 연산들의 시간복잡도를 정확히 분석하려면 먼저 파이썬 리스트 자체의 연산들에 대한 시간복잡도를 알아야 한다. 파이썬 리스트의 삽입과 삭제 연산의 시간복잡도를 살펴보자.


### Append() 연산의 시간복잡도

append() 연산의 시간복잡도는 상황에 따라 다르다. 리스트에 남은 용량이 있다면 바로 처리된다. 그림 3.3의 왼쪽과 같이 빈 공간에 바로 삽입하면 되기 때문이다. 따라서 시간복잡도가 $O(1)$이다. 만약 append 시점이 용량을 늘려야 하는 경우라면 어떻게 될까? 그림 3.4와 같이 내부적으로 새로운 배열을 할당하고 기존 항목들을 모두 복사해야 한다. 따라서 최소한 $O(n)$의 시간이 소요된다. 그러나 만약 이러한 상황이 매우 가끔 발생한다고 가정한다면 **append 연산의 시간복잡도는 $O(1)$**으로 볼 수 있다.


### Insert() 연산의 시간복잡도

그렇다면 insert 연산은 어떨까? 여분의 용량이 남아있는 경우만을 생각하자. 리스트의 크기가 5인 상태에서 맨 앞에 새로운 항목을 추가하는 A.insert(0, 'N') 연산을 생각해보자. 항목을 바로 맨 앞에 끼워넣을 수 없다. 그림 3.5와 같이 모든 항목들을 먼저 한 칸씩 뒤로 이동시킨 후 0번째 항목에 값을 복사해야 한다.


[그림 3.5] 배열구조에서 맨 앞에 항목을 삽입하는 과정


이 연산의 시간복잡도는 어떻게 될까? 당연히 $O(n)$이다. 즉, 파이썬 리스트는 후단 삽입은 효율적이지만 중간이나 전단 삽입은 항목의 이동이 발생하여 비효율적이라는 것을 알 수 있다.


### Pop() 연산의 시간복잡도

이것은 삭제연산 pop에서도 마찬가지이다. 만약 s.pop(0)으로 첫번째 항목을 삭제하려면 그림과 같이 이후의 모든 항목들을 앞으로 당겨야 한다.

[그림 3.6] 배열구조에서 맨 앞 항목을 삭제하는 과정



결론적으로 **파이썬 리스트**에서 후단 삽입이나 삭제는 효율적이지만 **중간이나 전단에 항목을 넣거나 빼는 것은 비효율적**이라는 것을 명심하라. 즉, 가능한 한 삽입은 A.append()를, 삭제는 A.pop(-1)을 사용하는 것이 좋다. 이때, 음수 인덱스 -1은 len(A)-1과 동일한데, 리스트의 맨 마지막 항목의 인덱스이다.


> len()은 항목 수를 반환하는 파이썬 내장함수이다. 파이썬은 다양한 내장 함수를 제공하는데, print()와 input()을 비롯하여 자료형 판별, 자료형 변환, 간단한 수학연산 등 다양한 함수가 제공된다. 이러한 내장함수들은 외부 모듈들과 달리 import를 필요로 하지 않고, 아무런 설정없이 바로 사용할 수 있다.



## 3.3 배열로 구현한 리스트

### 배열구조로 자료구조 리스트를 구현하자.

자료구조 리스트의 항목들을 저장하는 가장 간단한 방법은 배열구조를 이용하는 것이다. 물론 배열구조로는 파이썬의 리스트를 이용한다. 이 리스트의 이름을 items라고 하고 다음과 같이 전역변수로 정의한다. 맨 처음에는 items가 공백이 되어야 한다.

``` Python
items = []      # 리스트 항목 저장을 위한 파이썬 리스트
```

리스트 ADT의 연산들을 하나씩 구현해보자. 사실 필요한 연산이 대부분 파이썬 리스트에 있기 때문에 할 일이 별로 없다. 파이썬의 리스트가 "자료구조 리스트를 구현한 하나의 예"라는 것을 기억하라. 이미 파이썬의 리스트에 많은 기능들이 구현되어 있다. 따라서 리스트 ADT에서 정의한 연산들을 위해 파이썬 리스트 클래스의 멤버함수들을 적절히 호출해주기만 하면 된다.


# Insert(pos, elem) : 삽입 연산

삽입연산은 파이썬 리스트의 insert()를 사용하면 간단히 처리된다. append가 항상 맨 뒤에 삽입하는 것과 달리 이 함수는 위치를 지정해 삽입할 수 있다.

``` Python
def insert(pos, elem):          # pos 위치에 새로운 요소 elem을 삽입한다.
    items.insert(pos, elem)     # 파이썬 리스트 클래스의 insert 연산
```


### delete(pos) : 삭제 연산

삭제 연산도 파이썬 리스트의 pop 연산을 이용하면 간단하다. pop은 삭제할 위치를 지정하여 그 항목을 삭제한다.

``` Python
def delete(pos):            # pos 위치에 있는 요소를 꺼내고 반환한다.
    return items.pop(pos)   # 파이썬 리스트 클래스의 pop 연산
```


### getEntry(pos) : 항목 접근 연산

리스트의 pos번째 항목에 접근하는 것은 리스트에 인덱스 연산자를 적용해 간단히 처리할 수 있다. 즉, items[pos]는 리스트 items의 pos번째 항목을 반환한다. 이 연산은 다음과 같이 **한 줄로 간결하게 표현**해도 어려워보이지 않는다.

``` Python
def getEntry(pos):
    return items[pos]   # pos번째 항목 반환
```


### isEmpty() : 공백상태 검사와 기타 함수들

리스트가 공백상태인지를 검사하기 위해서는 항목의 개수를 알아야 한다. 이때 항목 수를 반환하는 파이썬 내장함수 len()을 사용하면 된다. 공백상태는 다음과 같이 구현된다.

``` Python
def isEmpty():
    if len(items) == 0:     # 크기가 0이면
        return True         # True를 반환
    else:                   # 크기가 0이 아니면
        return False        # False를 반환
```

공백상태는 리스트의 크기가 0인 경우이다. 이러한 문장들은 더 간결하게 나타낼 수 있다. 즉, len(items) == 0 문장 자체가 맞으면 True 아니면 False이므로 if문을 사용하지 않고 다음 코드와 같이 return으로 바로 반환하면 된다.

``` Python
def isEmpty():
    return len(items) == 0  # 크기가 0이면 True 아니면 False
```

이 코드는 여러 줄로 구현한 것과 정확히 동일하며 코드가 간결해진다. 동일한 기능이라면 코드가 길어서 좋은 점은 거의 없다.


### 기타 함수들

리스트의 크기는 isEmpty와 같이 len() 함수를 사용하면 된다. 리스트 초기화는 items = []로 처리되었다. 이 코드는 사실 문제가 있다. 어떤 문제일까? 쉽지는 않겠지만 한번 생각해보자.

``` Python
def size():             
    return len(items)   # 리스트의 크기 반환. len() 함수 이용

def clear():
    items = []          # items를 초기화 --> 오류
```

리스트 ADT의 나머지 연산들도 파이썬 리스트의 멤버함수로 쉽게 구현된다. 다음 코드에서 리스트의 멤버함수가 어떻게 사용되는지 살펴보자.

``` Python
def find(item):
    return items.index(item)    # 탐색 후 인덱스 반환

def replace(pos, elem):
    items[pos] = elem           # pos번째 항목 변경

def sort():
    items.sort()                # 정렬(sort 메소드 이용)

def merge(lst):
    items.extend(lst)           # 병합(확장)
```


### display() : 화면출력 함수

리스트는 어떻게 화면으로 출력할 수 있을까? print() 함수를 사용하면 된다. (2.4절 참조) 특히 이 함수에 리스트와 같은 내장 자료형의 객체를 인수로 전달해도 알아서 잘 출력해준다. 코드는 다음과 같다.

``` Python
def display(msg = 'ArrayList'):     # 출력 : 디폴트 인수 사용
    print(msg, size(), items)       # 메시지 + 크기 + 배열내용 출력
```

화면출력을 위한 display 함수에서는 **디폴트 인수(Default Argument)**를 사용하였다. 이 함수로 출력하고자 하는 리스트의 형태는 다음과 같다.

``` Python
메시지 항목수 [항목0, 항목1, ..., 항목n-1]
```

``` Python
디폴트 인수는 함수의 매개변수에 기본 값을 부여하는 기능으로, 함수 호출시 인수가 주어지면 그 인수를 사용하고, 만약 인수가 생략되면 기본 값을 사용하는 방법이다. (2.7절 참조) C++, Java 등 다른 언어에서도 많이 사용되지만 파이썬에서도 매우 유용하게 사용되므로 잘 이해하고 활용하는 것이 좋다.
```


### 테스트 프로그램

지금까지 구현한 리스트를 사용해보자. 테스트 코드는 다음과 같다. 파이썬에서는 코드의 들여쓰기가 매우 중요하고, 따라서 가급적 한 줄에 한 문장을 기술하는데, 다음 코드는 2~3번째 줄에서 한 줄에 여러 문장(비슷한)을 넣기 위해 세미콜론(;)을 사용하였다. (특별한 의미는 없고, 라인 수를 줄이기 위해 사용됨)

``` Python
display('파이썬 리스트로 구현한 리스트 테스트')
insert(0, 10); insert(0, 20); insert(1, 30)
insert(size(), 40); insert(2, 50)   # 한 줄에 여러 문장을 넣기 위해 ; 사용
display('파이썬 리스트로 구현한 List(삽입 x 5):')
sort()
display('파이썬 리스트로 구현한 List(정렬 후):')
replace(2, 90)
display('파이썬 리스트로 구현한 List(교체 x 1):')
delete(2); delete(size() - 1); delete(0)
display('파이썬 리스트로 구현한 List(삭제 x 3):')
lst = [1, 2, 3]
merge(lst)
display('파이썬 리스트로 구현한 List(병합 + 3):')
clear()
display('파이썬 리스트로 구현한 List(정리 후):')
```

리스트에 5개의 항목을 위치를 지정해 삽입하고, 리스트를 출력한다. 다음으로 리스트를 정렬한 후 출력, 항목 변경 후 출력, 삭제 연산과 병합 연산 등을 수행한 후 결과를 출력하였다. 결과는 다음과 같다.


대부분의 결과가 예상대로일 것이다. 그런데 한 가지 문제가 있다. clear()가 제대로 동작하지 않았다. 왜 그럴까? **items를 함수 내의 지역변수로 인식**하기 때문이다. 즉, 전역변수로 items가 있더라도 함수 내에서 이것이 전역변수임을 선언하지 않으면 **items = [] 문장은 새로운 지역변수 items를 만들게 되는 것**이다. (2.8절 변수의 범위 참조) 따라서 items를 전역변수라고 지정해주는 문장이 다음과 같이 필요하다.

``` Python
def clear():
    global items    # items가 전역변수임을 지정
    items = []      # 이제 전역변수 items를 초기화
```

다른 함수들은 모두 새로운 변수 items를 **만드는 것이 아니라** 어딘가에 있는 items를 **"사용"하는 코드**이기 때문에 전역변수로 지정하지 않아도 문제없다.

지금까지 자료구조 리스트를 배열(파이썬의 리스트)을 이용해 구현하였다. 너무 많은 것을 파이썬의 리스트 클래스가 처리해서 사실 우리가 한 일은 별로 없지만 어쨌든 우리만의 리스트가 구현되었고, 이제 이를 이용해 문제를 해결할 수 있다.


### 시간복잡도 분석

연산들의 시간복잡도는 사용한 파이썬 함수들의 시간복잡도에 따라 결정된다. 주요 함수의 복잡도를 따져보자.

* **삽입(insert)과 삭제(delete)** 연산에서 파이썬 리스트의 insert와 pop 메소드를 사용하였다. 따라서 최선의 경우는 pos가 리스트의 맨 뒤쪽인 경우로 시간복잡도가 $O(1)$이다. 그러나 그렇지 않은 대부분의 경우는 그림 3.5나 3.6과 같이 배열의 특성에 따라 많은 항목의 이동이 필요하다. 따라서 최악이나 평균적인 **시간복잡도는 $O(n)$**이다.








### 클래스로 구현하는 것이 더 좋은 방법이다.

그런데 아직 하나의 문제가 있다. 여러개의 리스트를 사용하려면 어떻게 할까? 예를 들어, 다항식을 리스트로 표현하고, 두 다항식을 더한 결과를 구하려면 최소한 3개의 리스트가 필요하다. 그러나 앞에서 구현한 방법에서는 전역변수로 하나의 배열 items를 사용하고 함수를 만들었기 때문에 하나의 리스트만을 이용할 수 있다. 방법이 없을까? 물론 모든 **함수의 매개변수에 배열을 추가**하는 것도 방법이다. (1.2절의 Bag을 함수로 구현한 코드 참조) 예를 들어, 공백상태 검사 함수를 isEmpty()가 아니라 isEmpty(A)로 하고 배열(파이썬의 리스트) A를 전달하면 된다. 이 방법을 사용하면 대부분의 함수에 매개변수가 하나 늘어난다.

**자료구조를 구현하는 가장 좋은 방법은 클래스**이다. 예를 들어, 리스트의 ADT를 클래스로 구현하면 파이썬의 리스트와 같이 리스트 객체를 마음대로 만들어 사용할 수 있다. 2.10절을 참고하여 이제 리스트를 클래스로 만들기 위해 필요한 작업을 구체적으로 살펴보자.

* 필요한 **클래스를 선언**한다.
* 전역변수로 선언되었던 **데이터를 멤버변수**로 클래스에 **넣는다**. 그 방법은 **생성자(Constructor)**로 불리는 `__init__()` 함수에서 그 변수를 선언하는 것이다.
* 일반함수로 구현된 자료구조의 **연산**을 클래스의 **멤버함수(또는 메소드)**로 바꾸어 클래스에 넣는다. 이때 클래스의 멤버함수임을 나타내기 위해 첫번째 매개변수로 self가 추가되어야 한다.
* 클래스의 멤버함수에서 객체 자신의 데이터를 사용하거나 멤버 함수를 호출하기 위해 self.을 앞에 넣어준다. 예를 들어, 멤버함수에서 x = 10은 새로운 변수 x를 만드는 것이고, self.x = 10은 클래스의 데이터 x에 값을 할당하는 것이다. 멤버함수도 마찬가지이다. 클래스 안에서 isEmpty()는 일반함수이고 self.isEmpty()는 그 클래스의 멤버함수를 말한다.

``` Python
사실 이름이 self가 아니고 다른 이름을 사용해도 문제는 없다. 그렇지만 통상적으로 self를 사용한다. 이것은 C++에서의 this와 비슷한 의미이다. this는 C++에서는 키워드이지만 self는 그냥 멤버함수에서 객체 자신을 나타내는 변수로 생각하면 된다.
```

조금 복잡해보인다. 클래스를 만드는 것도 익숙하지 않고, 사용하는 방법도 약간 어색할 것이다. 다음 코드를 통해 함수로 구현한 코드와 비교해보자. 클래스의 이름은 배열을 이용한 리스트의 의미로 ArrayList로 한다. 먼저, 클래스 선언과 생성자 함수는 다음과 같다.

``` Python
class ArrayList():          # 클래스 선언

    def __init__(self):     # 생성자 (2.10절 참조)
        self.items = []     # 클래스 변수 선언 및 초기화
    
    def insert(self, pos, elem):
        self.items.insert(pos, elem)
    
    def delete(self, pos):
        return self.items.pop(pos)
    
    def isEmpty(self):
        return self.size() == 0

    def getEntry(self, pos):
        return self.items[pos]
    
    def size(self):
        return len(self.items)
    
    def clear(self):
        self.items = []     # items는 멤버변수(global 아님)
    
    def find(self, item):
        return self.items.index(item)

    def replace(self, pos, elem):
        self.items[pos] = elem



```

이어서 앞에서 구현한 함수들을 넣으면 된다. 이때 **들여쓰기**를 반드시 고려해야 하는데, 이들은 모두 클래스 정의 블록에 포함되는 멤버함수이기 때문이다. 함수의 **첫번째 매개변수로 self가 추가**되어야 하는 것과 클래스 멤버를 **사용할 때 self.을 앞에 넣어야 한다**는 것만 명심하면 된다. 메소드의 구현내용은 앞에서 구현한 내용과 정확히 동일하다.

items는 더 이상 전역변수가 아니며 클래스의 멤버변수이므로 clear() 메소드에서 global을 이용해 전역변수로 처리할 필요가 없는 것에 유의하자. 클래스를 사용하는 것도 어렵지 않다. 리스트 객체를 먼저 만들고 그 객체를 통해 함수를 호출하면 된다.

* 먼저 리스트 객체를 만들어야 한다. s = ArrayList()와 같이 사용하는데, 이제 여러개의 리스트를 만들어 사용해도 전혀 문제가 없다.
* 리스트의 메소드나 멤버변수를 사용하려면 반드시 스택 객체를 통해야 한다. 예를 들어, 리스트 s의 2번 위치에 50을 삽입하려면 s.insert(2, 50)와 같이 작성해야 한다.

클래스 버전의 테스트 코드는 다음과 같다.

``` Python
s = ArrayList()
s.display('파이썬 리스트로 구현한 리스트 테스트')
s.insert(0, 10);        s.insert(0, 20);     s.insert(1, 30)
s.insert(s.size(), 40); s.insert(2, 50)
s.display('파이썬 리스트로 구현한 List(삽입 x 5):')
s.sort()
s.display('파이썬 리스트로 구현한 List(정렬 후):')
s.replace(2, 90)
s.display('파이썬 리스트로 구현한 List(교체 x 1):')
s.delete(2);    s.delete(s.size() - 1);    s.delete(0)
s.display('파이썬 리스트로 구현한 List(삭제 x 3):')
lst = [1, 2, 3]
s.merge(lst)
s.display('파이썬 리스트로 구현한 List(병합 + 3):')
s.clear()
s.display('파이썬 리스트로 구현한 List(정리 후):')
```

실행결과는 동일하다. 그렇지만 클래스로 만들면 이제 리스트 객체를 마음대로 만들어 사용할 수 있다. 시간복잡도는 함수로 구현한 경우와 동일하다.

> 파이썬에서는 모든 것이 객체이다. 심지어 정수(int)나 실수(float), 부울(bool)조차도 클래스로 구현되어 있다. 결국 클래스와 객체의 개념 및 메소드 호출 등에 익숙해야 파이썬의 강력한 내장 자료형과 다양한 기능들을 효율적으로 사용할 수 있다. 그래도 클래스는 어렵게 느껴질 수 있으므로 이 책에서는 가능한 한 함수로 설명하려고 했으며, 꼭 필요한 경우에 클래스를 이용해 구현하였다.

ArrayList의 대부분의 연산들은 파이썬 리스트의 멤버함수로 구현했지만 이들을 사용하지 않고 직접 구현할수도 있다. 예를 들어, 리스트의 후단에 삽입과 삭제를 하는 append()와 pop(-1) 만을 이용하여 insert()와 delete() 연산을 구현할 수 있다. 실습문제 P3.1에 도전해보자.


## 3.4 리스트의 응용 : 라인 편집기 

우리가 만든 ArrayList 클래스를 이용하여 아주 간단한 텍스트 편집기를 만들어보자. 이것은 **라인 편집기(Line Editor)**라고 불리는데 라인 단위로 입력이나 삭제를 할 수 있는 문서 편집기이다. 이 편집기는 고정된 수의 명령어들을 받아서 동작하며 커서를 사용하지 않는다. 따라서 현재 우리가 사용하고 있는 편집기와는 많은 차이가 있지만 편집기의 기본적인 아이디어를 공부할 수 있다.

라인 편집기는 리스트로 구현할 수 있는데, 리스트의 하나의 항목이 한 줄의 문자열을 나타낸다. 다음과 같은 기능을 갖도록 설계하자.

[그림 3.7] 리스트를 이용한 문서의 내부적인 표현


* 명령 i : 라인 삽입. 행 번호와 문자열을 입력하면 그 행에 한 라인 추가
* 명령 d : 한 라인 삭제. 행 번호를 입력하면 그 행을 삭제
* 명령 r : 한 라인 변경. 행 번호와 문자열을 입력하면 그 행의 내용을 변경
* 명령 p : 현재 내용 출력. 현재 문서의 모든 내용을 라인 번호와 함께 출력
* 명령 l : 파일 입력. 지정된 (test.txt) 파일로부터 라인을 읽어들임.
* 명령 s : 파일 출력. 지정된 (test.txt) 파일로 편집내용을 저장

물론 파일 이름을 지정하지 않고 임의의 파일을 사용하도록 하는 것이 더 일반적일 것이다. 구현한 함수와 테스트 코드는 다음과 같다.

``` Python
def myLineEditor():                             # 라인 편집기 주 함수
    list = ArrayList()                          # 리스트 객체 생성

    while True:
        command = input('[메뉴선택] i-입력, d-삭제, r-변경, p-출력, l-파일읽기, s-저장, q-종료 ==> ')
        
        if command == 'i':                      # 삽입 연산
            pos = int(input(' 입력행 번호:'))    # 삽입할 행 번호 입력
            str = input(' 입력행 내용:')         # 삽입할 행 내용 입력
            list.insert(pos, str)               # insert 메소드로 삽입
        elif command == 'd':                    # 행 삭제
            pos = int(input(' 삭제행 번호:'))    # 삭제할 행 번호 입력
            list.delete(pos)                    # delete 메소드로 삭제
        elif command == 'r':                    # 행 내용 변경
            pos = int(input(' 변경행 번호:'))    # 변경할 행 번호 입력
            str = input(' 변경행 내용:')         # 변경할 행 내용 입력
            list.replace(pos, str)              # replace로 변경
        elif command == 'q':                    # 프로그램 종료
            return
        elif command == 'p':                    # 문서 출력
            print('Line Editor')
            for line in range(list.size()):         # 모든 라인에 대해
                print('[%2d] ' % line, end = '')    # 라인 번호와
                print(list.getEntry(line))          # 행 내용 출력
            print()                                 # 한 줄 띄움
        elif command == 'l':                        # 파일 입력
            filename = 'test.txt'
            infile = open(filename, 'r')            # 파일 열기(읽기 모드)
            lines = infile.readlines()              # 파일의 모든 내용을 읽음
            for line in lines:                      # 읽혀진 각 행에 대해
                list.insert(list.size(), line.rstrip('\n'))
            infile.close()                          # 파일 닫기
        elif command == 's':                        # 파일 저장
            filename = 'test.txt'
            outfile = open(filename, 'w')           # 파일 열기(쓰기 모드)
            for i in range(list.size()):
                outfile.write(list.getEntry(i) + '\n')
            outfile.close()
myLineEditor()      # 라인 편집기 주 함수 호출
```

* 키보드 입력함수 input()을 이용해 사용자 입력을 받는다. input()은 하나의 문자열을 전달하여 사용자에게 어떤 정보를 기다린다는 것을 표시한다.
* 자료형 변환 함수 int()를 사용하였다. input()은 결과를 문자열로 반환하는데, 문자열을 정수(행 번호)로 변경하기 위해 이 함수를 사용한다. 예를 들어 int('12')는 정수 12를 반환한다. 파이썬의 다양한 자료형 변환 함수를 검색해보자.
* 대부분의 명령은 ArrayList의 메소드를 호출했지만 화면출력 명령 p에서는 새로운 코드를 사용하였다. 요구하는 출력형식이 우리가 만든 리스트 클래스의 display와 다르기 때문이다. 리스트의 한 항목을 한 줄로 화면에 출력한다.
* **컴퓨터에서 파일을 사용**하기 위해서는 먼저 열어야 하는데, 이를 위해 open() 함수를 사용하였다. 파일은 읽기 위해, 또는 쓰기 위해 열 수 있는데, 이를 위해 open() 함수의 매개변수로 읽기('r') 또는 쓰기('w') 모드를 지정해야 한다. 성공적으로 파일이 열리면 **open()**은 파일 객체를 반환한다. 파일 객체는 사용이 끝나면 반드시 닫아야 하는데, 이를 위해 **close()** 메소드를 사용한다.
* 파일 객체에서 **readlines()** 메소드를 이용해 파일 내의 모든 문자열을 한꺼번에 읽을 수 있다. 이를 lines에 저장하였는데, lines는 각 라인별로 나누어진 문자열의 리스트이다. 각 문자열의 마지막에 '\n'이 있는 경우 이를 제거하기 위해 문자열 클래스의 **rstrip()** 함수를 사용하였다.
* 파일 저장 명령도 쓰기 명령과 대부분 유사한데, 파일 객체의 **write()** 함수를 이용해 각 항목(각 라인 문자열)을 순서대로 파일에 저장하였다. 다양한 파일 입출력은 인터넷 참고자료를 활용하자.

다음은 구현된 라인 편집기의 사용 예시이다. 원하는 줄에 문장을 삽입하고, 내용을 출력하며, 원하는 행을 삭제하였다.










다음은 ArrayList 클래스의 코드 일부가 저장된 Test.txt를 읽고 5번 줄을 self에서 this로 변경하는 예를 보여준다.









다양한 파일 입출력에 대해서는 관련 도서와 인터넷을 참고하자.


## 3.5 집합이란?

리스트와 비슷한 개념으로 집합이 있다. 집합은 원소의 중복을 허용하지 않으며 원소들 사이에 순서가 없다는 면에서 리스트와는 다르다. 원소들이 어떤 위치를 가지지도 않고, 원소들을 일렬로 나열하는 의미도 적용되기 어렵기 때문에 선형자료구조로 볼 수 없다. 집합(Set)은 $S = \{ elem_0, elem_1, elem_2, ..., elem_{n-1} \} $과 같이 표현된다.

[그림 3.8] 집합의 다양한 연산들

집합의 추상자료형을 정의해보자. 지금까지 수학에서 공부한 집합의 개념들을 반영하여 집합 ADT를 다음과 같이 정의할 수 있다.

정의 3.2 Set ADT

* 데이터 : 같은 유형의 유일한 요소들의 모임. 원소들은 순서는 없지만 서로 비교할 수는 있어야 함.
* 연산
    - Set() : 비어있는 새로운 집합을 만든다.
    - size() : 집합의 원소의 개수를 반환한다.
    - contains(e) : 집합이 원소 e를 포함하는지를 검사하고 반환한다.
    - insert(e) : 새로운 원소 e를 삽입함. 이미 e가 있다면 삽입하지 않음.
    - delete(e) : 원소 e를 집합에서 꺼내고(삭제) 반환한다.
    - equals(setB) : setB와 같은 집합인지를 검사.
    - union(setB) : setB와의 합집합을 만들어 반환한다.
    - intersect(setB) : setB와의 교집합을 만들어 반환한다.
    - difference(setB) : setB와의 차집합을 만들어 반환한다.
    - display() : 집합을 화면에 출력한다.


## 3.6 집합의 구현

집합을 구현할 수 있는 방법은 다양하다. 그리고 어떤 방법을 사용하는가에 따라 연산들의 성능이 달라진다. 파이썬에서도 집합을 내장자료형으로 제공한다. 이 장에서 우리는 이것을 사용하지 않을 것이다. 일단 배열구조를 이용해 집합을 구현해보자. 집합은 합집합, 교집합 등과 같이 집합 사이의 연산이 많으므로 여러개의 집합이 사용될 것이고, 따라서 클래스를 이용해 구현하자. 클래스의 이름을 Set이라 하고, 앞에서 정의한 집합 ADT를 구현해보자. 클래스 선언과 생성자 및 간단한 메소드 구현 코드는 다음과 같다.

``` Python
class Set():                        # 집합 클래스

    def __init__(self):             # 생성자
        self.items = []             # 원소를 저장하기 위한 리스트 생성

    def size(self):                 # 집합의 크기
        return len(self.items)      # len() 함수 사용
    
    def display(self, msg):         # 화면에 출력
        print(msg, self.items)      # 메시지 + 집합내용 출력

    # 집합이 item을 포함하고 있는지를 확인하는 contains() 연산에서
    # 파이썬의 멤버쉽 연산자인 in을 사용할 수 있다.
    def contains(self, item):
        return item in self.items   # item이 self.items에 있는지 검사

    # in 연산자를 사용하지 않더라도 다음과 같이 반복구조로 구현할 수 있다.
    def contains2(self, item):
        for i in range(len(self.items)):    # self.items의 모든 항목에 대해
            if self.items[i] == item:       # item이 self.items[i]와 같으면
                return True                 # 집합 내에 있으므로 return True
        return False                        # 없음. return False

    # 삽입연산에서 원소의 중복을 피하기 위해 삽입할 항목이 이미 있는지 먼저 검사해야 한다.
    def insert(self, elem):
        if elem not in self.items:
            self.items.append(elem)

    # 삭제연산도 삭제할 원소가 있는 경우에만 가능하다.
    def delete(self, elem):
        if elem in self.items:
            self.items.remove(item)

    # 이제 집합간의 연산을 구현하자. 
    # 합집합과 교집합 및 차집합을 위한 코드는 다음과 같이 형태가 비슷하다.
    def union(self, setB):                  # C = self U B
        setC = Set()                        # 결과 집합
        setC.items = list(self.items)       # self의 리스트를 setC에 복사
        for elem in setB.items:             # 외부루프 : setB의 모든 항목에 대해
            if elem not in self.items:      # 내부루프 : self에 없으면
                setC.items.append(elem)     # 중복이 아니므로 추가함
        return setC                         # 결과를 반환

    def intersect(self, setB):              # C = self ^ B
        setC = Set()
        for elem in setB.items:             # 외부루프 : setB의 모든 항목에 대해
            if elem in self.items:          # 내부루프 : self에 있으면
                setC.items.append(elem)     # 양쪽에 모두 있음 --> 추가함
        return setC

    def difference(self, setB):             # C = self - B
        setC = Set()
        for elem in self.items:             # 외부루프 : self의 모든 항목에 대해
            if elem not in setB.items:      # 내부루프 : setB에 없으면
                setC.items.append(elem)     # 추가함
        return setC
```

``` Python
in은 강력한 연산자로 파이썬의 특징을 잘 보여준다. x in y는 리스트와 같은 시퀀스 객체 y에 x가 있는지를 검사하고, 있으면 True를 없으면 False를 반환한다.
```

테스트를 위한 코드는 다음과 같다. 2개의 공백 집합 객체를 만들어 원소를 삽입 및 삭제해보고, 합집합과 교집합 및 차집합을 구해본다.

``` Python
setA = Set()
setA.insert('휴대폰')
setA.insert('지갑')
setA.insert('손수건')
setA.display('Set A:')

setB = Set()
setB.insert('빗')
setB.insert('파이썬 자료구조')
setB.insert('야구공')
setB.insert('지갑')
setB.display('Set B:')

setB.insert('빗')
setA.delete('손수건')
setA.delete('발수건')
setA.display('Set A:')
setB.display('Set B:')

setA.union(setB).display('A U B:')
setA.intersect(setB).display('A ^ B:')
setA.difference(setB).display('A - B:')
```



### 시간복잡도 분석

연산들의 시간복잡도를 살펴보자.

먼저 삽입과 삭제연산은 어떨까? 삽입을 위해서는 중복을 검사해야 하고, 삭제를 위해서는 원소가 집합에 있는지를 검사해야 한다. 중복의 검사는 in 연산자를 이용해 간단하게 구현되었지만 파이썬 리스트에 대한 in 연산은 원소의 개수에 비례하는 시간이 걸린다. (7장의 순차탐색 방법을 이용한다.) 즉, 반복구조로 구현된 contains() 연산과 같은 시간이 걸리고, 결국 삽입이나 삭제 모두 시간복잡도는 $O(n)$이다.

합집합, 교집합, 차집합 연산의 시간복잡도는 어떻게 될까? 코드에서 외부루프는 당연히 원소의 개수에 비례해서 반복된다. 내부루프는 in 연산자를 사용해 반복으로 보이지 않지만 반복으로 검사할 수 밖에 없다. 결국 내부루프도 원소의 개수에 비례하는 시간이 걸린다. 만약 모든 집합의 원소의 개수가 $n$이라면 이들 알고리즘은 $O(n^2)$이다.

집합은 다양한 방법으로 구현할 수 있는데, 이 절에서 사용한 리스트 뿐 아니라 트리구조(8~9장)나 해싱(7장) 등의 방법들이 사용되기도 한다. 물론 구현방법에 따라 연산들의 성능도 영향을 받는다. 7장에서는 리스트를 이용해 구현한 집합에서 원소들을 정렬하는 방법으로 몇 가지 연산의 성능을 개선하는 방법을 소개한다.

---

## Reference

* <파이썬으로 쉽게 풀어쓴 자료구조와 알고리즘> 3장
